{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { isScalar, isAlias, isSeq, isMap } from '../../nodes/identity.js';\nimport { Scalar } from '../../nodes/Scalar.js';\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n  identify: value => value === MERGE_KEY || typeof value === 'symbol' && value.description === MERGE_KEY,\n  default: 'key',\n  tag: 'tag:yaml.org,2002:merge',\n  test: /^<<$/,\n  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {\n    addToJSMap: addMergeToJSMap\n  }),\n  stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n  if (isSeq(value)) for (const it of value.items) mergeValue(ctx, map, it);else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map, it);else mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n  if (!isMap(source)) throw new Error('Merge sources must be maps or map aliases');\n  const srcMap = source.toJSON(null, ctx, Map);\n  for (const [key, value] of srcMap) {\n    if (map instanceof Map) {\n      if (!map.has(key)) map.set(key, value);\n    } else if (map instanceof Set) {\n      map.add(key);\n    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n      Object.defineProperty(map, key, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  return map;\n}\nexport { addMergeToJSMap, isMergeKey, merge };","map":{"version":3,"names":["isScalar","isAlias","isSeq","isMap","Scalar","MERGE_KEY","merge","identify","value","description","default","tag","test","resolve","Object","assign","Symbol","addToJSMap","addMergeToJSMap","stringify","isMergeKey","ctx","key","type","PLAIN","doc","schema","tags","some","map","it","items","mergeValue","Array","isArray","source","Error","srcMap","toJSON","Map","has","set","Set","add","prototype","hasOwnProperty","call","defineProperty","writable","enumerable","configurable"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/schema/yaml-1.1/merge.js"],"sourcesContent":["import { isScalar, isAlias, isSeq, isMap } from '../../nodes/identity.js';\nimport { Scalar } from '../../nodes/Scalar.js';\n\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nconst MERGE_KEY = '<<';\nconst merge = {\n    identify: value => value === MERGE_KEY ||\n        (typeof value === 'symbol' && value.description === MERGE_KEY),\n    default: 'key',\n    tag: 'tag:yaml.org,2002:merge',\n    test: /^<<$/,\n    resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {\n        addToJSMap: addMergeToJSMap\n    }),\n    stringify: () => MERGE_KEY\n};\nconst isMergeKey = (ctx, key) => (merge.identify(key) ||\n    (isScalar(key) &&\n        (!key.type || key.type === Scalar.PLAIN) &&\n        merge.identify(key.value))) &&\n    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);\nfunction addMergeToJSMap(ctx, map, value) {\n    value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (isSeq(value))\n        for (const it of value.items)\n            mergeValue(ctx, map, it);\n    else if (Array.isArray(value))\n        for (const it of value)\n            mergeValue(ctx, map, it);\n    else\n        mergeValue(ctx, map, value);\n}\nfunction mergeValue(ctx, map, value) {\n    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\n\nexport { addMergeToJSMap, isMergeKey, merge };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}