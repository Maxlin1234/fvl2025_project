{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n  const coll = token.type === 'block-map' ? resolveBlockMap(CN, ctx, token, onError, tag) : token.type === 'block-seq' ? resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection(CN, ctx, token, onError, tag);\n  const Coll = coll.constructor;\n  // If we got a tagName matching the class, or the tag name is '!',\n  // then use the tagName from the node class used to create it.\n  if (tagName === '!' || tagName === Coll.tagName) {\n    coll.tag = Coll.tagName;\n    return coll;\n  }\n  if (tagName) coll.tag = tagName;\n  return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n  const tagToken = props.tag;\n  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n  if (token.type === 'block-seq') {\n    const {\n      anchor,\n      newlineAfterProp: nl\n    } = props;\n    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;\n    if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n      const message = 'Missing newline after block sequence props';\n      onError(lastProp, 'MISSING_CHAR', message);\n    }\n  }\n  const expType = token.type === 'block-map' ? 'map' : token.type === 'block-seq' ? 'seq' : token.start.source === '{' ? 'map' : 'seq';\n  // shortcut: check if it's a generic YAMLMap or YAMLSeq\n  // before jumping into the custom tag logic.\n  if (!tagToken || !tagName || tagName === '!' || tagName === YAMLMap.tagName && expType === 'map' || tagName === YAMLSeq.tagName && expType === 'seq') {\n    return resolveCollection(CN, ctx, token, onError, tagName);\n  }\n  let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n  if (!tag) {\n    const kt = ctx.schema.knownTags[tagName];\n    if (kt && kt.collection === expType) {\n      ctx.schema.tags.push(Object.assign({}, kt, {\n        default: false\n      }));\n      tag = kt;\n    } else {\n      if (kt) {\n        onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n      } else {\n        onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n      }\n      return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n  }\n  const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n  const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n  const node = isNode(res) ? res : new Scalar(res);\n  node.range = coll.range;\n  node.tag = tagName;\n  if (tag?.format) node.format = tag.format;\n  return node;\n}\nexport { composeCollection };","map":{"version":3,"names":["isNode","Scalar","YAMLMap","YAMLSeq","resolveBlockMap","resolveBlockSeq","resolveFlowCollection","resolveCollection","CN","ctx","token","onError","tagName","tag","coll","type","Coll","constructor","composeCollection","props","tagToken","directives","source","msg","anchor","newlineAfterProp","nl","lastProp","offset","message","expType","start","schema","tags","find","t","collection","kt","knownTags","push","Object","assign","default","res","resolve","options","node","range","format"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/compose-collection.js"],"sourcesContent":["import { isNode } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveBlockMap } from './resolve-block-map.js';\nimport { resolveBlockSeq } from './resolve-block-seq.js';\nimport { resolveFlowCollection } from './resolve-flow-collection.js';\n\nfunction resolveCollection(CN, ctx, token, onError, tagName, tag) {\n    const coll = token.type === 'block-map'\n        ? resolveBlockMap(CN, ctx, token, onError, tag)\n        : token.type === 'block-seq'\n            ? resolveBlockSeq(CN, ctx, token, onError, tag)\n            : resolveFlowCollection(CN, ctx, token, onError, tag);\n    const Coll = coll.constructor;\n    // If we got a tagName matching the class, or the tag name is '!',\n    // then use the tagName from the node class used to create it.\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    if (tagName)\n        coll.tag = tagName;\n    return coll;\n}\nfunction composeCollection(CN, ctx, token, props, onError) {\n    const tagToken = props.tag;\n    const tagName = !tagToken\n        ? null\n        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (token.type === 'block-seq') {\n        const { anchor, newlineAfterProp: nl } = props;\n        const lastProp = anchor && tagToken\n            ? anchor.offset > tagToken.offset\n                ? anchor\n                : tagToken\n            : (anchor ?? tagToken);\n        if (lastProp && (!nl || nl.offset < lastProp.offset)) {\n            const message = 'Missing newline after block sequence props';\n            onError(lastProp, 'MISSING_CHAR', message);\n        }\n    }\n    const expType = token.type === 'block-map'\n        ? 'map'\n        : token.type === 'block-seq'\n            ? 'seq'\n            : token.start.source === '{'\n                ? 'map'\n                : 'seq';\n    // shortcut: check if it's a generic YAMLMap or YAMLSeq\n    // before jumping into the custom tag logic.\n    if (!tagToken ||\n        !tagName ||\n        tagName === '!' ||\n        (tagName === YAMLMap.tagName && expType === 'map') ||\n        (tagName === YAMLSeq.tagName && expType === 'seq')) {\n        return resolveCollection(CN, ctx, token, onError, tagName);\n    }\n    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            if (kt) {\n                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);\n            }\n            else {\n                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            }\n            return resolveCollection(CN, ctx, token, onError, tagName);\n        }\n    }\n    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);\n    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;\n    const node = isNode(res)\n        ? res\n        : new Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexport { composeCollection };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}