{"ast":null,"code":"import \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\nconst binary = {\n  identify: value => value instanceof Uint8Array,\n  // Buffer inherits from Uint8Array\n  default: false,\n  tag: 'tag:yaml.org,2002:binary',\n  /**\n   * Returns a Buffer in node and an Uint8Array in browsers\n   *\n   * To use the resulting buffer as an image, you'll want to do something like:\n   *\n   *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n   *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n   */\n  resolve(src, onError) {\n    if (typeof atob === 'function') {\n      // On IE 11, atob() can't handle newlines\n      const str = atob(src.replace(/[\\n\\r]/g, ''));\n      const buffer = new Uint8Array(str.length);\n      for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);\n      return buffer;\n    } else {\n      onError('This environment does not support reading binary tags; either Buffer or atob is required');\n      return src;\n    }\n  },\n  stringify({\n    comment,\n    type,\n    value\n  }, ctx, onComment, onChompKeep) {\n    if (!value) return '';\n    const buf = value; // checked earlier by binary.identify()\n    let str;\n    if (typeof btoa === 'function') {\n      let s = '';\n      for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);\n      str = btoa(s);\n    } else {\n      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n    }\n    type ?? (type = Scalar.BLOCK_LITERAL);\n    if (type !== Scalar.QUOTE_DOUBLE) {\n      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n      const n = Math.ceil(str.length / lineWidth);\n      const lines = new Array(n);\n      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n        lines[i] = str.substr(o, lineWidth);\n      }\n      str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n    }\n    return stringifyString({\n      comment,\n      type,\n      value: str\n    }, ctx, onComment, onChompKeep);\n  }\n};\nexport { binary };","map":{"version":3,"names":["Scalar","stringifyString","binary","identify","value","Uint8Array","default","tag","resolve","src","onError","atob","str","replace","buffer","length","i","charCodeAt","stringify","comment","type","ctx","onComment","onChompKeep","buf","btoa","s","String","fromCharCode","Error","BLOCK_LITERAL","QUOTE_DOUBLE","lineWidth","Math","max","options","indent","minContentWidth","n","ceil","lines","Array","o","substr","join"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"],"sourcesContent":["import { Scalar } from '../../nodes/Scalar.js';\nimport { stringifyString } from '../../stringify/stringifyString.js';\n\nconst binary = {\n    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        if (!value)\n            return '';\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        type ?? (type = Scalar.BLOCK_LITERAL);\n        if (type !== Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexport { binary };\n"],"mappings":";;AAAA,SAASA,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,eAAe,QAAQ,oCAAoC;AAEpE,MAAMC,MAAM,GAAG;EACXC,QAAQ,EAAEC,KAAK,IAAIA,KAAK,YAAYC,UAAU;EAAE;EAChDC,OAAO,EAAE,KAAK;EACdC,GAAG,EAAE,0BAA0B;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAOA,CAACC,GAAG,EAAEC,OAAO,EAAE;IAClB,IAAI,OAAOC,IAAI,KAAK,UAAU,EAAE;MAC5B;MACA,MAAMC,GAAG,GAAGD,IAAI,CAACF,GAAG,CAACI,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;MAC5C,MAAMC,MAAM,GAAG,IAAIT,UAAU,CAACO,GAAG,CAACG,MAAM,CAAC;MACzC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,GAAG,CAACG,MAAM,EAAE,EAAEC,CAAC,EAC/BF,MAAM,CAACE,CAAC,CAAC,GAAGJ,GAAG,CAACK,UAAU,CAACD,CAAC,CAAC;MACjC,OAAOF,MAAM;IACjB,CAAC,MACI;MACDJ,OAAO,CAAC,0FAA0F,CAAC;MACnG,OAAOD,GAAG;IACd;EACJ,CAAC;EACDS,SAASA,CAAC;IAAEC,OAAO;IAAEC,IAAI;IAAEhB;EAAM,CAAC,EAAEiB,GAAG,EAAEC,SAAS,EAAEC,WAAW,EAAE;IAC7D,IAAI,CAACnB,KAAK,EACN,OAAO,EAAE;IACb,MAAMoB,GAAG,GAAGpB,KAAK,CAAC,CAAC;IACnB,IAAIQ,GAAG;IACP,IAAI,OAAOa,IAAI,KAAK,UAAU,EAAE;MAC5B,IAAIC,CAAC,GAAG,EAAE;MACV,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGQ,GAAG,CAACT,MAAM,EAAE,EAAEC,CAAC,EAC/BU,CAAC,IAAIC,MAAM,CAACC,YAAY,CAACJ,GAAG,CAACR,CAAC,CAAC,CAAC;MACpCJ,GAAG,GAAGa,IAAI,CAACC,CAAC,CAAC;IACjB,CAAC,MACI;MACD,MAAM,IAAIG,KAAK,CAAC,0FAA0F,CAAC;IAC/G;IACAT,IAAI,KAAKA,IAAI,GAAGpB,MAAM,CAAC8B,aAAa,CAAC;IACrC,IAAIV,IAAI,KAAKpB,MAAM,CAAC+B,YAAY,EAAE;MAC9B,MAAMC,SAAS,GAAGC,IAAI,CAACC,GAAG,CAACb,GAAG,CAACc,OAAO,CAACH,SAAS,GAAGX,GAAG,CAACe,MAAM,CAACrB,MAAM,EAAEM,GAAG,CAACc,OAAO,CAACE,eAAe,CAAC;MAClG,MAAMC,CAAC,GAAGL,IAAI,CAACM,IAAI,CAAC3B,GAAG,CAACG,MAAM,GAAGiB,SAAS,CAAC;MAC3C,MAAMQ,KAAK,GAAG,IAAIC,KAAK,CAACH,CAAC,CAAC;MAC1B,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAE0B,CAAC,GAAG,CAAC,EAAE1B,CAAC,GAAGsB,CAAC,EAAE,EAAEtB,CAAC,EAAE0B,CAAC,IAAIV,SAAS,EAAE;QAC/CQ,KAAK,CAACxB,CAAC,CAAC,GAAGJ,GAAG,CAAC+B,MAAM,CAACD,CAAC,EAAEV,SAAS,CAAC;MACvC;MACApB,GAAG,GAAG4B,KAAK,CAACI,IAAI,CAACxB,IAAI,KAAKpB,MAAM,CAAC8B,aAAa,GAAG,IAAI,GAAG,GAAG,CAAC;IAChE;IACA,OAAO7B,eAAe,CAAC;MAAEkB,OAAO;MAAEC,IAAI;MAAEhB,KAAK,EAAEQ;IAAI,CAAC,EAAES,GAAG,EAAEC,SAAS,EAAEC,WAAW,CAAC;EACtF;AACJ,CAAC;AAED,SAASrB,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}