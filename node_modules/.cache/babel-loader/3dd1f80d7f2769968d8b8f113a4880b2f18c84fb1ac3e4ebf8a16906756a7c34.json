{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\nfunction parseOptions(options) {\n  const prettyErrors = options.prettyErrors !== false;\n  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;\n  return {\n    lineCounter,\n    prettyErrors\n  };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n  const {\n    lineCounter,\n    prettyErrors\n  } = parseOptions(options);\n  const parser = new Parser(lineCounter?.addNewLine);\n  const composer = new Composer(options);\n  const docs = Array.from(composer.compose(parser.parse(source)));\n  if (prettyErrors && lineCounter) for (const doc of docs) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  if (docs.length > 0) return docs;\n  return Object.assign([], {\n    empty: true\n  }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n  const {\n    lineCounter,\n    prettyErrors\n  } = parseOptions(options);\n  const parser = new Parser(lineCounter?.addNewLine);\n  const composer = new Composer(options);\n  // `doc` is always set by compose.end(true) at the very latest\n  let doc = null;\n  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n    if (!doc) doc = _doc;else if (doc.options.logLevel !== 'silent') {\n      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n      break;\n    }\n  }\n  if (prettyErrors && lineCounter) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  return doc;\n}\nfunction parse(src, reviver, options) {\n  let _reviver = undefined;\n  if (typeof reviver === 'function') {\n    _reviver = reviver;\n  } else if (options === undefined && reviver && typeof reviver === 'object') {\n    options = reviver;\n  }\n  const doc = parseDocument(src, options);\n  if (!doc) return null;\n  doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n  if (doc.errors.length > 0) {\n    if (doc.options.logLevel !== 'silent') throw doc.errors[0];else doc.errors = [];\n  }\n  return doc.toJS(Object.assign({\n    reviver: _reviver\n  }, options));\n}\nfunction stringify(value, replacer, options) {\n  let _replacer = null;\n  if (typeof replacer === 'function' || Array.isArray(replacer)) {\n    _replacer = replacer;\n  } else if (options === undefined && replacer) {\n    options = replacer;\n  }\n  if (typeof options === 'string') options = options.length;\n  if (typeof options === 'number') {\n    const indent = Math.round(options);\n    options = indent < 1 ? undefined : indent > 8 ? {\n      indent: 8\n    } : {\n      indent\n    };\n  }\n  if (value === undefined) {\n    const {\n      keepUndefined\n    } = options ?? replacer ?? {};\n    if (!keepUndefined) return undefined;\n  }\n  if (isDocument(value) && !_replacer) return value.toString(options);\n  return new Document(value, _replacer, options).toString(options);\n}\nexport { parse, parseAllDocuments, parseDocument, stringify };","map":{"version":3,"names":["Composer","Document","prettifyError","YAMLParseError","warn","isDocument","LineCounter","Parser","parseOptions","options","prettyErrors","lineCounter","parseAllDocuments","source","parser","addNewLine","composer","docs","Array","from","compose","parse","doc","errors","forEach","warnings","length","Object","assign","empty","streamInfo","parseDocument","_doc","logLevel","push","range","slice","src","reviver","_reviver","undefined","warning","toJS","stringify","value","replacer","_replacer","isArray","indent","Math","round","keepUndefined","toString"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/public-api.js"],"sourcesContent":["import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;\n    return { lineCounter, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    const docs = Array.from(composer.compose(parser.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(prettifyError(source, lineCounter));\n            doc.warnings.forEach(prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser = new Parser(lineCounter?.addNewLine);\n    const composer = new Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(prettifyError(source, lineCounter));\n        doc.warnings.forEach(prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    if (isDocument(value) && !_replacer)\n        return value.toString(options);\n    return new Document(value, _replacer, options).toString(options);\n}\n\nexport { parse, parseAllDocuments, parseDocument, stringify };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}