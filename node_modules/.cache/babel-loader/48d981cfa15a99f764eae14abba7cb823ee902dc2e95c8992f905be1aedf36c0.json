{"ast":null,"code":"function resolveProps(tokens, {\n  flow,\n  indicator,\n  next,\n  offset,\n  onError,\n  parentIndent,\n  startOnNewline\n}) {\n  let spaceBefore = false;\n  let atNewline = startOnNewline;\n  let hasSpace = startOnNewline;\n  let comment = '';\n  let commentSep = '';\n  let hasNewline = false;\n  let reqSpace = false;\n  let tab = null;\n  let anchor = null;\n  let tag = null;\n  let newlineAfterProp = null;\n  let comma = null;\n  let found = null;\n  let start = null;\n  for (const token of tokens) {\n    if (reqSpace) {\n      if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma') onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n      reqSpace = false;\n    }\n    if (tab) {\n      if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n      }\n      tab = null;\n    }\n    switch (token.type) {\n      case 'space':\n        // At the doc level, tabs at line start may be parsed\n        // as leading white space rather than indentation.\n        // In a flow collection, only the parser handles indent.\n        if (!flow && (indicator !== 'doc-start' || next?.type !== 'flow-collection') && token.source.includes('\\t')) {\n          tab = token;\n        }\n        hasSpace = true;\n        break;\n      case 'comment':\n        {\n          if (!hasSpace) onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n          const cb = token.source.substring(1) || ' ';\n          if (!comment) comment = cb;else comment += commentSep + cb;\n          commentSep = '';\n          atNewline = false;\n          break;\n        }\n      case 'newline':\n        if (atNewline) {\n          if (comment) comment += token.source;else if (!found || indicator !== 'seq-item-ind') spaceBefore = true;\n        } else commentSep += token.source;\n        atNewline = true;\n        hasNewline = true;\n        if (anchor || tag) newlineAfterProp = token;\n        hasSpace = true;\n        break;\n      case 'anchor':\n        if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n        if (token.source.endsWith(':')) onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n        anchor = token;\n        start ?? (start = token.offset);\n        atNewline = false;\n        hasSpace = false;\n        reqSpace = true;\n        break;\n      case 'tag':\n        {\n          if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n          tag = token;\n          start ?? (start = token.offset);\n          atNewline = false;\n          hasSpace = false;\n          reqSpace = true;\n          break;\n        }\n      case indicator:\n        // Could here handle preceding comments differently\n        if (anchor || tag) onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n        if (found) onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n        found = token;\n        atNewline = indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n        hasSpace = false;\n        break;\n      case 'comma':\n        if (flow) {\n          if (comma) onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n          comma = token;\n          atNewline = false;\n          hasSpace = false;\n          break;\n        }\n      // else fallthrough\n      default:\n        onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n        atNewline = false;\n        hasSpace = false;\n    }\n  }\n  const last = tokens[tokens.length - 1];\n  const end = last ? last.offset + last.source.length : offset;\n  if (reqSpace && next && next.type !== 'space' && next.type !== 'newline' && next.type !== 'comma' && (next.type !== 'scalar' || next.source !== '')) {\n    onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n  }\n  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === 'block-map' || next?.type === 'block-seq')) onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n  return {\n    comma,\n    found,\n    spaceBefore,\n    comment,\n    hasNewline,\n    anchor,\n    tag,\n    newlineAfterProp,\n    end,\n    start: start ?? end\n  };\n}\nexport { resolveProps };","map":{"version":3,"names":["resolveProps","tokens","flow","indicator","next","offset","onError","parentIndent","startOnNewline","spaceBefore","atNewline","hasSpace","comment","commentSep","hasNewline","reqSpace","tab","anchor","tag","newlineAfterProp","comma","found","start","token","type","source","includes","cb","substring","endsWith","length","last","end","indent"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/resolve-props.js"],"sourcesContent":["function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let reqSpace = false;\n    let tab = null;\n    let anchor = null;\n    let tag = null;\n    let newlineAfterProp = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        if (tab) {\n            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {\n                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n            }\n            tab = null;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&\n                    token.source.includes('\\t')) {\n                    tab = token;\n                }\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else if (!found || indicator !== 'seq-item-ind')\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    newlineAfterProp = token;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                start ?? (start = token.offset);\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline =\n                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== '')) {\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    }\n    if (tab &&\n        ((atNewline && tab.indent <= parentIndent) ||\n            next?.type === 'block-map' ||\n            next?.type === 'block-seq'))\n        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        anchor,\n        tag,\n        newlineAfterProp,\n        end,\n        start: start ?? end\n    };\n}\n\nexport { resolveProps };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}