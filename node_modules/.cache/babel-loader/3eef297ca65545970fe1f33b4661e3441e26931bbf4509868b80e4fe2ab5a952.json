{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', {\n  indentAtStart,\n  lineWidth = 80,\n  minContentWidth = 20,\n  onFold,\n  onOverflow\n} = {}) {\n  if (!lineWidth || lineWidth < 0) return text;\n  if (lineWidth < minContentWidth) minContentWidth = 0;\n  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n  if (text.length <= endStep) return text;\n  const folds = [];\n  const escapedFolds = {};\n  let end = lineWidth - indent.length;\n  if (typeof indentAtStart === 'number') {\n    if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);else end = lineWidth - indentAtStart;\n  }\n  let split = undefined;\n  let prev = undefined;\n  let overflow = false;\n  let i = -1;\n  let escStart = -1;\n  let escEnd = -1;\n  if (mode === FOLD_BLOCK) {\n    i = consumeMoreIndentedLines(text, i, indent.length);\n    if (i !== -1) end = i + endStep;\n  }\n  for (let ch; ch = text[i += 1];) {\n    if (mode === FOLD_QUOTED && ch === '\\\\') {\n      escStart = i;\n      switch (text[i + 1]) {\n        case 'x':\n          i += 3;\n          break;\n        case 'u':\n          i += 5;\n          break;\n        case 'U':\n          i += 9;\n          break;\n        default:\n          i += 1;\n      }\n      escEnd = i;\n    }\n    if (ch === '\\n') {\n      if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i, indent.length);\n      end = i + indent.length + endStep;\n      split = undefined;\n    } else {\n      if (ch === ' ' && prev && prev !== ' ' && prev !== '\\n' && prev !== '\\t') {\n        // space surrounded by non-space can be replaced with newline + indent\n        const next = text[i + 1];\n        if (next && next !== ' ' && next !== '\\n' && next !== '\\t') split = i;\n      }\n      if (i >= end) {\n        if (split) {\n          folds.push(split);\n          end = split + endStep;\n          split = undefined;\n        } else if (mode === FOLD_QUOTED) {\n          // white-space collected at end may stretch past lineWidth\n          while (prev === ' ' || prev === '\\t') {\n            prev = ch;\n            ch = text[i += 1];\n            overflow = true;\n          }\n          // Account for newline escape, but don't break preceding escape\n          const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n          // Bail out if lineWidth & minContentWidth are shorter than an escape string\n          if (escapedFolds[j]) return text;\n          folds.push(j);\n          escapedFolds[j] = true;\n          end = j + endStep;\n          split = undefined;\n        } else {\n          overflow = true;\n        }\n      }\n    }\n    prev = ch;\n  }\n  if (overflow && onOverflow) onOverflow();\n  if (folds.length === 0) return text;\n  if (onFold) onFold();\n  let res = text.slice(0, folds[0]);\n  for (let i = 0; i < folds.length; ++i) {\n    const fold = folds[i];\n    const end = folds[i + 1] || text.length;\n    if (fold === 0) res = `\\n${indent}${text.slice(0, end)}`;else {\n      if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\\\`;\n      res += `\\n${indent}${text.slice(fold + 1, end)}`;\n    }\n  }\n  return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n  let end = i;\n  let start = i + 1;\n  let ch = text[start];\n  while (ch === ' ' || ch === '\\t') {\n    if (i < start + indent) {\n      ch = text[++i];\n    } else {\n      do {\n        ch = text[++i];\n      } while (ch && ch !== '\\n');\n      end = i;\n      start = i + 1;\n      ch = text[start];\n    }\n  }\n  return end;\n}\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };","map":{"version":3,"names":["FOLD_FLOW","FOLD_BLOCK","FOLD_QUOTED","foldFlowLines","text","indent","mode","indentAtStart","lineWidth","minContentWidth","onFold","onOverflow","endStep","Math","max","length","folds","escapedFolds","end","push","split","undefined","prev","overflow","i","escStart","escEnd","consumeMoreIndentedLines","ch","next","j","res","slice","fold","start"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/stringify/foldFlowLines.js"],"sourcesContent":["const FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    if (lineWidth < minContentWidth)\n        minContentWidth = 0;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i, indent.length);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i, indent.length);\n            end = i + indent.length + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i, indent) {\n    let end = i;\n    let start = i + 1;\n    let ch = text[start];\n    while (ch === ' ' || ch === '\\t') {\n        if (i < start + indent) {\n            ch = text[++i];\n        }\n        else {\n            do {\n                ch = text[++i];\n            } while (ch && ch !== '\\n');\n            end = i;\n            start = i + 1;\n            ch = text[start];\n        }\n    }\n    return end;\n}\n\nexport { FOLD_BLOCK, FOLD_FLOW, FOLD_QUOTED, foldFlowLines };\n"],"mappings":";AAAA,MAAMA,SAAS,GAAG,MAAM;AACxB,MAAMC,UAAU,GAAG,OAAO;AAC1B,MAAMC,WAAW,GAAG,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,SAASC,aAAaA,CAACC,IAAI,EAAEC,MAAM,EAAEC,IAAI,GAAG,MAAM,EAAE;EAAEC,aAAa;EAAEC,SAAS,GAAG,EAAE;EAAEC,eAAe,GAAG,EAAE;EAAEC,MAAM;EAAEC;AAAW,CAAC,GAAG,CAAC,CAAC,EAAE;EAClI,IAAI,CAACH,SAAS,IAAIA,SAAS,GAAG,CAAC,EAC3B,OAAOJ,IAAI;EACf,IAAII,SAAS,GAAGC,eAAe,EAC3BA,eAAe,GAAG,CAAC;EACvB,MAAMG,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGL,eAAe,EAAE,CAAC,GAAGD,SAAS,GAAGH,MAAM,CAACU,MAAM,CAAC;EAC5E,IAAIX,IAAI,CAACW,MAAM,IAAIH,OAAO,EACtB,OAAOR,IAAI;EACf,MAAMY,KAAK,GAAG,EAAE;EAChB,MAAMC,YAAY,GAAG,CAAC,CAAC;EACvB,IAAIC,GAAG,GAAGV,SAAS,GAAGH,MAAM,CAACU,MAAM;EACnC,IAAI,OAAOR,aAAa,KAAK,QAAQ,EAAE;IACnC,IAAIA,aAAa,GAAGC,SAAS,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEL,eAAe,CAAC,EACxDO,KAAK,CAACG,IAAI,CAAC,CAAC,CAAC,CAAC,KAEdD,GAAG,GAAGV,SAAS,GAAGD,aAAa;EACvC;EACA,IAAIa,KAAK,GAAGC,SAAS;EACrB,IAAIC,IAAI,GAAGD,SAAS;EACpB,IAAIE,QAAQ,GAAG,KAAK;EACpB,IAAIC,CAAC,GAAG,CAAC,CAAC;EACV,IAAIC,QAAQ,GAAG,CAAC,CAAC;EACjB,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,IAAIpB,IAAI,KAAKL,UAAU,EAAE;IACrBuB,CAAC,GAAGG,wBAAwB,CAACvB,IAAI,EAAEoB,CAAC,EAAEnB,MAAM,CAACU,MAAM,CAAC;IACpD,IAAIS,CAAC,KAAK,CAAC,CAAC,EACRN,GAAG,GAAGM,CAAC,GAAGZ,OAAO;EACzB;EACA,KAAK,IAAIgB,EAAE,EAAGA,EAAE,GAAGxB,IAAI,CAAEoB,CAAC,IAAI,CAAC,CAAE,GAAI;IACjC,IAAIlB,IAAI,KAAKJ,WAAW,IAAI0B,EAAE,KAAK,IAAI,EAAE;MACrCH,QAAQ,GAAGD,CAAC;MACZ,QAAQpB,IAAI,CAACoB,CAAC,GAAG,CAAC,CAAC;QACf,KAAK,GAAG;UACJA,CAAC,IAAI,CAAC;UACN;QACJ,KAAK,GAAG;UACJA,CAAC,IAAI,CAAC;UACN;QACJ,KAAK,GAAG;UACJA,CAAC,IAAI,CAAC;UACN;QACJ;UACIA,CAAC,IAAI,CAAC;MACd;MACAE,MAAM,GAAGF,CAAC;IACd;IACA,IAAII,EAAE,KAAK,IAAI,EAAE;MACb,IAAItB,IAAI,KAAKL,UAAU,EACnBuB,CAAC,GAAGG,wBAAwB,CAACvB,IAAI,EAAEoB,CAAC,EAAEnB,MAAM,CAACU,MAAM,CAAC;MACxDG,GAAG,GAAGM,CAAC,GAAGnB,MAAM,CAACU,MAAM,GAAGH,OAAO;MACjCQ,KAAK,GAAGC,SAAS;IACrB,CAAC,MACI;MACD,IAAIO,EAAE,KAAK,GAAG,IACVN,IAAI,IACJA,IAAI,KAAK,GAAG,IACZA,IAAI,KAAK,IAAI,IACbA,IAAI,KAAK,IAAI,EAAE;QACf;QACA,MAAMO,IAAI,GAAGzB,IAAI,CAACoB,CAAC,GAAG,CAAC,CAAC;QACxB,IAAIK,IAAI,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,IAAI,EACtDT,KAAK,GAAGI,CAAC;MACjB;MACA,IAAIA,CAAC,IAAIN,GAAG,EAAE;QACV,IAAIE,KAAK,EAAE;UACPJ,KAAK,CAACG,IAAI,CAACC,KAAK,CAAC;UACjBF,GAAG,GAAGE,KAAK,GAAGR,OAAO;UACrBQ,KAAK,GAAGC,SAAS;QACrB,CAAC,MACI,IAAIf,IAAI,KAAKJ,WAAW,EAAE;UAC3B;UACA,OAAOoB,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;YAClCA,IAAI,GAAGM,EAAE;YACTA,EAAE,GAAGxB,IAAI,CAAEoB,CAAC,IAAI,CAAC,CAAE;YACnBD,QAAQ,GAAG,IAAI;UACnB;UACA;UACA,MAAMO,CAAC,GAAGN,CAAC,GAAGE,MAAM,GAAG,CAAC,GAAGF,CAAC,GAAG,CAAC,GAAGC,QAAQ,GAAG,CAAC;UAC/C;UACA,IAAIR,YAAY,CAACa,CAAC,CAAC,EACf,OAAO1B,IAAI;UACfY,KAAK,CAACG,IAAI,CAACW,CAAC,CAAC;UACbb,YAAY,CAACa,CAAC,CAAC,GAAG,IAAI;UACtBZ,GAAG,GAAGY,CAAC,GAAGlB,OAAO;UACjBQ,KAAK,GAAGC,SAAS;QACrB,CAAC,MACI;UACDE,QAAQ,GAAG,IAAI;QACnB;MACJ;IACJ;IACAD,IAAI,GAAGM,EAAE;EACb;EACA,IAAIL,QAAQ,IAAIZ,UAAU,EACtBA,UAAU,CAAC,CAAC;EAChB,IAAIK,KAAK,CAACD,MAAM,KAAK,CAAC,EAClB,OAAOX,IAAI;EACf,IAAIM,MAAM,EACNA,MAAM,CAAC,CAAC;EACZ,IAAIqB,GAAG,GAAG3B,IAAI,CAAC4B,KAAK,CAAC,CAAC,EAAEhB,KAAK,CAAC,CAAC,CAAC,CAAC;EACjC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAK,CAACD,MAAM,EAAE,EAAES,CAAC,EAAE;IACnC,MAAMS,IAAI,GAAGjB,KAAK,CAACQ,CAAC,CAAC;IACrB,MAAMN,GAAG,GAAGF,KAAK,CAACQ,CAAC,GAAG,CAAC,CAAC,IAAIpB,IAAI,CAACW,MAAM;IACvC,IAAIkB,IAAI,KAAK,CAAC,EACVF,GAAG,GAAG,KAAK1B,MAAM,GAAGD,IAAI,CAAC4B,KAAK,CAAC,CAAC,EAAEd,GAAG,CAAC,EAAE,CAAC,KACxC;MACD,IAAIZ,IAAI,KAAKJ,WAAW,IAAIe,YAAY,CAACgB,IAAI,CAAC,EAC1CF,GAAG,IAAI,GAAG3B,IAAI,CAAC6B,IAAI,CAAC,IAAI;MAC5BF,GAAG,IAAI,KAAK1B,MAAM,GAAGD,IAAI,CAAC4B,KAAK,CAACC,IAAI,GAAG,CAAC,EAAEf,GAAG,CAAC,EAAE;IACpD;EACJ;EACA,OAAOa,GAAG;AACd;AACA;AACA;AACA;AACA;AACA,SAASJ,wBAAwBA,CAACvB,IAAI,EAAEoB,CAAC,EAAEnB,MAAM,EAAE;EAC/C,IAAIa,GAAG,GAAGM,CAAC;EACX,IAAIU,KAAK,GAAGV,CAAC,GAAG,CAAC;EACjB,IAAII,EAAE,GAAGxB,IAAI,CAAC8B,KAAK,CAAC;EACpB,OAAON,EAAE,KAAK,GAAG,IAAIA,EAAE,KAAK,IAAI,EAAE;IAC9B,IAAIJ,CAAC,GAAGU,KAAK,GAAG7B,MAAM,EAAE;MACpBuB,EAAE,GAAGxB,IAAI,CAAC,EAAEoB,CAAC,CAAC;IAClB,CAAC,MACI;MACD,GAAG;QACCI,EAAE,GAAGxB,IAAI,CAAC,EAAEoB,CAAC,CAAC;MAClB,CAAC,QAAQI,EAAE,IAAIA,EAAE,KAAK,IAAI;MAC1BV,GAAG,GAAGM,CAAC;MACPU,KAAK,GAAGV,CAAC,GAAG,CAAC;MACbI,EAAE,GAAGxB,IAAI,CAAC8B,KAAK,CAAC;IACpB;EACJ;EACA,OAAOhB,GAAG;AACd;AAEA,SAASjB,UAAU,EAAED,SAAS,EAAEE,WAAW,EAAEC,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}