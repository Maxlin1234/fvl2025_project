{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/*\n  @license\n\tRollup.js v4.46.2\n\tTue, 29 Jul 2025 19:44:27 GMT - commit 4e19badeda6f116a13a2f617ae3c6e1e14606023\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { getAugmentedNamespace, fseventsImporter, getDefaultExportFromCjs, createFilter, rollupInternal } from './node-entry.js';\nimport path from 'node:path';\nimport process$1 from 'node:process';\nimport require$$0$1 from 'path';\nimport require$$2 from 'util';\nimport require$$0$2 from 'fs';\nimport require$$1 from 'stream';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport { platform } from 'node:os';\nimport './parseAst.js';\nimport '../../native.js';\nimport 'node:perf_hooks';\nimport 'node:fs/promises';\nvar chokidar$1 = {};\nvar utils$2 = {};\nvar constants$3;\nvar hasRequiredConstants$3;\nfunction requireConstants$3() {\n  if (hasRequiredConstants$3) return constants$3;\n  hasRequiredConstants$3 = 1;\n  const path = require$$0$1;\n  const WIN_SLASH = '\\\\\\\\/';\n  const WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n  /**\n   * Posix glob regex\n   */\n\n  const DOT_LITERAL = '\\\\.';\n  const PLUS_LITERAL = '\\\\+';\n  const QMARK_LITERAL = '\\\\?';\n  const SLASH_LITERAL = '\\\\/';\n  const ONE_CHAR = '(?=.)';\n  const QMARK = '[^/]';\n  const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n  const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n  const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n  const NO_DOT = `(?!${DOT_LITERAL})`;\n  const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n  const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n  const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n  const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n  const STAR = `${QMARK}*?`;\n  const POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  };\n\n  /**\n   * Windows glob regex\n   */\n\n  const WINDOWS_CHARS = {\n    ...POSIX_CHARS,\n    SLASH_LITERAL: `[${WIN_SLASH}]`,\n    QMARK: WIN_NO_SLASH,\n    STAR: `${WIN_NO_SLASH}*?`,\n    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n    NO_DOT: `(?!${DOT_LITERAL})`,\n    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n  };\n\n  /**\n   * POSIX Bracket Regex\n   */\n\n  const POSIX_REGEX_SOURCE = {\n    alnum: 'a-zA-Z0-9',\n    alpha: 'a-zA-Z',\n    ascii: '\\\\x00-\\\\x7F',\n    blank: ' \\\\t',\n    cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n    digit: '0-9',\n    graph: '\\\\x21-\\\\x7E',\n    lower: 'a-z',\n    print: '\\\\x20-\\\\x7E ',\n    punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n    space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n    upper: 'A-Z',\n    word: 'A-Za-z0-9_',\n    xdigit: 'A-Fa-f0-9'\n  };\n  constants$3 = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n      '***': '*',\n      '**/**': '**',\n      '**/**/**': '**'\n    },\n    // Digits\n    CHAR_0: 48,\n    /* 0 */\n    CHAR_9: 57,\n    /* 9 */\n\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    /* A */\n    CHAR_LOWERCASE_A: 97,\n    /* a */\n    CHAR_UPPERCASE_Z: 90,\n    /* Z */\n    CHAR_LOWERCASE_Z: 122,\n    /* z */\n\n    CHAR_LEFT_PARENTHESES: 40,\n    /* ( */\n    CHAR_RIGHT_PARENTHESES: 41,\n    /* ) */\n\n    CHAR_ASTERISK: 42,\n    /* * */\n\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    /* & */\n    CHAR_AT: 64,\n    /* @ */\n    CHAR_BACKWARD_SLASH: 92,\n    /* \\ */\n    CHAR_CARRIAGE_RETURN: 13,\n    /* \\r */\n    CHAR_CIRCUMFLEX_ACCENT: 94,\n    /* ^ */\n    CHAR_COLON: 58,\n    /* : */\n    CHAR_COMMA: 44,\n    /* , */\n    CHAR_DOT: 46,\n    /* . */\n    CHAR_DOUBLE_QUOTE: 34,\n    /* \" */\n    CHAR_EQUAL: 61,\n    /* = */\n    CHAR_EXCLAMATION_MARK: 33,\n    /* ! */\n    CHAR_FORM_FEED: 12,\n    /* \\f */\n    CHAR_FORWARD_SLASH: 47,\n    /* / */\n    CHAR_GRAVE_ACCENT: 96,\n    /* ` */\n    CHAR_HASH: 35,\n    /* # */\n    CHAR_HYPHEN_MINUS: 45,\n    /* - */\n    CHAR_LEFT_ANGLE_BRACKET: 60,\n    /* < */\n    CHAR_LEFT_CURLY_BRACE: 123,\n    /* { */\n    CHAR_LEFT_SQUARE_BRACKET: 91,\n    /* [ */\n    CHAR_LINE_FEED: 10,\n    /* \\n */\n    CHAR_NO_BREAK_SPACE: 160,\n    /* \\u00A0 */\n    CHAR_PERCENT: 37,\n    /* % */\n    CHAR_PLUS: 43,\n    /* + */\n    CHAR_QUESTION_MARK: 63,\n    /* ? */\n    CHAR_RIGHT_ANGLE_BRACKET: 62,\n    /* > */\n    CHAR_RIGHT_CURLY_BRACE: 125,\n    /* } */\n    CHAR_RIGHT_SQUARE_BRACKET: 93,\n    /* ] */\n    CHAR_SEMICOLON: 59,\n    /* ; */\n    CHAR_SINGLE_QUOTE: 39,\n    /* ' */\n    CHAR_SPACE: 32,\n    /*   */\n    CHAR_TAB: 9,\n    /* \\t */\n    CHAR_UNDERSCORE: 95,\n    /* _ */\n    CHAR_VERTICAL_LINE: 124,\n    /* | */\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    /* \\uFEFF */\n\n    SEP: path.sep,\n    /**\n     * Create EXTGLOB_CHARS\n     */\n\n    extglobChars(chars) {\n      return {\n        '!': {\n          type: 'negate',\n          open: '(?:(?!(?:',\n          close: `))${chars.STAR})`\n        },\n        '?': {\n          type: 'qmark',\n          open: '(?:',\n          close: ')?'\n        },\n        '+': {\n          type: 'plus',\n          open: '(?:',\n          close: ')+'\n        },\n        '*': {\n          type: 'star',\n          open: '(?:',\n          close: ')*'\n        },\n        '@': {\n          type: 'at',\n          open: '(?:',\n          close: ')'\n        }\n      };\n    },\n    /**\n     * Create GLOB_CHARS\n     */\n\n    globChars(win32) {\n      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n  };\n  return constants$3;\n}\nvar hasRequiredUtils$2;\nfunction requireUtils$2() {\n  if (hasRequiredUtils$2) return utils$2;\n  hasRequiredUtils$2 = 1;\n  (function (exports) {\n    const path = require$$0$1;\n    const win32 = process.platform === 'win32';\n    const {\n      REGEX_BACKSLASH,\n      REGEX_REMOVE_BACKSLASH,\n      REGEX_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_GLOBAL\n    } = /*@__PURE__*/requireConstants$3();\n    exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n    exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n    exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n    exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n    exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n    exports.removeBackslashes = str => {\n      return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n        return match === '\\\\' ? '' : match;\n      });\n    };\n    exports.supportsLookbehinds = () => {\n      const segs = process.version.slice(1).split('.').map(Number);\n      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n        return true;\n      }\n      return false;\n    };\n    exports.isWindows = options => {\n      if (options && typeof options.windows === 'boolean') {\n        return options.windows;\n      }\n      return win32 === true || path.sep === '\\\\';\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n      const idx = input.lastIndexOf(char, lastIdx);\n      if (idx === -1) return input;\n      if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n      return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n    };\n    exports.removePrefix = (input, state = {}) => {\n      let output = input;\n      if (output.startsWith('./')) {\n        output = output.slice(2);\n        state.prefix = './';\n      }\n      return output;\n    };\n    exports.wrapOutput = (input, state = {}, options = {}) => {\n      const prepend = options.contains ? '' : '^';\n      const append = options.contains ? '' : '$';\n      let output = `${prepend}(?:${input})${append}`;\n      if (state.negated === true) {\n        output = `(?:^(?!${output}).*$)`;\n      }\n      return output;\n    };\n  })(utils$2);\n  return utils$2;\n}\nvar scan_1$1;\nvar hasRequiredScan$1;\nfunction requireScan$1() {\n  if (hasRequiredScan$1) return scan_1$1;\n  hasRequiredScan$1 = 1;\n  const utils = /*@__PURE__*/requireUtils$2();\n  const {\n    CHAR_ASTERISK,\n    /* * */\n    CHAR_AT,\n    /* @ */\n    CHAR_BACKWARD_SLASH,\n    /* \\ */\n    CHAR_COMMA,\n    /* , */\n    CHAR_DOT,\n    /* . */\n    CHAR_EXCLAMATION_MARK,\n    /* ! */\n    CHAR_FORWARD_SLASH,\n    /* / */\n    CHAR_LEFT_CURLY_BRACE,\n    /* { */\n    CHAR_LEFT_PARENTHESES,\n    /* ( */\n    CHAR_LEFT_SQUARE_BRACKET,\n    /* [ */\n    CHAR_PLUS,\n    /* + */\n    CHAR_QUESTION_MARK,\n    /* ? */\n    CHAR_RIGHT_CURLY_BRACE,\n    /* } */\n    CHAR_RIGHT_PARENTHESES,\n    /* ) */\n    CHAR_RIGHT_SQUARE_BRACKET /* ] */\n  } = /*@__PURE__*/requireConstants$3();\n  const isPathSeparator = code => {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n  };\n  const depth = token => {\n    if (token.isPrefix !== true) {\n      token.depth = token.isGlobstar ? Infinity : 1;\n    }\n  };\n\n  /**\n   * Quickly scans a glob pattern and returns an object with a handful of\n   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n   * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n   * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n   *\n   * ```js\n   * const pm = require('picomatch');\n   * console.log(pm.scan('foo/bar/*.js'));\n   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n   * ```\n   * @param {String} `str`\n   * @param {Object} `options`\n   * @return {Object} Returns an object with tokens and regex source string.\n   * @api public\n   */\n\n  const scan = (input, options) => {\n    const opts = options || {};\n    const length = input.length - 1;\n    const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n    const slashes = [];\n    const tokens = [];\n    const parts = [];\n    let str = input;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isBrace = false;\n    let isBracket = false;\n    let isGlob = false;\n    let isExtglob = false;\n    let isGlobstar = false;\n    let braceEscaped = false;\n    let backslashes = false;\n    let negated = false;\n    let negatedExtglob = false;\n    let finished = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let token = {\n      value: '',\n      depth: 0,\n      isGlob: false\n    };\n    const eos = () => index >= length;\n    const peek = () => str.charCodeAt(index + 1);\n    const advance = () => {\n      prev = code;\n      return str.charCodeAt(++index);\n    };\n    while (index < length) {\n      code = advance();\n      let next;\n      if (code === CHAR_BACKWARD_SLASH) {\n        backslashes = token.backslashes = true;\n        code = advance();\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braceEscaped = true;\n        }\n        continue;\n      }\n      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n        braces++;\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = token.backslashes = true;\n            advance();\n            continue;\n          }\n          if (code === CHAR_LEFT_CURLY_BRACE) {\n            braces++;\n            continue;\n          }\n          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n            isBrace = token.isBrace = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n              continue;\n            }\n            break;\n          }\n          if (braceEscaped !== true && code === CHAR_COMMA) {\n            isBrace = token.isBrace = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n              continue;\n            }\n            break;\n          }\n          if (code === CHAR_RIGHT_CURLY_BRACE) {\n            braces--;\n            if (braces === 0) {\n              braceEscaped = false;\n              isBrace = token.isBrace = true;\n              finished = true;\n              break;\n            }\n          }\n        }\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_FORWARD_SLASH) {\n        slashes.push(index);\n        tokens.push(token);\n        token = {\n          value: '',\n          depth: 0,\n          isGlob: false\n        };\n        if (finished === true) continue;\n        if (prev === CHAR_DOT && index === start + 1) {\n          start += 2;\n          continue;\n        }\n        lastIndex = index + 1;\n        continue;\n      }\n      if (opts.noext !== true) {\n        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n          isGlob = token.isGlob = true;\n          isExtglob = token.isExtglob = true;\n          finished = true;\n          if (code === CHAR_EXCLAMATION_MARK && index === start) {\n            negatedExtglob = true;\n          }\n          if (scanToEnd === true) {\n            while (eos() !== true && (code = advance())) {\n              if (code === CHAR_BACKWARD_SLASH) {\n                backslashes = token.backslashes = true;\n                code = advance();\n                continue;\n              }\n              if (code === CHAR_RIGHT_PARENTHESES) {\n                isGlob = token.isGlob = true;\n                finished = true;\n                break;\n              }\n            }\n            continue;\n          }\n          break;\n        }\n      }\n      if (code === CHAR_ASTERISK) {\n        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n        isGlob = token.isGlob = true;\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_QUESTION_MARK) {\n        isGlob = token.isGlob = true;\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_LEFT_SQUARE_BRACKET) {\n        while (eos() !== true && (next = advance())) {\n          if (next === CHAR_BACKWARD_SLASH) {\n            backslashes = token.backslashes = true;\n            advance();\n            continue;\n          }\n          if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n            isBracket = token.isBracket = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            break;\n          }\n        }\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n        negated = token.negated = true;\n        start++;\n        continue;\n      }\n      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_LEFT_PARENTHESES) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n      if (isGlob === true) {\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n    }\n    if (opts.noext === true) {\n      isExtglob = false;\n      isGlob = false;\n    }\n    let base = str;\n    let prefix = '';\n    let glob = '';\n    if (start > 0) {\n      prefix = str.slice(0, start);\n      str = str.slice(start);\n      lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n      base = str.slice(0, lastIndex);\n      glob = str.slice(lastIndex);\n    } else if (isGlob === true) {\n      base = '';\n      glob = str;\n    } else {\n      base = str;\n    }\n    if (base && base !== '' && base !== '/' && base !== str) {\n      if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n        base = base.slice(0, -1);\n      }\n    }\n    if (opts.unescape === true) {\n      if (glob) glob = utils.removeBackslashes(glob);\n      if (base && backslashes === true) {\n        base = utils.removeBackslashes(base);\n      }\n    }\n    const state = {\n      prefix,\n      input,\n      start,\n      base,\n      glob,\n      isBrace,\n      isBracket,\n      isGlob,\n      isExtglob,\n      isGlobstar,\n      negated,\n      negatedExtglob\n    };\n    if (opts.tokens === true) {\n      state.maxDepth = 0;\n      if (!isPathSeparator(code)) {\n        tokens.push(token);\n      }\n      state.tokens = tokens;\n    }\n    if (opts.parts === true || opts.tokens === true) {\n      let prevIndex;\n      for (let idx = 0; idx < slashes.length; idx++) {\n        const n = prevIndex ? prevIndex + 1 : start;\n        const i = slashes[idx];\n        const value = input.slice(n, i);\n        if (opts.tokens) {\n          if (idx === 0 && start !== 0) {\n            tokens[idx].isPrefix = true;\n            tokens[idx].value = prefix;\n          } else {\n            tokens[idx].value = value;\n          }\n          depth(tokens[idx]);\n          state.maxDepth += tokens[idx].depth;\n        }\n        if (idx !== 0 || value !== '') {\n          parts.push(value);\n        }\n        prevIndex = i;\n      }\n      if (prevIndex && prevIndex + 1 < input.length) {\n        const value = input.slice(prevIndex + 1);\n        parts.push(value);\n        if (opts.tokens) {\n          tokens[tokens.length - 1].value = value;\n          depth(tokens[tokens.length - 1]);\n          state.maxDepth += tokens[tokens.length - 1].depth;\n        }\n      }\n      state.slashes = slashes;\n      state.parts = parts;\n    }\n    return state;\n  };\n  scan_1$1 = scan;\n  return scan_1$1;\n}\nvar parse_1$2;\nvar hasRequiredParse$2;\nfunction requireParse$2() {\n  if (hasRequiredParse$2) return parse_1$2;\n  hasRequiredParse$2 = 1;\n  const constants = /*@__PURE__*/requireConstants$3();\n  const utils = /*@__PURE__*/requireUtils$2();\n\n  /**\n   * Constants\n   */\n\n  const {\n    MAX_LENGTH,\n    POSIX_REGEX_SOURCE,\n    REGEX_NON_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_BACKREF,\n    REPLACEMENTS\n  } = constants;\n\n  /**\n   * Helpers\n   */\n\n  const expandRange = (args, options) => {\n    if (typeof options.expandRange === 'function') {\n      return options.expandRange(...args, options);\n    }\n    args.sort();\n    const value = `[${args.join('-')}]`;\n    return value;\n  };\n\n  /**\n   * Create the message for a syntax error\n   */\n\n  const syntaxError = (type, char) => {\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n  };\n\n  /**\n   * Parse the given input string.\n   * @param {String} input\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  const parse = (input, options) => {\n    if (typeof input !== 'string') {\n      throw new TypeError('Expected a string');\n    }\n    input = REPLACEMENTS[input] || input;\n    const opts = {\n      ...options\n    };\n    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    let len = input.length;\n    if (len > max) {\n      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    const bos = {\n      type: 'bos',\n      value: '',\n      output: opts.prepend || ''\n    };\n    const tokens = [bos];\n    const capture = opts.capture ? '' : '?:';\n    const win32 = utils.isWindows(options);\n\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants.globChars(win32);\n    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n    const {\n      DOT_LITERAL,\n      PLUS_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOT_SLASH,\n      NO_DOTS_SLASH,\n      QMARK,\n      QMARK_NO_DOT,\n      STAR,\n      START_ANCHOR\n    } = PLATFORM_CHARS;\n    const globstar = opts => {\n      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const nodot = opts.dot ? '' : NO_DOT;\n    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    if (opts.capture) {\n      star = `(${star})`;\n    }\n\n    // minimatch options support\n    if (typeof opts.noext === 'boolean') {\n      opts.noextglob = opts.noext;\n    }\n    const state = {\n      input,\n      index: -1,\n      start: 0,\n      dot: opts.dot === true,\n      consumed: '',\n      output: '',\n      prefix: '',\n      backtrack: false,\n      negated: false,\n      brackets: 0,\n      braces: 0,\n      parens: 0,\n      quotes: 0,\n      globstar: false,\n      tokens\n    };\n    input = utils.removePrefix(input, state);\n    len = input.length;\n    const extglobs = [];\n    const braces = [];\n    const stack = [];\n    let prev = bos;\n    let value;\n\n    /**\n     * Tokenizing helpers\n     */\n\n    const eos = () => state.index === len - 1;\n    const peek = state.peek = (n = 1) => input[state.index + n];\n    const advance = state.advance = () => input[++state.index] || '';\n    const remaining = () => input.slice(state.index + 1);\n    const consume = (value = '', num = 0) => {\n      state.consumed += value;\n      state.index += num;\n    };\n    const append = token => {\n      state.output += token.output != null ? token.output : token.value;\n      consume(token.value);\n    };\n    const negate = () => {\n      let count = 1;\n      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n        advance();\n        state.start++;\n        count++;\n      }\n      if (count % 2 === 0) {\n        return false;\n      }\n      state.negated = true;\n      state.start++;\n      return true;\n    };\n    const increment = type => {\n      state[type]++;\n      stack.push(type);\n    };\n    const decrement = type => {\n      state[type]--;\n      stack.pop();\n    };\n\n    /**\n     * Push tokens onto the tokens array. This helper speeds up\n     * tokenizing by 1) helping us avoid backtracking as much as possible,\n     * and 2) helping us avoid creating extra tokens when consecutive\n     * characters are plain text. This improves performance and simplifies\n     * lookbehinds.\n     */\n\n    const push = tok => {\n      if (prev.type === 'globstar') {\n        const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n          state.output = state.output.slice(0, -prev.output.length);\n          prev.type = 'star';\n          prev.value = '*';\n          prev.output = star;\n          state.output += prev.output;\n        }\n      }\n      if (extglobs.length && tok.type !== 'paren') {\n        extglobs[extglobs.length - 1].inner += tok.value;\n      }\n      if (tok.value || tok.output) append(tok);\n      if (prev && prev.type === 'text' && tok.type === 'text') {\n        prev.value += tok.value;\n        prev.output = (prev.output || '') + tok.value;\n        return;\n      }\n      tok.prev = prev;\n      tokens.push(tok);\n      prev = tok;\n    };\n    const extglobOpen = (type, value) => {\n      const token = {\n        ...EXTGLOB_CHARS[value],\n        conditions: 1,\n        inner: ''\n      };\n      token.prev = prev;\n      token.parens = state.parens;\n      token.output = state.output;\n      const output = (opts.capture ? '(' : '') + token.open;\n      increment('parens');\n      push({\n        type,\n        value,\n        output: state.output ? '' : ONE_CHAR\n      });\n      push({\n        type: 'paren',\n        extglob: true,\n        value: advance(),\n        output\n      });\n      extglobs.push(token);\n    };\n    const extglobClose = token => {\n      let output = token.close + (opts.capture ? ')' : '');\n      let rest;\n      if (token.type === 'negate') {\n        let extglobStar = star;\n        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n          extglobStar = globstar(opts);\n        }\n        if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n          output = token.close = `)$))${extglobStar}`;\n        }\n        if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n          // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n          // In this case, we need to parse the string and use it in the output of the original pattern.\n          // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n          //\n          // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n          const expression = parse(rest, {\n            ...options,\n            fastpaths: false\n          }).output;\n          output = token.close = `)${expression})${extglobStar})`;\n        }\n        if (token.prev.type === 'bos') {\n          state.negatedExtglob = true;\n        }\n      }\n      push({\n        type: 'paren',\n        extglob: true,\n        value,\n        output\n      });\n      decrement('parens');\n    };\n\n    /**\n     * Fast paths\n     */\n\n    if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n      let backslashes = false;\n      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n        if (first === '\\\\') {\n          backslashes = true;\n          return m;\n        }\n        if (first === '?') {\n          if (esc) {\n            return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n          }\n          if (index === 0) {\n            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n          }\n          return QMARK.repeat(chars.length);\n        }\n        if (first === '.') {\n          return DOT_LITERAL.repeat(chars.length);\n        }\n        if (first === '*') {\n          if (esc) {\n            return esc + first + (rest ? star : '');\n          }\n          return star;\n        }\n        return esc ? m : `\\\\${m}`;\n      });\n      if (backslashes === true) {\n        if (opts.unescape === true) {\n          output = output.replace(/\\\\/g, '');\n        } else {\n          output = output.replace(/\\\\+/g, m => {\n            return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n          });\n        }\n      }\n      if (output === input && opts.contains === true) {\n        state.output = input;\n        return state;\n      }\n      state.output = utils.wrapOutput(output, state, options);\n      return state;\n    }\n\n    /**\n     * Tokenize input until we reach end-of-string\n     */\n\n    while (!eos()) {\n      value = advance();\n      if (value === '\\u0000') {\n        continue;\n      }\n\n      /**\n       * Escaped characters\n       */\n\n      if (value === '\\\\') {\n        const next = peek();\n        if (next === '/' && opts.bash !== true) {\n          continue;\n        }\n        if (next === '.' || next === ';') {\n          continue;\n        }\n        if (!next) {\n          value += '\\\\';\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n\n        // collapse slashes to reduce potential for exploits\n        const match = /^\\\\+/.exec(remaining());\n        let slashes = 0;\n        if (match && match[0].length > 2) {\n          slashes = match[0].length;\n          state.index += slashes;\n          if (slashes % 2 !== 0) {\n            value += '\\\\';\n          }\n        }\n        if (opts.unescape === true) {\n          value = advance();\n        } else {\n          value += advance();\n        }\n        if (state.brackets === 0) {\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n      }\n\n      /**\n       * If we're inside a regex character class, continue\n       * until we reach the closing bracket.\n       */\n\n      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n        if (opts.posix !== false && value === ':') {\n          const inner = prev.value.slice(1);\n          if (inner.includes('[')) {\n            prev.posix = true;\n            if (inner.includes(':')) {\n              const idx = prev.value.lastIndexOf('[');\n              const pre = prev.value.slice(0, idx);\n              const rest = prev.value.slice(idx + 2);\n              const posix = POSIX_REGEX_SOURCE[rest];\n              if (posix) {\n                prev.value = pre + posix;\n                state.backtrack = true;\n                advance();\n                if (!bos.output && tokens.indexOf(prev) === 1) {\n                  bos.output = ONE_CHAR;\n                }\n                continue;\n              }\n            }\n          }\n        }\n        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n          value = `\\\\${value}`;\n        }\n        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n          value = `\\\\${value}`;\n        }\n        if (opts.posix === true && value === '!' && prev.value === '[') {\n          value = '^';\n        }\n        prev.value += value;\n        append({\n          value\n        });\n        continue;\n      }\n\n      /**\n       * If we're inside a quoted string, continue\n       * until we reach the closing double quote.\n       */\n\n      if (state.quotes === 1 && value !== '\"') {\n        value = utils.escapeRegex(value);\n        prev.value += value;\n        append({\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Double quotes\n       */\n\n      if (value === '\"') {\n        state.quotes = state.quotes === 1 ? 0 : 1;\n        if (opts.keepQuotes === true) {\n          push({\n            type: 'text',\n            value\n          });\n        }\n        continue;\n      }\n\n      /**\n       * Parentheses\n       */\n\n      if (value === '(') {\n        increment('parens');\n        push({\n          type: 'paren',\n          value\n        });\n        continue;\n      }\n      if (value === ')') {\n        if (state.parens === 0 && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '('));\n        }\n        const extglob = extglobs[extglobs.length - 1];\n        if (extglob && state.parens === extglob.parens + 1) {\n          extglobClose(extglobs.pop());\n          continue;\n        }\n        push({\n          type: 'paren',\n          value,\n          output: state.parens ? ')' : '\\\\)'\n        });\n        decrement('parens');\n        continue;\n      }\n\n      /**\n       * Square brackets\n       */\n\n      if (value === '[') {\n        if (opts.nobracket === true || !remaining().includes(']')) {\n          if (opts.nobracket !== true && opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError('closing', ']'));\n          }\n          value = `\\\\${value}`;\n        } else {\n          increment('brackets');\n        }\n        push({\n          type: 'bracket',\n          value\n        });\n        continue;\n      }\n      if (value === ']') {\n        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n          push({\n            type: 'text',\n            value,\n            output: `\\\\${value}`\n          });\n          continue;\n        }\n        if (state.brackets === 0) {\n          if (opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError('opening', '['));\n          }\n          push({\n            type: 'text',\n            value,\n            output: `\\\\${value}`\n          });\n          continue;\n        }\n        decrement('brackets');\n        const prevValue = prev.value.slice(1);\n        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n          value = `/${value}`;\n        }\n        prev.value += value;\n        append({\n          value\n        });\n\n        // when literal brackets are explicitly disabled\n        // assume we should match with a regex character class\n        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n          continue;\n        }\n        const escaped = utils.escapeRegex(prev.value);\n        state.output = state.output.slice(0, -prev.value.length);\n\n        // when literal brackets are explicitly enabled\n        // assume we should escape the brackets to match literal characters\n        if (opts.literalBrackets === true) {\n          state.output += escaped;\n          prev.value = escaped;\n          continue;\n        }\n\n        // when the user specifies nothing, try to match both\n        prev.value = `(${capture}${escaped}|${prev.value})`;\n        state.output += prev.value;\n        continue;\n      }\n\n      /**\n       * Braces\n       */\n\n      if (value === '{' && opts.nobrace !== true) {\n        increment('braces');\n        const open = {\n          type: 'brace',\n          value,\n          output: '(',\n          outputIndex: state.output.length,\n          tokensIndex: state.tokens.length\n        };\n        braces.push(open);\n        push(open);\n        continue;\n      }\n      if (value === '}') {\n        const brace = braces[braces.length - 1];\n        if (opts.nobrace === true || !brace) {\n          push({\n            type: 'text',\n            value,\n            output: value\n          });\n          continue;\n        }\n        let output = ')';\n        if (brace.dots === true) {\n          const arr = tokens.slice();\n          const range = [];\n          for (let i = arr.length - 1; i >= 0; i--) {\n            tokens.pop();\n            if (arr[i].type === 'brace') {\n              break;\n            }\n            if (arr[i].type !== 'dots') {\n              range.unshift(arr[i].value);\n            }\n          }\n          output = expandRange(range, opts);\n          state.backtrack = true;\n        }\n        if (brace.comma !== true && brace.dots !== true) {\n          const out = state.output.slice(0, brace.outputIndex);\n          const toks = state.tokens.slice(brace.tokensIndex);\n          brace.value = brace.output = '\\\\{';\n          value = output = '\\\\}';\n          state.output = out;\n          for (const t of toks) {\n            state.output += t.output || t.value;\n          }\n        }\n        push({\n          type: 'brace',\n          value,\n          output\n        });\n        decrement('braces');\n        braces.pop();\n        continue;\n      }\n\n      /**\n       * Pipes\n       */\n\n      if (value === '|') {\n        if (extglobs.length > 0) {\n          extglobs[extglobs.length - 1].conditions++;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Commas\n       */\n\n      if (value === ',') {\n        let output = value;\n        const brace = braces[braces.length - 1];\n        if (brace && stack[stack.length - 1] === 'braces') {\n          brace.comma = true;\n          output = '|';\n        }\n        push({\n          type: 'comma',\n          value,\n          output\n        });\n        continue;\n      }\n\n      /**\n       * Slashes\n       */\n\n      if (value === '/') {\n        // if the beginning of the glob is \"./\", advance the start\n        // to the current index, and don't add the \"./\" characters\n        // to the state. This greatly simplifies lookbehinds when\n        // checking for BOS characters like \"!\" and \".\" (not \"./\")\n        if (prev.type === 'dot' && state.index === state.start + 1) {\n          state.start = state.index + 1;\n          state.consumed = '';\n          state.output = '';\n          tokens.pop();\n          prev = bos; // reset \"prev\" to the first token\n          continue;\n        }\n        push({\n          type: 'slash',\n          value,\n          output: SLASH_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Dots\n       */\n\n      if (value === '.') {\n        if (state.braces > 0 && prev.type === 'dot') {\n          if (prev.value === '.') prev.output = DOT_LITERAL;\n          const brace = braces[braces.length - 1];\n          prev.type = 'dots';\n          prev.output += value;\n          prev.value += value;\n          brace.dots = true;\n          continue;\n        }\n        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n          push({\n            type: 'text',\n            value,\n            output: DOT_LITERAL\n          });\n          continue;\n        }\n        push({\n          type: 'dot',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Question marks\n       */\n\n      if (value === '?') {\n        const isGroup = prev && prev.value === '(';\n        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          extglobOpen('qmark', value);\n          continue;\n        }\n        if (prev && prev.type === 'paren') {\n          const next = peek();\n          let output = value;\n          if (next === '<' && !utils.supportsLookbehinds()) {\n            throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n          }\n          if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n            output = `\\\\${value}`;\n          }\n          push({\n            type: 'text',\n            value,\n            output\n          });\n          continue;\n        }\n        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n          push({\n            type: 'qmark',\n            value,\n            output: QMARK_NO_DOT\n          });\n          continue;\n        }\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK\n        });\n        continue;\n      }\n\n      /**\n       * Exclamation\n       */\n\n      if (value === '!') {\n        if (opts.noextglob !== true && peek() === '(') {\n          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n            extglobOpen('negate', value);\n            continue;\n          }\n        }\n        if (opts.nonegate !== true && state.index === 0) {\n          negate();\n          continue;\n        }\n      }\n\n      /**\n       * Plus\n       */\n\n      if (value === '+') {\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          extglobOpen('plus', value);\n          continue;\n        }\n        if (prev && prev.value === '(' || opts.regex === false) {\n          push({\n            type: 'plus',\n            value,\n            output: PLUS_LITERAL\n          });\n          continue;\n        }\n        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n          push({\n            type: 'plus',\n            value\n          });\n          continue;\n        }\n        push({\n          type: 'plus',\n          value: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Plain text\n       */\n\n      if (value === '@') {\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          push({\n            type: 'at',\n            extglob: true,\n            value,\n            output: ''\n          });\n          continue;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Plain text\n       */\n\n      if (value !== '*') {\n        if (value === '$' || value === '^') {\n          value = `\\\\${value}`;\n        }\n        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n        if (match) {\n          value += match[0];\n          state.index += match[0].length;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Stars\n       */\n\n      if (prev && (prev.type === 'globstar' || prev.star === true)) {\n        prev.type = 'star';\n        prev.star = true;\n        prev.value += value;\n        prev.output = star;\n        state.backtrack = true;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      let rest = remaining();\n      if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n        extglobOpen('star', value);\n        continue;\n      }\n      if (prev.type === 'star') {\n        if (opts.noglobstar === true) {\n          consume(value);\n          continue;\n        }\n        const prior = prev.prev;\n        const before = prior.prev;\n        const isStart = prior.type === 'slash' || prior.type === 'bos';\n        const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n          push({\n            type: 'star',\n            value,\n            output: ''\n          });\n          continue;\n        }\n        const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n        const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n          push({\n            type: 'star',\n            value,\n            output: ''\n          });\n          continue;\n        }\n\n        // strip consecutive `/**/`\n        while (rest.slice(0, 3) === '/**') {\n          const after = input[state.index + 4];\n          if (after && after !== '/') {\n            break;\n          }\n          rest = rest.slice(3);\n          consume('/**', 3);\n        }\n        if (prior.type === 'bos' && eos()) {\n          prev.type = 'globstar';\n          prev.value += value;\n          prev.output = globstar(opts);\n          state.output = prev.output;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n          state.output = state.output.slice(0, -(prior.output + prev.output).length);\n          prior.output = `(?:${prior.output}`;\n          prev.type = 'globstar';\n          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n          prev.value += value;\n          state.globstar = true;\n          state.output += prior.output + prev.output;\n          consume(value);\n          continue;\n        }\n        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n          const end = rest[1] !== void 0 ? '|$' : '';\n          state.output = state.output.slice(0, -(prior.output + prev.output).length);\n          prior.output = `(?:${prior.output}`;\n          prev.type = 'globstar';\n          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n          prev.value += value;\n          state.output += prior.output + prev.output;\n          state.globstar = true;\n          consume(value + advance());\n          push({\n            type: 'slash',\n            value: '/',\n            output: ''\n          });\n          continue;\n        }\n        if (prior.type === 'bos' && rest[0] === '/') {\n          prev.type = 'globstar';\n          prev.value += value;\n          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n          state.output = prev.output;\n          state.globstar = true;\n          consume(value + advance());\n          push({\n            type: 'slash',\n            value: '/',\n            output: ''\n          });\n          continue;\n        }\n\n        // remove single star from output\n        state.output = state.output.slice(0, -prev.output.length);\n\n        // reset previous token to globstar\n        prev.type = 'globstar';\n        prev.output = globstar(opts);\n        prev.value += value;\n\n        // reset output with globstar\n        state.output += prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      const token = {\n        type: 'star',\n        value,\n        output: star\n      };\n      if (opts.bash === true) {\n        token.output = '.*?';\n        if (prev.type === 'bos' || prev.type === 'slash') {\n          token.output = nodot + token.output;\n        }\n        push(token);\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n        token.output = value;\n        push(token);\n        continue;\n      }\n      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n        if (prev.type === 'dot') {\n          state.output += NO_DOT_SLASH;\n          prev.output += NO_DOT_SLASH;\n        } else if (opts.dot === true) {\n          state.output += NO_DOTS_SLASH;\n          prev.output += NO_DOTS_SLASH;\n        } else {\n          state.output += nodot;\n          prev.output += nodot;\n        }\n        if (peek() !== '*') {\n          state.output += ONE_CHAR;\n          prev.output += ONE_CHAR;\n        }\n      }\n      push(token);\n    }\n    while (state.brackets > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n      state.output = utils.escapeLast(state.output, '[');\n      decrement('brackets');\n    }\n    while (state.parens > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n      state.output = utils.escapeLast(state.output, '(');\n      decrement('parens');\n    }\n    while (state.braces > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n      state.output = utils.escapeLast(state.output, '{');\n      decrement('braces');\n    }\n    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n      push({\n        type: 'maybe_slash',\n        value: '',\n        output: `${SLASH_LITERAL}?`\n      });\n    }\n\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n      state.output = '';\n      for (const token of state.tokens) {\n        state.output += token.output != null ? token.output : token.value;\n        if (token.suffix) {\n          state.output += token.suffix;\n        }\n      }\n    }\n    return state;\n  };\n\n  /**\n   * Fast paths for creating regular expressions for common glob patterns.\n   * This can significantly speed up processing and has very little downside\n   * impact when none of the fast paths match.\n   */\n\n  parse.fastpaths = (input, options) => {\n    const opts = {\n      ...options\n    };\n    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    const len = input.length;\n    if (len > max) {\n      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    const win32 = utils.isWindows(options);\n\n    // create constants based on platform, for windows or posix\n    const {\n      DOT_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOTS,\n      NO_DOTS_SLASH,\n      STAR,\n      START_ANCHOR\n    } = constants.globChars(win32);\n    const nodot = opts.dot ? NO_DOTS : NO_DOT;\n    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    const capture = opts.capture ? '' : '?:';\n    const state = {\n      negated: false,\n      prefix: ''\n    };\n    let star = opts.bash === true ? '.*?' : STAR;\n    if (opts.capture) {\n      star = `(${star})`;\n    }\n    const globstar = opts => {\n      if (opts.noglobstar === true) return star;\n      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = str => {\n      switch (str) {\n        case '*':\n          return `${nodot}${ONE_CHAR}${star}`;\n        case '.*':\n          return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '*.*':\n          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '*/*':\n          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n        case '**':\n          return nodot + globstar(opts);\n        case '**/*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n        case '**/*.*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '**/.*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n        default:\n          {\n            const match = /^(.*?)\\.(\\w+)$/.exec(str);\n            if (!match) return;\n            const source = create(match[1]);\n            if (!source) return;\n            return source + DOT_LITERAL + match[2];\n          }\n      }\n    };\n    const output = utils.removePrefix(input, state);\n    let source = create(output);\n    if (source && opts.strictSlashes !== true) {\n      source += `${SLASH_LITERAL}?`;\n    }\n    return source;\n  };\n  parse_1$2 = parse;\n  return parse_1$2;\n}\nvar picomatch_1$1;\nvar hasRequiredPicomatch$3;\nfunction requirePicomatch$3() {\n  if (hasRequiredPicomatch$3) return picomatch_1$1;\n  hasRequiredPicomatch$3 = 1;\n  const path = require$$0$1;\n  const scan = /*@__PURE__*/requireScan$1();\n  const parse = /*@__PURE__*/requireParse$2();\n  const utils = /*@__PURE__*/requireUtils$2();\n  const constants = /*@__PURE__*/requireConstants$3();\n  const isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n  /**\n   * Creates a matcher function from one or more glob patterns. The\n   * returned function takes a string to match as its first argument,\n   * and returns true if the string is a match. The returned matcher\n   * function also takes a boolean as the second argument that, when true,\n   * returns an object with additional information.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch(glob[, options]);\n   *\n   * const isMatch = picomatch('*.!(*a)');\n   * console.log(isMatch('a.a')); //=> false\n   * console.log(isMatch('a.b')); //=> true\n   * ```\n   * @name picomatch\n   * @param {String|Array} `globs` One or more glob patterns.\n   * @param {Object=} `options`\n   * @return {Function=} Returns a matcher function.\n   * @api public\n   */\n\n  const picomatch = (glob, options, returnState = false) => {\n    if (Array.isArray(glob)) {\n      const fns = glob.map(input => picomatch(input, options, returnState));\n      const arrayMatcher = str => {\n        for (const isMatch of fns) {\n          const state = isMatch(str);\n          if (state) return state;\n        }\n        return false;\n      };\n      return arrayMatcher;\n    }\n    const isState = isObject(glob) && glob.tokens && glob.input;\n    if (glob === '' || typeof glob !== 'string' && !isState) {\n      throw new TypeError('Expected pattern to be a non-empty string');\n    }\n    const opts = options || {};\n    const posix = utils.isWindows(options);\n    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n    const state = regex.state;\n    delete regex.state;\n    let isIgnored = () => false;\n    if (opts.ignore) {\n      const ignoreOpts = {\n        ...options,\n        ignore: null,\n        onMatch: null,\n        onResult: null\n      };\n      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false) => {\n      const {\n        isMatch,\n        match,\n        output\n      } = picomatch.test(input, regex, options, {\n        glob,\n        posix\n      });\n      const result = {\n        glob,\n        state,\n        regex,\n        posix,\n        input,\n        output,\n        match,\n        isMatch\n      };\n      if (typeof opts.onResult === 'function') {\n        opts.onResult(result);\n      }\n      if (isMatch === false) {\n        result.isMatch = false;\n        return returnObject ? result : false;\n      }\n      if (isIgnored(input)) {\n        if (typeof opts.onIgnore === 'function') {\n          opts.onIgnore(result);\n        }\n        result.isMatch = false;\n        return returnObject ? result : false;\n      }\n      if (typeof opts.onMatch === 'function') {\n        opts.onMatch(result);\n      }\n      return returnObject ? result : true;\n    };\n    if (returnState) {\n      matcher.state = state;\n    }\n    return matcher;\n  };\n\n  /**\n   * Test `input` with the given `regex`. This is used by the main\n   * `picomatch()` function to test the input string.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.test(input, regex[, options]);\n   *\n   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n   * ```\n   * @param {String} `input` String to test.\n   * @param {RegExp} `regex`\n   * @return {Object} Returns an object with matching info.\n   * @api public\n   */\n\n  picomatch.test = (input, regex, options, {\n    glob,\n    posix\n  } = {}) => {\n    if (typeof input !== 'string') {\n      throw new TypeError('Expected input to be a string');\n    }\n    if (input === '') {\n      return {\n        isMatch: false,\n        output: ''\n      };\n    }\n    const opts = options || {};\n    const format = opts.format || (posix ? utils.toPosixSlashes : null);\n    let match = input === glob;\n    let output = match && format ? format(input) : input;\n    if (match === false) {\n      output = format ? format(input) : input;\n      match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n      if (opts.matchBase === true || opts.basename === true) {\n        match = picomatch.matchBase(input, regex, options, posix);\n      } else {\n        match = regex.exec(output);\n      }\n    }\n    return {\n      isMatch: Boolean(match),\n      match,\n      output\n    };\n  };\n\n  /**\n   * Match the basename of a filepath.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.matchBase(input, glob[, options]);\n   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n   * ```\n   * @param {String} `input` String to test.\n   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n   * @return {Boolean}\n   * @api public\n   */\n\n  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n  };\n\n  /**\n   * Returns true if **any** of the given glob `patterns` match the specified `string`.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.isMatch(string, patterns[, options]);\n   *\n   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n   * ```\n   * @param {String|Array} str The string to test.\n   * @param {String|Array} patterns One or more glob patterns to use for matching.\n   * @param {Object} [options] See available [options](#options).\n   * @return {Boolean} Returns true if any patterns match `str`\n   * @api public\n   */\n\n  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n  /**\n   * Parse a glob pattern to create the source string for a regular\n   * expression.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * const result = picomatch.parse(pattern[, options]);\n   * ```\n   * @param {String} `pattern`\n   * @param {Object} `options`\n   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n   * @api public\n   */\n\n  picomatch.parse = (pattern, options) => {\n    if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n    return parse(pattern, {\n      ...options,\n      fastpaths: false\n    });\n  };\n\n  /**\n   * Scan a glob pattern to separate the pattern into segments.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.scan(input[, options]);\n   *\n   * const result = picomatch.scan('!./foo/*.js');\n   * console.log(result);\n   * { prefix: '!./',\n   *   input: '!./foo/*.js',\n   *   start: 3,\n   *   base: 'foo',\n   *   glob: '*.js',\n   *   isBrace: false,\n   *   isBracket: false,\n   *   isGlob: true,\n   *   isExtglob: false,\n   *   isGlobstar: false,\n   *   negated: true }\n   * ```\n   * @param {String} `input` Glob pattern to scan.\n   * @param {Object} `options`\n   * @return {Object} Returns an object with\n   * @api public\n   */\n\n  picomatch.scan = (input, options) => scan(input, options);\n\n  /**\n   * Compile a regular expression from the `state` object returned by the\n   * [parse()](#parse) method.\n   *\n   * @param {Object} `state`\n   * @param {Object} `options`\n   * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n   * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n   * @return {RegExp}\n   * @api public\n   */\n\n  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n    if (returnOutput === true) {\n      return state.output;\n    }\n    const opts = options || {};\n    const prepend = opts.contains ? '' : '^';\n    const append = opts.contains ? '' : '$';\n    let source = `${prepend}(?:${state.output})${append}`;\n    if (state && state.negated === true) {\n      source = `^(?!${source}).*$`;\n    }\n    const regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n      regex.state = state;\n    }\n    return regex;\n  };\n\n  /**\n   * Create a regular expression from a parsed glob pattern.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * const state = picomatch.parse('*.js');\n   * // picomatch.compileRe(state[, options]);\n   *\n   * console.log(picomatch.compileRe(state));\n   * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n   * ```\n   * @param {String} `state` The object returned from the `.parse` method.\n   * @param {Object} `options`\n   * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n   * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n   * @return {RegExp} Returns a regex created from the given pattern.\n   * @api public\n   */\n\n  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n    if (!input || typeof input !== 'string') {\n      throw new TypeError('Expected a non-empty string');\n    }\n    let parsed = {\n      negated: false,\n      fastpaths: true\n    };\n    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n      parsed.output = parse.fastpaths(input, options);\n    }\n    if (!parsed.output) {\n      parsed = parse(input, options);\n    }\n    return picomatch.compileRe(parsed, options, returnOutput, returnState);\n  };\n\n  /**\n   * Create a regular expression from the given regex source string.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.toRegex(source[, options]);\n   *\n   * const { output } = picomatch.parse('*.js');\n   * console.log(picomatch.toRegex(output));\n   * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n   * ```\n   * @param {String} `source` Regular expression source string.\n   * @param {Object} `options`\n   * @return {RegExp}\n   * @api public\n   */\n\n  picomatch.toRegex = (source, options) => {\n    try {\n      const opts = options || {};\n      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n    } catch (err) {\n      if (options && options.debug === true) throw err;\n      return /$^/;\n    }\n  };\n\n  /**\n   * Picomatch constants.\n   * @return {Object}\n   */\n\n  picomatch.constants = constants;\n\n  /**\n   * Expose \"picomatch\"\n   */\n\n  picomatch_1$1 = picomatch;\n  return picomatch_1$1;\n}\nvar picomatch$1;\nvar hasRequiredPicomatch$2;\nfunction requirePicomatch$2() {\n  if (hasRequiredPicomatch$2) return picomatch$1;\n  hasRequiredPicomatch$2 = 1;\n  picomatch$1 = /*@__PURE__*/requirePicomatch$3();\n  return picomatch$1;\n}\nvar readdirp_1;\nvar hasRequiredReaddirp;\nfunction requireReaddirp() {\n  if (hasRequiredReaddirp) return readdirp_1;\n  hasRequiredReaddirp = 1;\n  const fs = require$$0$2;\n  const {\n    Readable\n  } = require$$1;\n  const sysPath = require$$0$1;\n  const {\n    promisify\n  } = require$$2;\n  const picomatch = /*@__PURE__*/requirePicomatch$2();\n  const readdir = promisify(fs.readdir);\n  const stat = promisify(fs.stat);\n  const lstat = promisify(fs.lstat);\n  const realpath = promisify(fs.realpath);\n\n  /**\n   * @typedef {Object} EntryInfo\n   * @property {String} path\n   * @property {String} fullPath\n   * @property {fs.Stats=} stats\n   * @property {fs.Dirent=} dirent\n   * @property {String} basename\n   */\n\n  const BANG = '!';\n  const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\n  const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\n  const FILE_TYPE = 'files';\n  const DIR_TYPE = 'directories';\n  const FILE_DIR_TYPE = 'files_directories';\n  const EVERYTHING_TYPE = 'all';\n  const ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n  const isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n  const [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\n  const wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n  const normalizeFilter = filter => {\n    if (filter === undefined) return;\n    if (typeof filter === 'function') return filter;\n    if (typeof filter === 'string') {\n      const glob = picomatch(filter.trim());\n      return entry => glob(entry.basename);\n    }\n    if (Array.isArray(filter)) {\n      const positive = [];\n      const negative = [];\n      for (const item of filter) {\n        const trimmed = item.trim();\n        if (trimmed.charAt(0) === BANG) {\n          negative.push(picomatch(trimmed.slice(1)));\n        } else {\n          positive.push(picomatch(trimmed));\n        }\n      }\n      if (negative.length > 0) {\n        if (positive.length > 0) {\n          return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n        }\n        return entry => !negative.some(f => f(entry.basename));\n      }\n      return entry => positive.some(f => f(entry.basename));\n    }\n  };\n  class ReaddirpStream extends Readable {\n    static get defaultOptions() {\n      return {\n        root: '.',\n        /* eslint-disable no-unused-vars */\n        fileFilter: path => true,\n        directoryFilter: path => true,\n        /* eslint-enable no-unused-vars */\n        type: FILE_TYPE,\n        lstat: false,\n        depth: 2147483648,\n        alwaysStat: false\n      };\n    }\n    constructor(options = {}) {\n      super({\n        objectMode: true,\n        autoDestroy: true,\n        highWaterMark: options.highWaterMark || 4096\n      });\n      const opts = {\n        ...ReaddirpStream.defaultOptions,\n        ...options\n      };\n      const {\n        root,\n        type\n      } = opts;\n      this._fileFilter = normalizeFilter(opts.fileFilter);\n      this._directoryFilter = normalizeFilter(opts.directoryFilter);\n      const statMethod = opts.lstat ? lstat : stat;\n      // Use bigint stats if it's windows and stat() supports options (node 10+).\n      if (wantBigintFsStats) {\n        this._stat = path => statMethod(path, {\n          bigint: true\n        });\n      } else {\n        this._stat = statMethod;\n      }\n      this._maxDepth = opts.depth;\n      this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n      this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n      this._wantsEverything = type === EVERYTHING_TYPE;\n      this._root = sysPath.resolve(root);\n      this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n      this._statsProp = this._isDirent ? 'dirent' : 'stats';\n      this._rdOptions = {\n        encoding: 'utf8',\n        withFileTypes: this._isDirent\n      };\n\n      // Launch stream with one parent, the root dir.\n      this.parents = [this._exploreDir(root, 1)];\n      this.reading = false;\n      this.parent = undefined;\n    }\n    async _read(batch) {\n      if (this.reading) return;\n      this.reading = true;\n      try {\n        while (!this.destroyed && batch > 0) {\n          const {\n            path,\n            depth,\n            files = []\n          } = this.parent || {};\n          if (files.length > 0) {\n            const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n            for (const entry of await Promise.all(slice)) {\n              if (this.destroyed) return;\n              const entryType = await this._getEntryType(entry);\n              if (entryType === 'directory' && this._directoryFilter(entry)) {\n                if (depth <= this._maxDepth) {\n                  this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n                }\n                if (this._wantsDir) {\n                  this.push(entry);\n                  batch--;\n                }\n              } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n                if (this._wantsFile) {\n                  this.push(entry);\n                  batch--;\n                }\n              }\n            }\n          } else {\n            const parent = this.parents.pop();\n            if (!parent) {\n              this.push(null);\n              break;\n            }\n            this.parent = await parent;\n            if (this.destroyed) return;\n          }\n        }\n      } catch (error) {\n        this.destroy(error);\n      } finally {\n        this.reading = false;\n      }\n    }\n    async _exploreDir(path, depth) {\n      let files;\n      try {\n        files = await readdir(path, this._rdOptions);\n      } catch (error) {\n        this._onError(error);\n      }\n      return {\n        files,\n        depth,\n        path\n      };\n    }\n    async _formatEntry(dirent, path) {\n      let entry;\n      try {\n        const basename = this._isDirent ? dirent.name : dirent;\n        const fullPath = sysPath.resolve(sysPath.join(path, basename));\n        entry = {\n          path: sysPath.relative(this._root, fullPath),\n          fullPath,\n          basename\n        };\n        entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n      } catch (err) {\n        this._onError(err);\n      }\n      return entry;\n    }\n    _onError(err) {\n      if (isNormalFlowError(err) && !this.destroyed) {\n        this.emit('warn', err);\n      } else {\n        this.destroy(err);\n      }\n    }\n    async _getEntryType(entry) {\n      // entry may be undefined, because a warning or an error were emitted\n      // and the statsProp is undefined\n      const stats = entry && entry[this._statsProp];\n      if (!stats) {\n        return;\n      }\n      if (stats.isFile()) {\n        return 'file';\n      }\n      if (stats.isDirectory()) {\n        return 'directory';\n      }\n      if (stats && stats.isSymbolicLink()) {\n        const full = entry.fullPath;\n        try {\n          const entryRealPath = await realpath(full);\n          const entryRealPathStats = await lstat(entryRealPath);\n          if (entryRealPathStats.isFile()) {\n            return 'file';\n          }\n          if (entryRealPathStats.isDirectory()) {\n            const len = entryRealPath.length;\n            if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n              const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n              recursiveError.code = RECURSIVE_ERROR_CODE;\n              return this._onError(recursiveError);\n            }\n            return 'directory';\n          }\n        } catch (error) {\n          this._onError(error);\n        }\n      }\n    }\n    _includeAsFile(entry) {\n      const stats = entry && entry[this._statsProp];\n      return stats && this._wantsEverything && !stats.isDirectory();\n    }\n  }\n\n  /**\n   * @typedef {Object} ReaddirpArguments\n   * @property {Function=} fileFilter\n   * @property {Function=} directoryFilter\n   * @property {String=} type\n   * @property {Number=} depth\n   * @property {String=} root\n   * @property {Boolean=} lstat\n   * @property {Boolean=} bigint\n   */\n\n  /**\n   * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n   * @param {String} root Root directory\n   * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n   */\n  const readdirp = (root, options = {}) => {\n    let type = options.entryType || options.type;\n    if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n    if (type) options.type = type;\n    if (!root) {\n      throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n    } else if (typeof root !== 'string') {\n      throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n    } else if (type && !ALL_TYPES.includes(type)) {\n      throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n    }\n    options.root = root;\n    return new ReaddirpStream(options);\n  };\n  const readdirpPromise = (root, options = {}) => {\n    return new Promise((resolve, reject) => {\n      const files = [];\n      readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n    });\n  };\n  readdirp.promise = readdirpPromise;\n  readdirp.ReaddirpStream = ReaddirpStream;\n  readdirp.default = readdirp;\n  readdirp_1 = readdirp;\n  return readdirp_1;\n}\nvar anymatch = {\n  exports: {}\n};\nvar utils$1 = {};\nvar constants$2;\nvar hasRequiredConstants$2;\nfunction requireConstants$2() {\n  if (hasRequiredConstants$2) return constants$2;\n  hasRequiredConstants$2 = 1;\n  const path = require$$0$1;\n  const WIN_SLASH = '\\\\\\\\/';\n  const WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n  /**\n   * Posix glob regex\n   */\n\n  const DOT_LITERAL = '\\\\.';\n  const PLUS_LITERAL = '\\\\+';\n  const QMARK_LITERAL = '\\\\?';\n  const SLASH_LITERAL = '\\\\/';\n  const ONE_CHAR = '(?=.)';\n  const QMARK = '[^/]';\n  const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n  const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n  const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n  const NO_DOT = `(?!${DOT_LITERAL})`;\n  const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n  const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n  const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n  const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n  const STAR = `${QMARK}*?`;\n  const POSIX_CHARS = {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    QMARK_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    QMARK,\n    END_ANCHOR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  };\n\n  /**\n   * Windows glob regex\n   */\n\n  const WINDOWS_CHARS = {\n    ...POSIX_CHARS,\n    SLASH_LITERAL: `[${WIN_SLASH}]`,\n    QMARK: WIN_NO_SLASH,\n    STAR: `${WIN_NO_SLASH}*?`,\n    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n    NO_DOT: `(?!${DOT_LITERAL})`,\n    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n  };\n\n  /**\n   * POSIX Bracket Regex\n   */\n\n  const POSIX_REGEX_SOURCE = {\n    alnum: 'a-zA-Z0-9',\n    alpha: 'a-zA-Z',\n    ascii: '\\\\x00-\\\\x7F',\n    blank: ' \\\\t',\n    cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n    digit: '0-9',\n    graph: '\\\\x21-\\\\x7E',\n    lower: 'a-z',\n    print: '\\\\x20-\\\\x7E ',\n    punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n    space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n    upper: 'A-Z',\n    word: 'A-Za-z0-9_',\n    xdigit: 'A-Fa-f0-9'\n  };\n  constants$2 = {\n    MAX_LENGTH: 1024 * 64,\n    POSIX_REGEX_SOURCE,\n    // regular expressions\n    REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n    REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n    REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n    REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n    // Replace globs with equivalent patterns to reduce parsing time.\n    REPLACEMENTS: {\n      '***': '*',\n      '**/**': '**',\n      '**/**/**': '**'\n    },\n    // Digits\n    CHAR_0: 48,\n    /* 0 */\n    CHAR_9: 57,\n    /* 9 */\n\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 65,\n    /* A */\n    CHAR_LOWERCASE_A: 97,\n    /* a */\n    CHAR_UPPERCASE_Z: 90,\n    /* Z */\n    CHAR_LOWERCASE_Z: 122,\n    /* z */\n\n    CHAR_LEFT_PARENTHESES: 40,\n    /* ( */\n    CHAR_RIGHT_PARENTHESES: 41,\n    /* ) */\n\n    CHAR_ASTERISK: 42,\n    /* * */\n\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: 38,\n    /* & */\n    CHAR_AT: 64,\n    /* @ */\n    CHAR_BACKWARD_SLASH: 92,\n    /* \\ */\n    CHAR_CARRIAGE_RETURN: 13,\n    /* \\r */\n    CHAR_CIRCUMFLEX_ACCENT: 94,\n    /* ^ */\n    CHAR_COLON: 58,\n    /* : */\n    CHAR_COMMA: 44,\n    /* , */\n    CHAR_DOT: 46,\n    /* . */\n    CHAR_DOUBLE_QUOTE: 34,\n    /* \" */\n    CHAR_EQUAL: 61,\n    /* = */\n    CHAR_EXCLAMATION_MARK: 33,\n    /* ! */\n    CHAR_FORM_FEED: 12,\n    /* \\f */\n    CHAR_FORWARD_SLASH: 47,\n    /* / */\n    CHAR_GRAVE_ACCENT: 96,\n    /* ` */\n    CHAR_HASH: 35,\n    /* # */\n    CHAR_HYPHEN_MINUS: 45,\n    /* - */\n    CHAR_LEFT_ANGLE_BRACKET: 60,\n    /* < */\n    CHAR_LEFT_CURLY_BRACE: 123,\n    /* { */\n    CHAR_LEFT_SQUARE_BRACKET: 91,\n    /* [ */\n    CHAR_LINE_FEED: 10,\n    /* \\n */\n    CHAR_NO_BREAK_SPACE: 160,\n    /* \\u00A0 */\n    CHAR_PERCENT: 37,\n    /* % */\n    CHAR_PLUS: 43,\n    /* + */\n    CHAR_QUESTION_MARK: 63,\n    /* ? */\n    CHAR_RIGHT_ANGLE_BRACKET: 62,\n    /* > */\n    CHAR_RIGHT_CURLY_BRACE: 125,\n    /* } */\n    CHAR_RIGHT_SQUARE_BRACKET: 93,\n    /* ] */\n    CHAR_SEMICOLON: 59,\n    /* ; */\n    CHAR_SINGLE_QUOTE: 39,\n    /* ' */\n    CHAR_SPACE: 32,\n    /*   */\n    CHAR_TAB: 9,\n    /* \\t */\n    CHAR_UNDERSCORE: 95,\n    /* _ */\n    CHAR_VERTICAL_LINE: 124,\n    /* | */\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n    /* \\uFEFF */\n\n    SEP: path.sep,\n    /**\n     * Create EXTGLOB_CHARS\n     */\n\n    extglobChars(chars) {\n      return {\n        '!': {\n          type: 'negate',\n          open: '(?:(?!(?:',\n          close: `))${chars.STAR})`\n        },\n        '?': {\n          type: 'qmark',\n          open: '(?:',\n          close: ')?'\n        },\n        '+': {\n          type: 'plus',\n          open: '(?:',\n          close: ')+'\n        },\n        '*': {\n          type: 'star',\n          open: '(?:',\n          close: ')*'\n        },\n        '@': {\n          type: 'at',\n          open: '(?:',\n          close: ')'\n        }\n      };\n    },\n    /**\n     * Create GLOB_CHARS\n     */\n\n    globChars(win32) {\n      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n    }\n  };\n  return constants$2;\n}\nvar hasRequiredUtils$1;\nfunction requireUtils$1() {\n  if (hasRequiredUtils$1) return utils$1;\n  hasRequiredUtils$1 = 1;\n  (function (exports) {\n    const path = require$$0$1;\n    const win32 = process.platform === 'win32';\n    const {\n      REGEX_BACKSLASH,\n      REGEX_REMOVE_BACKSLASH,\n      REGEX_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_GLOBAL\n    } = /*@__PURE__*/requireConstants$2();\n    exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n    exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n    exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n    exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n    exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n    exports.removeBackslashes = str => {\n      return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n        return match === '\\\\' ? '' : match;\n      });\n    };\n    exports.supportsLookbehinds = () => {\n      const segs = process.version.slice(1).split('.').map(Number);\n      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n        return true;\n      }\n      return false;\n    };\n    exports.isWindows = options => {\n      if (options && typeof options.windows === 'boolean') {\n        return options.windows;\n      }\n      return win32 === true || path.sep === '\\\\';\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n      const idx = input.lastIndexOf(char, lastIdx);\n      if (idx === -1) return input;\n      if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n      return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n    };\n    exports.removePrefix = (input, state = {}) => {\n      let output = input;\n      if (output.startsWith('./')) {\n        output = output.slice(2);\n        state.prefix = './';\n      }\n      return output;\n    };\n    exports.wrapOutput = (input, state = {}, options = {}) => {\n      const prepend = options.contains ? '' : '^';\n      const append = options.contains ? '' : '$';\n      let output = `${prepend}(?:${input})${append}`;\n      if (state.negated === true) {\n        output = `(?:^(?!${output}).*$)`;\n      }\n      return output;\n    };\n  })(utils$1);\n  return utils$1;\n}\nvar scan_1;\nvar hasRequiredScan;\nfunction requireScan() {\n  if (hasRequiredScan) return scan_1;\n  hasRequiredScan = 1;\n  const utils = /*@__PURE__*/requireUtils$1();\n  const {\n    CHAR_ASTERISK,\n    /* * */\n    CHAR_AT,\n    /* @ */\n    CHAR_BACKWARD_SLASH,\n    /* \\ */\n    CHAR_COMMA,\n    /* , */\n    CHAR_DOT,\n    /* . */\n    CHAR_EXCLAMATION_MARK,\n    /* ! */\n    CHAR_FORWARD_SLASH,\n    /* / */\n    CHAR_LEFT_CURLY_BRACE,\n    /* { */\n    CHAR_LEFT_PARENTHESES,\n    /* ( */\n    CHAR_LEFT_SQUARE_BRACKET,\n    /* [ */\n    CHAR_PLUS,\n    /* + */\n    CHAR_QUESTION_MARK,\n    /* ? */\n    CHAR_RIGHT_CURLY_BRACE,\n    /* } */\n    CHAR_RIGHT_PARENTHESES,\n    /* ) */\n    CHAR_RIGHT_SQUARE_BRACKET /* ] */\n  } = /*@__PURE__*/requireConstants$2();\n  const isPathSeparator = code => {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n  };\n  const depth = token => {\n    if (token.isPrefix !== true) {\n      token.depth = token.isGlobstar ? Infinity : 1;\n    }\n  };\n\n  /**\n   * Quickly scans a glob pattern and returns an object with a handful of\n   * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n   * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n   * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n   *\n   * ```js\n   * const pm = require('picomatch');\n   * console.log(pm.scan('foo/bar/*.js'));\n   * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n   * ```\n   * @param {String} `str`\n   * @param {Object} `options`\n   * @return {Object} Returns an object with tokens and regex source string.\n   * @api public\n   */\n\n  const scan = (input, options) => {\n    const opts = options || {};\n    const length = input.length - 1;\n    const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n    const slashes = [];\n    const tokens = [];\n    const parts = [];\n    let str = input;\n    let index = -1;\n    let start = 0;\n    let lastIndex = 0;\n    let isBrace = false;\n    let isBracket = false;\n    let isGlob = false;\n    let isExtglob = false;\n    let isGlobstar = false;\n    let braceEscaped = false;\n    let backslashes = false;\n    let negated = false;\n    let negatedExtglob = false;\n    let finished = false;\n    let braces = 0;\n    let prev;\n    let code;\n    let token = {\n      value: '',\n      depth: 0,\n      isGlob: false\n    };\n    const eos = () => index >= length;\n    const peek = () => str.charCodeAt(index + 1);\n    const advance = () => {\n      prev = code;\n      return str.charCodeAt(++index);\n    };\n    while (index < length) {\n      code = advance();\n      let next;\n      if (code === CHAR_BACKWARD_SLASH) {\n        backslashes = token.backslashes = true;\n        code = advance();\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braceEscaped = true;\n        }\n        continue;\n      }\n      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n        braces++;\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_BACKWARD_SLASH) {\n            backslashes = token.backslashes = true;\n            advance();\n            continue;\n          }\n          if (code === CHAR_LEFT_CURLY_BRACE) {\n            braces++;\n            continue;\n          }\n          if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n            isBrace = token.isBrace = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n              continue;\n            }\n            break;\n          }\n          if (braceEscaped !== true && code === CHAR_COMMA) {\n            isBrace = token.isBrace = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            if (scanToEnd === true) {\n              continue;\n            }\n            break;\n          }\n          if (code === CHAR_RIGHT_CURLY_BRACE) {\n            braces--;\n            if (braces === 0) {\n              braceEscaped = false;\n              isBrace = token.isBrace = true;\n              finished = true;\n              break;\n            }\n          }\n        }\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_FORWARD_SLASH) {\n        slashes.push(index);\n        tokens.push(token);\n        token = {\n          value: '',\n          depth: 0,\n          isGlob: false\n        };\n        if (finished === true) continue;\n        if (prev === CHAR_DOT && index === start + 1) {\n          start += 2;\n          continue;\n        }\n        lastIndex = index + 1;\n        continue;\n      }\n      if (opts.noext !== true) {\n        const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n        if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n          isGlob = token.isGlob = true;\n          isExtglob = token.isExtglob = true;\n          finished = true;\n          if (code === CHAR_EXCLAMATION_MARK && index === start) {\n            negatedExtglob = true;\n          }\n          if (scanToEnd === true) {\n            while (eos() !== true && (code = advance())) {\n              if (code === CHAR_BACKWARD_SLASH) {\n                backslashes = token.backslashes = true;\n                code = advance();\n                continue;\n              }\n              if (code === CHAR_RIGHT_PARENTHESES) {\n                isGlob = token.isGlob = true;\n                finished = true;\n                break;\n              }\n            }\n            continue;\n          }\n          break;\n        }\n      }\n      if (code === CHAR_ASTERISK) {\n        if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n        isGlob = token.isGlob = true;\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_QUESTION_MARK) {\n        isGlob = token.isGlob = true;\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (code === CHAR_LEFT_SQUARE_BRACKET) {\n        while (eos() !== true && (next = advance())) {\n          if (next === CHAR_BACKWARD_SLASH) {\n            backslashes = token.backslashes = true;\n            advance();\n            continue;\n          }\n          if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n            isBracket = token.isBracket = true;\n            isGlob = token.isGlob = true;\n            finished = true;\n            break;\n          }\n        }\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n      if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n        negated = token.negated = true;\n        start++;\n        continue;\n      }\n      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_LEFT_PARENTHESES) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n      if (isGlob === true) {\n        finished = true;\n        if (scanToEnd === true) {\n          continue;\n        }\n        break;\n      }\n    }\n    if (opts.noext === true) {\n      isExtglob = false;\n      isGlob = false;\n    }\n    let base = str;\n    let prefix = '';\n    let glob = '';\n    if (start > 0) {\n      prefix = str.slice(0, start);\n      str = str.slice(start);\n      lastIndex -= start;\n    }\n    if (base && isGlob === true && lastIndex > 0) {\n      base = str.slice(0, lastIndex);\n      glob = str.slice(lastIndex);\n    } else if (isGlob === true) {\n      base = '';\n      glob = str;\n    } else {\n      base = str;\n    }\n    if (base && base !== '' && base !== '/' && base !== str) {\n      if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n        base = base.slice(0, -1);\n      }\n    }\n    if (opts.unescape === true) {\n      if (glob) glob = utils.removeBackslashes(glob);\n      if (base && backslashes === true) {\n        base = utils.removeBackslashes(base);\n      }\n    }\n    const state = {\n      prefix,\n      input,\n      start,\n      base,\n      glob,\n      isBrace,\n      isBracket,\n      isGlob,\n      isExtglob,\n      isGlobstar,\n      negated,\n      negatedExtglob\n    };\n    if (opts.tokens === true) {\n      state.maxDepth = 0;\n      if (!isPathSeparator(code)) {\n        tokens.push(token);\n      }\n      state.tokens = tokens;\n    }\n    if (opts.parts === true || opts.tokens === true) {\n      let prevIndex;\n      for (let idx = 0; idx < slashes.length; idx++) {\n        const n = prevIndex ? prevIndex + 1 : start;\n        const i = slashes[idx];\n        const value = input.slice(n, i);\n        if (opts.tokens) {\n          if (idx === 0 && start !== 0) {\n            tokens[idx].isPrefix = true;\n            tokens[idx].value = prefix;\n          } else {\n            tokens[idx].value = value;\n          }\n          depth(tokens[idx]);\n          state.maxDepth += tokens[idx].depth;\n        }\n        if (idx !== 0 || value !== '') {\n          parts.push(value);\n        }\n        prevIndex = i;\n      }\n      if (prevIndex && prevIndex + 1 < input.length) {\n        const value = input.slice(prevIndex + 1);\n        parts.push(value);\n        if (opts.tokens) {\n          tokens[tokens.length - 1].value = value;\n          depth(tokens[tokens.length - 1]);\n          state.maxDepth += tokens[tokens.length - 1].depth;\n        }\n      }\n      state.slashes = slashes;\n      state.parts = parts;\n    }\n    return state;\n  };\n  scan_1 = scan;\n  return scan_1;\n}\nvar parse_1$1;\nvar hasRequiredParse$1;\nfunction requireParse$1() {\n  if (hasRequiredParse$1) return parse_1$1;\n  hasRequiredParse$1 = 1;\n  const constants = /*@__PURE__*/requireConstants$2();\n  const utils = /*@__PURE__*/requireUtils$1();\n\n  /**\n   * Constants\n   */\n\n  const {\n    MAX_LENGTH,\n    POSIX_REGEX_SOURCE,\n    REGEX_NON_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_BACKREF,\n    REPLACEMENTS\n  } = constants;\n\n  /**\n   * Helpers\n   */\n\n  const expandRange = (args, options) => {\n    if (typeof options.expandRange === 'function') {\n      return options.expandRange(...args, options);\n    }\n    args.sort();\n    const value = `[${args.join('-')}]`;\n    return value;\n  };\n\n  /**\n   * Create the message for a syntax error\n   */\n\n  const syntaxError = (type, char) => {\n    return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n  };\n\n  /**\n   * Parse the given input string.\n   * @param {String} input\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  const parse = (input, options) => {\n    if (typeof input !== 'string') {\n      throw new TypeError('Expected a string');\n    }\n    input = REPLACEMENTS[input] || input;\n    const opts = {\n      ...options\n    };\n    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    let len = input.length;\n    if (len > max) {\n      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    const bos = {\n      type: 'bos',\n      value: '',\n      output: opts.prepend || ''\n    };\n    const tokens = [bos];\n    const capture = opts.capture ? '' : '?:';\n    const win32 = utils.isWindows(options);\n\n    // create constants based on platform, for windows or posix\n    const PLATFORM_CHARS = constants.globChars(win32);\n    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n    const {\n      DOT_LITERAL,\n      PLUS_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOT_SLASH,\n      NO_DOTS_SLASH,\n      QMARK,\n      QMARK_NO_DOT,\n      STAR,\n      START_ANCHOR\n    } = PLATFORM_CHARS;\n    const globstar = opts => {\n      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const nodot = opts.dot ? '' : NO_DOT;\n    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n    let star = opts.bash === true ? globstar(opts) : STAR;\n    if (opts.capture) {\n      star = `(${star})`;\n    }\n\n    // minimatch options support\n    if (typeof opts.noext === 'boolean') {\n      opts.noextglob = opts.noext;\n    }\n    const state = {\n      input,\n      index: -1,\n      start: 0,\n      dot: opts.dot === true,\n      consumed: '',\n      output: '',\n      prefix: '',\n      backtrack: false,\n      negated: false,\n      brackets: 0,\n      braces: 0,\n      parens: 0,\n      quotes: 0,\n      globstar: false,\n      tokens\n    };\n    input = utils.removePrefix(input, state);\n    len = input.length;\n    const extglobs = [];\n    const braces = [];\n    const stack = [];\n    let prev = bos;\n    let value;\n\n    /**\n     * Tokenizing helpers\n     */\n\n    const eos = () => state.index === len - 1;\n    const peek = state.peek = (n = 1) => input[state.index + n];\n    const advance = state.advance = () => input[++state.index] || '';\n    const remaining = () => input.slice(state.index + 1);\n    const consume = (value = '', num = 0) => {\n      state.consumed += value;\n      state.index += num;\n    };\n    const append = token => {\n      state.output += token.output != null ? token.output : token.value;\n      consume(token.value);\n    };\n    const negate = () => {\n      let count = 1;\n      while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n        advance();\n        state.start++;\n        count++;\n      }\n      if (count % 2 === 0) {\n        return false;\n      }\n      state.negated = true;\n      state.start++;\n      return true;\n    };\n    const increment = type => {\n      state[type]++;\n      stack.push(type);\n    };\n    const decrement = type => {\n      state[type]--;\n      stack.pop();\n    };\n\n    /**\n     * Push tokens onto the tokens array. This helper speeds up\n     * tokenizing by 1) helping us avoid backtracking as much as possible,\n     * and 2) helping us avoid creating extra tokens when consecutive\n     * characters are plain text. This improves performance and simplifies\n     * lookbehinds.\n     */\n\n    const push = tok => {\n      if (prev.type === 'globstar') {\n        const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n        if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n          state.output = state.output.slice(0, -prev.output.length);\n          prev.type = 'star';\n          prev.value = '*';\n          prev.output = star;\n          state.output += prev.output;\n        }\n      }\n      if (extglobs.length && tok.type !== 'paren') {\n        extglobs[extglobs.length - 1].inner += tok.value;\n      }\n      if (tok.value || tok.output) append(tok);\n      if (prev && prev.type === 'text' && tok.type === 'text') {\n        prev.value += tok.value;\n        prev.output = (prev.output || '') + tok.value;\n        return;\n      }\n      tok.prev = prev;\n      tokens.push(tok);\n      prev = tok;\n    };\n    const extglobOpen = (type, value) => {\n      const token = {\n        ...EXTGLOB_CHARS[value],\n        conditions: 1,\n        inner: ''\n      };\n      token.prev = prev;\n      token.parens = state.parens;\n      token.output = state.output;\n      const output = (opts.capture ? '(' : '') + token.open;\n      increment('parens');\n      push({\n        type,\n        value,\n        output: state.output ? '' : ONE_CHAR\n      });\n      push({\n        type: 'paren',\n        extglob: true,\n        value: advance(),\n        output\n      });\n      extglobs.push(token);\n    };\n    const extglobClose = token => {\n      let output = token.close + (opts.capture ? ')' : '');\n      let rest;\n      if (token.type === 'negate') {\n        let extglobStar = star;\n        if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n          extglobStar = globstar(opts);\n        }\n        if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n          output = token.close = `)$))${extglobStar}`;\n        }\n        if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n          // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n          // In this case, we need to parse the string and use it in the output of the original pattern.\n          // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n          //\n          // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n          const expression = parse(rest, {\n            ...options,\n            fastpaths: false\n          }).output;\n          output = token.close = `)${expression})${extglobStar})`;\n        }\n        if (token.prev.type === 'bos') {\n          state.negatedExtglob = true;\n        }\n      }\n      push({\n        type: 'paren',\n        extglob: true,\n        value,\n        output\n      });\n      decrement('parens');\n    };\n\n    /**\n     * Fast paths\n     */\n\n    if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n      let backslashes = false;\n      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n        if (first === '\\\\') {\n          backslashes = true;\n          return m;\n        }\n        if (first === '?') {\n          if (esc) {\n            return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n          }\n          if (index === 0) {\n            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n          }\n          return QMARK.repeat(chars.length);\n        }\n        if (first === '.') {\n          return DOT_LITERAL.repeat(chars.length);\n        }\n        if (first === '*') {\n          if (esc) {\n            return esc + first + (rest ? star : '');\n          }\n          return star;\n        }\n        return esc ? m : `\\\\${m}`;\n      });\n      if (backslashes === true) {\n        if (opts.unescape === true) {\n          output = output.replace(/\\\\/g, '');\n        } else {\n          output = output.replace(/\\\\+/g, m => {\n            return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n          });\n        }\n      }\n      if (output === input && opts.contains === true) {\n        state.output = input;\n        return state;\n      }\n      state.output = utils.wrapOutput(output, state, options);\n      return state;\n    }\n\n    /**\n     * Tokenize input until we reach end-of-string\n     */\n\n    while (!eos()) {\n      value = advance();\n      if (value === '\\u0000') {\n        continue;\n      }\n\n      /**\n       * Escaped characters\n       */\n\n      if (value === '\\\\') {\n        const next = peek();\n        if (next === '/' && opts.bash !== true) {\n          continue;\n        }\n        if (next === '.' || next === ';') {\n          continue;\n        }\n        if (!next) {\n          value += '\\\\';\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n\n        // collapse slashes to reduce potential for exploits\n        const match = /^\\\\+/.exec(remaining());\n        let slashes = 0;\n        if (match && match[0].length > 2) {\n          slashes = match[0].length;\n          state.index += slashes;\n          if (slashes % 2 !== 0) {\n            value += '\\\\';\n          }\n        }\n        if (opts.unescape === true) {\n          value = advance();\n        } else {\n          value += advance();\n        }\n        if (state.brackets === 0) {\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n      }\n\n      /**\n       * If we're inside a regex character class, continue\n       * until we reach the closing bracket.\n       */\n\n      if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n        if (opts.posix !== false && value === ':') {\n          const inner = prev.value.slice(1);\n          if (inner.includes('[')) {\n            prev.posix = true;\n            if (inner.includes(':')) {\n              const idx = prev.value.lastIndexOf('[');\n              const pre = prev.value.slice(0, idx);\n              const rest = prev.value.slice(idx + 2);\n              const posix = POSIX_REGEX_SOURCE[rest];\n              if (posix) {\n                prev.value = pre + posix;\n                state.backtrack = true;\n                advance();\n                if (!bos.output && tokens.indexOf(prev) === 1) {\n                  bos.output = ONE_CHAR;\n                }\n                continue;\n              }\n            }\n          }\n        }\n        if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n          value = `\\\\${value}`;\n        }\n        if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n          value = `\\\\${value}`;\n        }\n        if (opts.posix === true && value === '!' && prev.value === '[') {\n          value = '^';\n        }\n        prev.value += value;\n        append({\n          value\n        });\n        continue;\n      }\n\n      /**\n       * If we're inside a quoted string, continue\n       * until we reach the closing double quote.\n       */\n\n      if (state.quotes === 1 && value !== '\"') {\n        value = utils.escapeRegex(value);\n        prev.value += value;\n        append({\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Double quotes\n       */\n\n      if (value === '\"') {\n        state.quotes = state.quotes === 1 ? 0 : 1;\n        if (opts.keepQuotes === true) {\n          push({\n            type: 'text',\n            value\n          });\n        }\n        continue;\n      }\n\n      /**\n       * Parentheses\n       */\n\n      if (value === '(') {\n        increment('parens');\n        push({\n          type: 'paren',\n          value\n        });\n        continue;\n      }\n      if (value === ')') {\n        if (state.parens === 0 && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '('));\n        }\n        const extglob = extglobs[extglobs.length - 1];\n        if (extglob && state.parens === extglob.parens + 1) {\n          extglobClose(extglobs.pop());\n          continue;\n        }\n        push({\n          type: 'paren',\n          value,\n          output: state.parens ? ')' : '\\\\)'\n        });\n        decrement('parens');\n        continue;\n      }\n\n      /**\n       * Square brackets\n       */\n\n      if (value === '[') {\n        if (opts.nobracket === true || !remaining().includes(']')) {\n          if (opts.nobracket !== true && opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError('closing', ']'));\n          }\n          value = `\\\\${value}`;\n        } else {\n          increment('brackets');\n        }\n        push({\n          type: 'bracket',\n          value\n        });\n        continue;\n      }\n      if (value === ']') {\n        if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n          push({\n            type: 'text',\n            value,\n            output: `\\\\${value}`\n          });\n          continue;\n        }\n        if (state.brackets === 0) {\n          if (opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError('opening', '['));\n          }\n          push({\n            type: 'text',\n            value,\n            output: `\\\\${value}`\n          });\n          continue;\n        }\n        decrement('brackets');\n        const prevValue = prev.value.slice(1);\n        if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n          value = `/${value}`;\n        }\n        prev.value += value;\n        append({\n          value\n        });\n\n        // when literal brackets are explicitly disabled\n        // assume we should match with a regex character class\n        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n          continue;\n        }\n        const escaped = utils.escapeRegex(prev.value);\n        state.output = state.output.slice(0, -prev.value.length);\n\n        // when literal brackets are explicitly enabled\n        // assume we should escape the brackets to match literal characters\n        if (opts.literalBrackets === true) {\n          state.output += escaped;\n          prev.value = escaped;\n          continue;\n        }\n\n        // when the user specifies nothing, try to match both\n        prev.value = `(${capture}${escaped}|${prev.value})`;\n        state.output += prev.value;\n        continue;\n      }\n\n      /**\n       * Braces\n       */\n\n      if (value === '{' && opts.nobrace !== true) {\n        increment('braces');\n        const open = {\n          type: 'brace',\n          value,\n          output: '(',\n          outputIndex: state.output.length,\n          tokensIndex: state.tokens.length\n        };\n        braces.push(open);\n        push(open);\n        continue;\n      }\n      if (value === '}') {\n        const brace = braces[braces.length - 1];\n        if (opts.nobrace === true || !brace) {\n          push({\n            type: 'text',\n            value,\n            output: value\n          });\n          continue;\n        }\n        let output = ')';\n        if (brace.dots === true) {\n          const arr = tokens.slice();\n          const range = [];\n          for (let i = arr.length - 1; i >= 0; i--) {\n            tokens.pop();\n            if (arr[i].type === 'brace') {\n              break;\n            }\n            if (arr[i].type !== 'dots') {\n              range.unshift(arr[i].value);\n            }\n          }\n          output = expandRange(range, opts);\n          state.backtrack = true;\n        }\n        if (brace.comma !== true && brace.dots !== true) {\n          const out = state.output.slice(0, brace.outputIndex);\n          const toks = state.tokens.slice(brace.tokensIndex);\n          brace.value = brace.output = '\\\\{';\n          value = output = '\\\\}';\n          state.output = out;\n          for (const t of toks) {\n            state.output += t.output || t.value;\n          }\n        }\n        push({\n          type: 'brace',\n          value,\n          output\n        });\n        decrement('braces');\n        braces.pop();\n        continue;\n      }\n\n      /**\n       * Pipes\n       */\n\n      if (value === '|') {\n        if (extglobs.length > 0) {\n          extglobs[extglobs.length - 1].conditions++;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Commas\n       */\n\n      if (value === ',') {\n        let output = value;\n        const brace = braces[braces.length - 1];\n        if (brace && stack[stack.length - 1] === 'braces') {\n          brace.comma = true;\n          output = '|';\n        }\n        push({\n          type: 'comma',\n          value,\n          output\n        });\n        continue;\n      }\n\n      /**\n       * Slashes\n       */\n\n      if (value === '/') {\n        // if the beginning of the glob is \"./\", advance the start\n        // to the current index, and don't add the \"./\" characters\n        // to the state. This greatly simplifies lookbehinds when\n        // checking for BOS characters like \"!\" and \".\" (not \"./\")\n        if (prev.type === 'dot' && state.index === state.start + 1) {\n          state.start = state.index + 1;\n          state.consumed = '';\n          state.output = '';\n          tokens.pop();\n          prev = bos; // reset \"prev\" to the first token\n          continue;\n        }\n        push({\n          type: 'slash',\n          value,\n          output: SLASH_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Dots\n       */\n\n      if (value === '.') {\n        if (state.braces > 0 && prev.type === 'dot') {\n          if (prev.value === '.') prev.output = DOT_LITERAL;\n          const brace = braces[braces.length - 1];\n          prev.type = 'dots';\n          prev.output += value;\n          prev.value += value;\n          brace.dots = true;\n          continue;\n        }\n        if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n          push({\n            type: 'text',\n            value,\n            output: DOT_LITERAL\n          });\n          continue;\n        }\n        push({\n          type: 'dot',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Question marks\n       */\n\n      if (value === '?') {\n        const isGroup = prev && prev.value === '(';\n        if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          extglobOpen('qmark', value);\n          continue;\n        }\n        if (prev && prev.type === 'paren') {\n          const next = peek();\n          let output = value;\n          if (next === '<' && !utils.supportsLookbehinds()) {\n            throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n          }\n          if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n            output = `\\\\${value}`;\n          }\n          push({\n            type: 'text',\n            value,\n            output\n          });\n          continue;\n        }\n        if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n          push({\n            type: 'qmark',\n            value,\n            output: QMARK_NO_DOT\n          });\n          continue;\n        }\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK\n        });\n        continue;\n      }\n\n      /**\n       * Exclamation\n       */\n\n      if (value === '!') {\n        if (opts.noextglob !== true && peek() === '(') {\n          if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n            extglobOpen('negate', value);\n            continue;\n          }\n        }\n        if (opts.nonegate !== true && state.index === 0) {\n          negate();\n          continue;\n        }\n      }\n\n      /**\n       * Plus\n       */\n\n      if (value === '+') {\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          extglobOpen('plus', value);\n          continue;\n        }\n        if (prev && prev.value === '(' || opts.regex === false) {\n          push({\n            type: 'plus',\n            value,\n            output: PLUS_LITERAL\n          });\n          continue;\n        }\n        if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n          push({\n            type: 'plus',\n            value\n          });\n          continue;\n        }\n        push({\n          type: 'plus',\n          value: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      /**\n       * Plain text\n       */\n\n      if (value === '@') {\n        if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n          push({\n            type: 'at',\n            extglob: true,\n            value,\n            output: ''\n          });\n          continue;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Plain text\n       */\n\n      if (value !== '*') {\n        if (value === '$' || value === '^') {\n          value = `\\\\${value}`;\n        }\n        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n        if (match) {\n          value += match[0];\n          state.index += match[0].length;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Stars\n       */\n\n      if (prev && (prev.type === 'globstar' || prev.star === true)) {\n        prev.type = 'star';\n        prev.star = true;\n        prev.value += value;\n        prev.output = star;\n        state.backtrack = true;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      let rest = remaining();\n      if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n        extglobOpen('star', value);\n        continue;\n      }\n      if (prev.type === 'star') {\n        if (opts.noglobstar === true) {\n          consume(value);\n          continue;\n        }\n        const prior = prev.prev;\n        const before = prior.prev;\n        const isStart = prior.type === 'slash' || prior.type === 'bos';\n        const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n          push({\n            type: 'star',\n            value,\n            output: ''\n          });\n          continue;\n        }\n        const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n        const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n        if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n          push({\n            type: 'star',\n            value,\n            output: ''\n          });\n          continue;\n        }\n\n        // strip consecutive `/**/`\n        while (rest.slice(0, 3) === '/**') {\n          const after = input[state.index + 4];\n          if (after && after !== '/') {\n            break;\n          }\n          rest = rest.slice(3);\n          consume('/**', 3);\n        }\n        if (prior.type === 'bos' && eos()) {\n          prev.type = 'globstar';\n          prev.value += value;\n          prev.output = globstar(opts);\n          state.output = prev.output;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n          state.output = state.output.slice(0, -(prior.output + prev.output).length);\n          prior.output = `(?:${prior.output}`;\n          prev.type = 'globstar';\n          prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n          prev.value += value;\n          state.globstar = true;\n          state.output += prior.output + prev.output;\n          consume(value);\n          continue;\n        }\n        if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n          const end = rest[1] !== void 0 ? '|$' : '';\n          state.output = state.output.slice(0, -(prior.output + prev.output).length);\n          prior.output = `(?:${prior.output}`;\n          prev.type = 'globstar';\n          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n          prev.value += value;\n          state.output += prior.output + prev.output;\n          state.globstar = true;\n          consume(value + advance());\n          push({\n            type: 'slash',\n            value: '/',\n            output: ''\n          });\n          continue;\n        }\n        if (prior.type === 'bos' && rest[0] === '/') {\n          prev.type = 'globstar';\n          prev.value += value;\n          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n          state.output = prev.output;\n          state.globstar = true;\n          consume(value + advance());\n          push({\n            type: 'slash',\n            value: '/',\n            output: ''\n          });\n          continue;\n        }\n\n        // remove single star from output\n        state.output = state.output.slice(0, -prev.output.length);\n\n        // reset previous token to globstar\n        prev.type = 'globstar';\n        prev.output = globstar(opts);\n        prev.value += value;\n\n        // reset output with globstar\n        state.output += prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      const token = {\n        type: 'star',\n        value,\n        output: star\n      };\n      if (opts.bash === true) {\n        token.output = '.*?';\n        if (prev.type === 'bos' || prev.type === 'slash') {\n          token.output = nodot + token.output;\n        }\n        push(token);\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n        token.output = value;\n        push(token);\n        continue;\n      }\n      if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n        if (prev.type === 'dot') {\n          state.output += NO_DOT_SLASH;\n          prev.output += NO_DOT_SLASH;\n        } else if (opts.dot === true) {\n          state.output += NO_DOTS_SLASH;\n          prev.output += NO_DOTS_SLASH;\n        } else {\n          state.output += nodot;\n          prev.output += nodot;\n        }\n        if (peek() !== '*') {\n          state.output += ONE_CHAR;\n          prev.output += ONE_CHAR;\n        }\n      }\n      push(token);\n    }\n    while (state.brackets > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n      state.output = utils.escapeLast(state.output, '[');\n      decrement('brackets');\n    }\n    while (state.parens > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n      state.output = utils.escapeLast(state.output, '(');\n      decrement('parens');\n    }\n    while (state.braces > 0) {\n      if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n      state.output = utils.escapeLast(state.output, '{');\n      decrement('braces');\n    }\n    if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n      push({\n        type: 'maybe_slash',\n        value: '',\n        output: `${SLASH_LITERAL}?`\n      });\n    }\n\n    // rebuild the output if we had to backtrack at any point\n    if (state.backtrack === true) {\n      state.output = '';\n      for (const token of state.tokens) {\n        state.output += token.output != null ? token.output : token.value;\n        if (token.suffix) {\n          state.output += token.suffix;\n        }\n      }\n    }\n    return state;\n  };\n\n  /**\n   * Fast paths for creating regular expressions for common glob patterns.\n   * This can significantly speed up processing and has very little downside\n   * impact when none of the fast paths match.\n   */\n\n  parse.fastpaths = (input, options) => {\n    const opts = {\n      ...options\n    };\n    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    const len = input.length;\n    if (len > max) {\n      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n    }\n    input = REPLACEMENTS[input] || input;\n    const win32 = utils.isWindows(options);\n\n    // create constants based on platform, for windows or posix\n    const {\n      DOT_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOTS,\n      NO_DOTS_SLASH,\n      STAR,\n      START_ANCHOR\n    } = constants.globChars(win32);\n    const nodot = opts.dot ? NO_DOTS : NO_DOT;\n    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n    const capture = opts.capture ? '' : '?:';\n    const state = {\n      negated: false,\n      prefix: ''\n    };\n    let star = opts.bash === true ? '.*?' : STAR;\n    if (opts.capture) {\n      star = `(${star})`;\n    }\n    const globstar = opts => {\n      if (opts.noglobstar === true) return star;\n      return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n    };\n    const create = str => {\n      switch (str) {\n        case '*':\n          return `${nodot}${ONE_CHAR}${star}`;\n        case '.*':\n          return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '*.*':\n          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '*/*':\n          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n        case '**':\n          return nodot + globstar(opts);\n        case '**/*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n        case '**/*.*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n        case '**/.*':\n          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n        default:\n          {\n            const match = /^(.*?)\\.(\\w+)$/.exec(str);\n            if (!match) return;\n            const source = create(match[1]);\n            if (!source) return;\n            return source + DOT_LITERAL + match[2];\n          }\n      }\n    };\n    const output = utils.removePrefix(input, state);\n    let source = create(output);\n    if (source && opts.strictSlashes !== true) {\n      source += `${SLASH_LITERAL}?`;\n    }\n    return source;\n  };\n  parse_1$1 = parse;\n  return parse_1$1;\n}\nvar picomatch_1;\nvar hasRequiredPicomatch$1;\nfunction requirePicomatch$1() {\n  if (hasRequiredPicomatch$1) return picomatch_1;\n  hasRequiredPicomatch$1 = 1;\n  const path = require$$0$1;\n  const scan = /*@__PURE__*/requireScan();\n  const parse = /*@__PURE__*/requireParse$1();\n  const utils = /*@__PURE__*/requireUtils$1();\n  const constants = /*@__PURE__*/requireConstants$2();\n  const isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n  /**\n   * Creates a matcher function from one or more glob patterns. The\n   * returned function takes a string to match as its first argument,\n   * and returns true if the string is a match. The returned matcher\n   * function also takes a boolean as the second argument that, when true,\n   * returns an object with additional information.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch(glob[, options]);\n   *\n   * const isMatch = picomatch('*.!(*a)');\n   * console.log(isMatch('a.a')); //=> false\n   * console.log(isMatch('a.b')); //=> true\n   * ```\n   * @name picomatch\n   * @param {String|Array} `globs` One or more glob patterns.\n   * @param {Object=} `options`\n   * @return {Function=} Returns a matcher function.\n   * @api public\n   */\n\n  const picomatch = (glob, options, returnState = false) => {\n    if (Array.isArray(glob)) {\n      const fns = glob.map(input => picomatch(input, options, returnState));\n      const arrayMatcher = str => {\n        for (const isMatch of fns) {\n          const state = isMatch(str);\n          if (state) return state;\n        }\n        return false;\n      };\n      return arrayMatcher;\n    }\n    const isState = isObject(glob) && glob.tokens && glob.input;\n    if (glob === '' || typeof glob !== 'string' && !isState) {\n      throw new TypeError('Expected pattern to be a non-empty string');\n    }\n    const opts = options || {};\n    const posix = utils.isWindows(options);\n    const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n    const state = regex.state;\n    delete regex.state;\n    let isIgnored = () => false;\n    if (opts.ignore) {\n      const ignoreOpts = {\n        ...options,\n        ignore: null,\n        onMatch: null,\n        onResult: null\n      };\n      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n    }\n    const matcher = (input, returnObject = false) => {\n      const {\n        isMatch,\n        match,\n        output\n      } = picomatch.test(input, regex, options, {\n        glob,\n        posix\n      });\n      const result = {\n        glob,\n        state,\n        regex,\n        posix,\n        input,\n        output,\n        match,\n        isMatch\n      };\n      if (typeof opts.onResult === 'function') {\n        opts.onResult(result);\n      }\n      if (isMatch === false) {\n        result.isMatch = false;\n        return returnObject ? result : false;\n      }\n      if (isIgnored(input)) {\n        if (typeof opts.onIgnore === 'function') {\n          opts.onIgnore(result);\n        }\n        result.isMatch = false;\n        return returnObject ? result : false;\n      }\n      if (typeof opts.onMatch === 'function') {\n        opts.onMatch(result);\n      }\n      return returnObject ? result : true;\n    };\n    if (returnState) {\n      matcher.state = state;\n    }\n    return matcher;\n  };\n\n  /**\n   * Test `input` with the given `regex`. This is used by the main\n   * `picomatch()` function to test the input string.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.test(input, regex[, options]);\n   *\n   * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n   * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n   * ```\n   * @param {String} `input` String to test.\n   * @param {RegExp} `regex`\n   * @return {Object} Returns an object with matching info.\n   * @api public\n   */\n\n  picomatch.test = (input, regex, options, {\n    glob,\n    posix\n  } = {}) => {\n    if (typeof input !== 'string') {\n      throw new TypeError('Expected input to be a string');\n    }\n    if (input === '') {\n      return {\n        isMatch: false,\n        output: ''\n      };\n    }\n    const opts = options || {};\n    const format = opts.format || (posix ? utils.toPosixSlashes : null);\n    let match = input === glob;\n    let output = match && format ? format(input) : input;\n    if (match === false) {\n      output = format ? format(input) : input;\n      match = output === glob;\n    }\n    if (match === false || opts.capture === true) {\n      if (opts.matchBase === true || opts.basename === true) {\n        match = picomatch.matchBase(input, regex, options, posix);\n      } else {\n        match = regex.exec(output);\n      }\n    }\n    return {\n      isMatch: Boolean(match),\n      match,\n      output\n    };\n  };\n\n  /**\n   * Match the basename of a filepath.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.matchBase(input, glob[, options]);\n   * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n   * ```\n   * @param {String} `input` String to test.\n   * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n   * @return {Boolean}\n   * @api public\n   */\n\n  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n    return regex.test(path.basename(input));\n  };\n\n  /**\n   * Returns true if **any** of the given glob `patterns` match the specified `string`.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.isMatch(string, patterns[, options]);\n   *\n   * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n   * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n   * ```\n   * @param {String|Array} str The string to test.\n   * @param {String|Array} patterns One or more glob patterns to use for matching.\n   * @param {Object} [options] See available [options](#options).\n   * @return {Boolean} Returns true if any patterns match `str`\n   * @api public\n   */\n\n  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n  /**\n   * Parse a glob pattern to create the source string for a regular\n   * expression.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * const result = picomatch.parse(pattern[, options]);\n   * ```\n   * @param {String} `pattern`\n   * @param {Object} `options`\n   * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n   * @api public\n   */\n\n  picomatch.parse = (pattern, options) => {\n    if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n    return parse(pattern, {\n      ...options,\n      fastpaths: false\n    });\n  };\n\n  /**\n   * Scan a glob pattern to separate the pattern into segments.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.scan(input[, options]);\n   *\n   * const result = picomatch.scan('!./foo/*.js');\n   * console.log(result);\n   * { prefix: '!./',\n   *   input: '!./foo/*.js',\n   *   start: 3,\n   *   base: 'foo',\n   *   glob: '*.js',\n   *   isBrace: false,\n   *   isBracket: false,\n   *   isGlob: true,\n   *   isExtglob: false,\n   *   isGlobstar: false,\n   *   negated: true }\n   * ```\n   * @param {String} `input` Glob pattern to scan.\n   * @param {Object} `options`\n   * @return {Object} Returns an object with\n   * @api public\n   */\n\n  picomatch.scan = (input, options) => scan(input, options);\n\n  /**\n   * Compile a regular expression from the `state` object returned by the\n   * [parse()](#parse) method.\n   *\n   * @param {Object} `state`\n   * @param {Object} `options`\n   * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n   * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n   * @return {RegExp}\n   * @api public\n   */\n\n  picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n    if (returnOutput === true) {\n      return state.output;\n    }\n    const opts = options || {};\n    const prepend = opts.contains ? '' : '^';\n    const append = opts.contains ? '' : '$';\n    let source = `${prepend}(?:${state.output})${append}`;\n    if (state && state.negated === true) {\n      source = `^(?!${source}).*$`;\n    }\n    const regex = picomatch.toRegex(source, options);\n    if (returnState === true) {\n      regex.state = state;\n    }\n    return regex;\n  };\n\n  /**\n   * Create a regular expression from a parsed glob pattern.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * const state = picomatch.parse('*.js');\n   * // picomatch.compileRe(state[, options]);\n   *\n   * console.log(picomatch.compileRe(state));\n   * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n   * ```\n   * @param {String} `state` The object returned from the `.parse` method.\n   * @param {Object} `options`\n   * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n   * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n   * @return {RegExp} Returns a regex created from the given pattern.\n   * @api public\n   */\n\n  picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n    if (!input || typeof input !== 'string') {\n      throw new TypeError('Expected a non-empty string');\n    }\n    let parsed = {\n      negated: false,\n      fastpaths: true\n    };\n    if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n      parsed.output = parse.fastpaths(input, options);\n    }\n    if (!parsed.output) {\n      parsed = parse(input, options);\n    }\n    return picomatch.compileRe(parsed, options, returnOutput, returnState);\n  };\n\n  /**\n   * Create a regular expression from the given regex source string.\n   *\n   * ```js\n   * const picomatch = require('picomatch');\n   * // picomatch.toRegex(source[, options]);\n   *\n   * const { output } = picomatch.parse('*.js');\n   * console.log(picomatch.toRegex(output));\n   * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n   * ```\n   * @param {String} `source` Regular expression source string.\n   * @param {Object} `options`\n   * @return {RegExp}\n   * @api public\n   */\n\n  picomatch.toRegex = (source, options) => {\n    try {\n      const opts = options || {};\n      return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n    } catch (err) {\n      if (options && options.debug === true) throw err;\n      return /$^/;\n    }\n  };\n\n  /**\n   * Picomatch constants.\n   * @return {Object}\n   */\n\n  picomatch.constants = constants;\n\n  /**\n   * Expose \"picomatch\"\n   */\n\n  picomatch_1 = picomatch;\n  return picomatch_1;\n}\nvar picomatch;\nvar hasRequiredPicomatch;\nfunction requirePicomatch() {\n  if (hasRequiredPicomatch) return picomatch;\n  hasRequiredPicomatch = 1;\n  picomatch = /*@__PURE__*/requirePicomatch$1();\n  return picomatch;\n}\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath;\nvar hasRequiredNormalizePath;\nfunction requireNormalizePath() {\n  if (hasRequiredNormalizePath) return normalizePath;\n  hasRequiredNormalizePath = 1;\n  normalizePath = function (path, stripTrailing) {\n    if (typeof path !== 'string') {\n      throw new TypeError('expected path to be a string');\n    }\n    if (path === '\\\\' || path === '/') return '/';\n    var len = path.length;\n    if (len <= 1) return path;\n\n    // ensure that win32 namespaces has two leading slashes, so that the path is\n    // handled properly by the win32 version of path.parse() after being normalized\n    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n    var prefix = '';\n    if (len > 4 && path[3] === '\\\\') {\n      var ch = path[2];\n      if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n        path = path.slice(2);\n        prefix = '//';\n      }\n    }\n    var segs = path.split(/[/\\\\]+/);\n    if (stripTrailing !== false && segs[segs.length - 1] === '') {\n      segs.pop();\n    }\n    return prefix + segs.join('/');\n  };\n  return normalizePath;\n}\nvar anymatch_1 = anymatch.exports;\nvar hasRequiredAnymatch;\nfunction requireAnymatch() {\n  if (hasRequiredAnymatch) return anymatch.exports;\n  hasRequiredAnymatch = 1;\n  Object.defineProperty(anymatch_1, \"__esModule\", {\n    value: true\n  });\n  const picomatch = /*@__PURE__*/requirePicomatch();\n  const normalizePath = /*@__PURE__*/requireNormalizePath();\n\n  /**\n   * @typedef {(testString: string) => boolean} AnymatchFn\n   * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n   * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n   */\n  const BANG = '!';\n  const DEFAULT_OPTIONS = {\n    returnIndex: false\n  };\n  const arrify = item => Array.isArray(item) ? item : [item];\n\n  /**\n   * @param {AnymatchPattern} matcher\n   * @param {object} options\n   * @returns {AnymatchFn}\n   */\n  const createPattern = (matcher, options) => {\n    if (typeof matcher === 'function') {\n      return matcher;\n    }\n    if (typeof matcher === 'string') {\n      const glob = picomatch(matcher, options);\n      return string => matcher === string || glob(string);\n    }\n    if (matcher instanceof RegExp) {\n      return string => matcher.test(string);\n    }\n    return string => false;\n  };\n\n  /**\n   * @param {Array<Function>} patterns\n   * @param {Array<Function>} negPatterns\n   * @param {String|Array} args\n   * @param {Boolean} returnIndex\n   * @returns {boolean|number}\n   */\n  const matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n    const isList = Array.isArray(args);\n    const _path = isList ? args[0] : args;\n    if (!isList && typeof _path !== 'string') {\n      throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n    }\n    const path = normalizePath(_path, false);\n    for (let index = 0; index < negPatterns.length; index++) {\n      const nglob = negPatterns[index];\n      if (nglob(path)) {\n        return returnIndex ? -1 : false;\n      }\n    }\n    const applied = isList && [path].concat(args.slice(1));\n    for (let index = 0; index < patterns.length; index++) {\n      const pattern = patterns[index];\n      if (isList ? pattern(...applied) : pattern(path)) {\n        return returnIndex ? index : true;\n      }\n    }\n    return returnIndex ? -1 : false;\n  };\n\n  /**\n   * @param {AnymatchMatcher} matchers\n   * @param {Array|string} testString\n   * @param {object} options\n   * @returns {boolean|number|Function}\n   */\n  const anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n    if (matchers == null) {\n      throw new TypeError('anymatch: specify first argument');\n    }\n    const opts = typeof options === 'boolean' ? {\n      returnIndex: options\n    } : options;\n    const returnIndex = opts.returnIndex || false;\n\n    // Early cache for matchers.\n    const mtchers = arrify(matchers);\n    const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch(item, opts));\n    const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG).map(matcher => createPattern(matcher, opts));\n    if (testString == null) {\n      return (testString, ri = false) => {\n        const returnIndex = typeof ri === 'boolean' ? ri : false;\n        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n      };\n    }\n    return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n  };\n  anymatch$1.default = anymatch$1;\n  anymatch.exports = anymatch$1;\n  return anymatch.exports;\n}\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob;\nvar hasRequiredIsExtglob;\nfunction requireIsExtglob() {\n  if (hasRequiredIsExtglob) return isExtglob;\n  hasRequiredIsExtglob = 1;\n  isExtglob = function isExtglob(str) {\n    if (typeof str !== 'string' || str === '') {\n      return false;\n    }\n    var match;\n    while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n      if (match[2]) return true;\n      str = str.slice(match.index + match[0].length);\n    }\n    return false;\n  };\n  return isExtglob;\n}\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isGlob;\nvar hasRequiredIsGlob;\nfunction requireIsGlob() {\n  if (hasRequiredIsGlob) return isGlob;\n  hasRequiredIsGlob = 1;\n  var isExtglob = /*@__PURE__*/requireIsExtglob();\n  var chars = {\n    '{': '}',\n    '(': ')',\n    '[': ']'\n  };\n  var strictCheck = function (str) {\n    if (str[0] === '!') {\n      return true;\n    }\n    var index = 0;\n    var pipeIndex = -2;\n    var closeSquareIndex = -2;\n    var closeCurlyIndex = -2;\n    var closeParenIndex = -2;\n    var backSlashIndex = -2;\n    while (index < str.length) {\n      if (str[index] === '*') {\n        return true;\n      }\n      if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n        return true;\n      }\n      if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n        if (closeSquareIndex < index) {\n          closeSquareIndex = str.indexOf(']', index);\n        }\n        if (closeSquareIndex > index) {\n          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n            return true;\n          }\n          backSlashIndex = str.indexOf('\\\\', index);\n          if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n            return true;\n          }\n        }\n      }\n      if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n        closeCurlyIndex = str.indexOf('}', index);\n        if (closeCurlyIndex > index) {\n          backSlashIndex = str.indexOf('\\\\', index);\n          if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n            return true;\n          }\n        }\n      }\n      if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n        closeParenIndex = str.indexOf(')', index);\n        if (closeParenIndex > index) {\n          backSlashIndex = str.indexOf('\\\\', index);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n      if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n        if (pipeIndex < index) {\n          pipeIndex = str.indexOf('|', index);\n        }\n        if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n          closeParenIndex = str.indexOf(')', pipeIndex);\n          if (closeParenIndex > pipeIndex) {\n            backSlashIndex = str.indexOf('\\\\', pipeIndex);\n            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n              return true;\n            }\n          }\n        }\n      }\n      if (str[index] === '\\\\') {\n        var open = str[index + 1];\n        index += 2;\n        var close = chars[open];\n        if (close) {\n          var n = str.indexOf(close, index);\n          if (n !== -1) {\n            index = n + 1;\n          }\n        }\n        if (str[index] === '!') {\n          return true;\n        }\n      } else {\n        index++;\n      }\n    }\n    return false;\n  };\n  var relaxedCheck = function (str) {\n    if (str[0] === '!') {\n      return true;\n    }\n    var index = 0;\n    while (index < str.length) {\n      if (/[*?{}()[\\]]/.test(str[index])) {\n        return true;\n      }\n      if (str[index] === '\\\\') {\n        var open = str[index + 1];\n        index += 2;\n        var close = chars[open];\n        if (close) {\n          var n = str.indexOf(close, index);\n          if (n !== -1) {\n            index = n + 1;\n          }\n        }\n        if (str[index] === '!') {\n          return true;\n        }\n      } else {\n        index++;\n      }\n    }\n    return false;\n  };\n  isGlob = function isGlob(str, options) {\n    if (typeof str !== 'string' || str === '') {\n      return false;\n    }\n    if (isExtglob(str)) {\n      return true;\n    }\n    var check = strictCheck;\n\n    // optionally relax check\n    if (options && options.strict === false) {\n      check = relaxedCheck;\n    }\n    return check(str);\n  };\n  return isGlob;\n}\nvar globParent;\nvar hasRequiredGlobParent;\nfunction requireGlobParent() {\n  if (hasRequiredGlobParent) return globParent;\n  hasRequiredGlobParent = 1;\n  var isGlob = /*@__PURE__*/requireIsGlob();\n  var pathPosixDirname = require$$0$1.posix.dirname;\n  var isWin32 = require$$2$1.platform() === 'win32';\n  var slash = '/';\n  var backslash = /\\\\/g;\n  var enclosure = /[\\{\\[].*[\\}\\]]$/;\n  var globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\n  var escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n  /**\n   * @param {string} str\n   * @param {Object} opts\n   * @param {boolean} [opts.flipBackslashes=true]\n   * @returns {string}\n   */\n  globParent = function globParent(str, opts) {\n    var options = Object.assign({\n      flipBackslashes: true\n    }, opts);\n\n    // flip windows path separators\n    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n      str = str.replace(backslash, slash);\n    }\n\n    // special case for strings ending in enclosure containing path separator\n    if (enclosure.test(str)) {\n      str += slash;\n    }\n\n    // preserves full path in case of trailing path separator\n    str += 'a';\n\n    // remove path parts that are globby\n    do {\n      str = pathPosixDirname(str);\n    } while (isGlob(str) || globby.test(str));\n\n    // remove escape chars and return result\n    return str.replace(escaped, '$1');\n  };\n  return globParent;\n}\nvar utils = {};\nvar hasRequiredUtils;\nfunction requireUtils() {\n  if (hasRequiredUtils) return utils;\n  hasRequiredUtils = 1;\n  (function (exports) {\n    exports.isInteger = num => {\n      if (typeof num === 'number') {\n        return Number.isInteger(num);\n      }\n      if (typeof num === 'string' && num.trim() !== '') {\n        return Number.isInteger(Number(num));\n      }\n      return false;\n    };\n\n    /**\n     * Find a node of the given type\n     */\n\n    exports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n    /**\n     * Find a node of the given type\n     */\n\n    exports.exceedsLimit = (min, max, step = 1, limit) => {\n      if (limit === false) return false;\n      if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n      return (Number(max) - Number(min)) / Number(step) >= limit;\n    };\n\n    /**\n     * Escape the given node with '\\\\' before node.value\n     */\n\n    exports.escapeNode = (block, n = 0, type) => {\n      const node = block.nodes[n];\n      if (!node) return;\n      if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n        if (node.escaped !== true) {\n          node.value = '\\\\' + node.value;\n          node.escaped = true;\n        }\n      }\n    };\n\n    /**\n     * Returns true if the given brace node should be enclosed in literal braces\n     */\n\n    exports.encloseBrace = node => {\n      if (node.type !== 'brace') return false;\n      if (node.commas >> 0 + node.ranges >> 0 === 0) {\n        node.invalid = true;\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * Returns true if a brace node is invalid.\n     */\n\n    exports.isInvalidBrace = block => {\n      if (block.type !== 'brace') return false;\n      if (block.invalid === true || block.dollar) return true;\n      if (block.commas >> 0 + block.ranges >> 0 === 0) {\n        block.invalid = true;\n        return true;\n      }\n      if (block.open !== true || block.close !== true) {\n        block.invalid = true;\n        return true;\n      }\n      return false;\n    };\n\n    /**\n     * Returns true if a node is an open or close node\n     */\n\n    exports.isOpenOrClose = node => {\n      if (node.type === 'open' || node.type === 'close') {\n        return true;\n      }\n      return node.open === true || node.close === true;\n    };\n\n    /**\n     * Reduce an array of text nodes.\n     */\n\n    exports.reduce = nodes => nodes.reduce((acc, node) => {\n      if (node.type === 'text') acc.push(node.value);\n      if (node.type === 'range') node.type = 'text';\n      return acc;\n    }, []);\n\n    /**\n     * Flatten an array\n     */\n\n    exports.flatten = (...args) => {\n      const result = [];\n      const flat = arr => {\n        for (let i = 0; i < arr.length; i++) {\n          const ele = arr[i];\n          if (Array.isArray(ele)) {\n            flat(ele);\n            continue;\n          }\n          if (ele !== undefined) {\n            result.push(ele);\n          }\n        }\n        return result;\n      };\n      flat(args);\n      return result;\n    };\n  })(utils);\n  return utils;\n}\nvar stringify;\nvar hasRequiredStringify;\nfunction requireStringify() {\n  if (hasRequiredStringify) return stringify;\n  hasRequiredStringify = 1;\n  const utils = /*@__PURE__*/requireUtils();\n  stringify = (ast, options = {}) => {\n    const stringify = (node, parent = {}) => {\n      const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n      const invalidNode = node.invalid === true && options.escapeInvalid === true;\n      let output = '';\n      if (node.value) {\n        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n          return '\\\\' + node.value;\n        }\n        return node.value;\n      }\n      if (node.value) {\n        return node.value;\n      }\n      if (node.nodes) {\n        for (const child of node.nodes) {\n          output += stringify(child);\n        }\n      }\n      return output;\n    };\n    return stringify(ast);\n  };\n  return stringify;\n}\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber;\nvar hasRequiredIsNumber;\nfunction requireIsNumber() {\n  if (hasRequiredIsNumber) return isNumber;\n  hasRequiredIsNumber = 1;\n  isNumber = function (num) {\n    if (typeof num === 'number') {\n      return num - num === 0;\n    }\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n    }\n    return false;\n  };\n  return isNumber;\n}\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar toRegexRange_1;\nvar hasRequiredToRegexRange;\nfunction requireToRegexRange() {\n  if (hasRequiredToRegexRange) return toRegexRange_1;\n  hasRequiredToRegexRange = 1;\n  const isNumber = /*@__PURE__*/requireIsNumber();\n  const toRegexRange = (min, max, options) => {\n    if (isNumber(min) === false) {\n      throw new TypeError('toRegexRange: expected the first argument to be a number');\n    }\n    if (max === void 0 || min === max) {\n      return String(min);\n    }\n    if (isNumber(max) === false) {\n      throw new TypeError('toRegexRange: expected the second argument to be a number.');\n    }\n    let opts = {\n      relaxZeros: true,\n      ...options\n    };\n    if (typeof opts.strictZeros === 'boolean') {\n      opts.relaxZeros = opts.strictZeros === false;\n    }\n    let relax = String(opts.relaxZeros);\n    let shorthand = String(opts.shorthand);\n    let capture = String(opts.capture);\n    let wrap = String(opts.wrap);\n    let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n      return toRegexRange.cache[cacheKey].result;\n    }\n    let a = Math.min(min, max);\n    let b = Math.max(min, max);\n    if (Math.abs(a - b) === 1) {\n      let result = min + '|' + max;\n      if (opts.capture) {\n        return `(${result})`;\n      }\n      if (opts.wrap === false) {\n        return result;\n      }\n      return `(?:${result})`;\n    }\n    let isPadded = hasPadding(min) || hasPadding(max);\n    let state = {\n      min,\n      max,\n      a,\n      b\n    };\n    let positives = [];\n    let negatives = [];\n    if (isPadded) {\n      state.isPadded = isPadded;\n      state.maxLen = String(state.max).length;\n    }\n    if (a < 0) {\n      let newMin = b < 0 ? Math.abs(b) : 1;\n      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n      a = state.a = 0;\n    }\n    if (b >= 0) {\n      positives = splitToPatterns(a, b, state, opts);\n    }\n    state.negatives = negatives;\n    state.positives = positives;\n    state.result = collatePatterns(negatives, positives);\n    if (opts.capture === true) {\n      state.result = `(${state.result})`;\n    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n      state.result = `(?:${state.result})`;\n    }\n    toRegexRange.cache[cacheKey] = state;\n    return state.result;\n  };\n  function collatePatterns(neg, pos, options) {\n    let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n    let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n    let intersected = filterPatterns(neg, pos, '-?', true) || [];\n    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n    return subpatterns.join('|');\n  }\n  function splitToRanges(min, max) {\n    let nines = 1;\n    let zeros = 1;\n    let stop = countNines(min, nines);\n    let stops = new Set([max]);\n    while (min <= stop && stop <= max) {\n      stops.add(stop);\n      nines += 1;\n      stop = countNines(min, nines);\n    }\n    stop = countZeros(max + 1, zeros) - 1;\n    while (min < stop && stop <= max) {\n      stops.add(stop);\n      zeros += 1;\n      stop = countZeros(max + 1, zeros) - 1;\n    }\n    stops = [...stops];\n    stops.sort(compare);\n    return stops;\n  }\n\n  /**\n   * Convert a range to a regex pattern\n   * @param {Number} `start`\n   * @param {Number} `stop`\n   * @return {String}\n   */\n\n  function rangeToPattern(start, stop, options) {\n    if (start === stop) {\n      return {\n        pattern: start,\n        count: [],\n        digits: 0\n      };\n    }\n    let zipped = zip(start, stop);\n    let digits = zipped.length;\n    let pattern = '';\n    let count = 0;\n    for (let i = 0; i < digits; i++) {\n      let [startDigit, stopDigit] = zipped[i];\n      if (startDigit === stopDigit) {\n        pattern += startDigit;\n      } else if (startDigit !== '0' || stopDigit !== '9') {\n        pattern += toCharacterClass(startDigit, stopDigit);\n      } else {\n        count++;\n      }\n    }\n    if (count) {\n      pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n    }\n    return {\n      pattern,\n      count: [count],\n      digits\n    };\n  }\n  function splitToPatterns(min, max, tok, options) {\n    let ranges = splitToRanges(min, max);\n    let tokens = [];\n    let start = min;\n    let prev;\n    for (let i = 0; i < ranges.length; i++) {\n      let max = ranges[i];\n      let obj = rangeToPattern(String(start), String(max), options);\n      let zeros = '';\n      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n        if (prev.count.length > 1) {\n          prev.count.pop();\n        }\n        prev.count.push(obj.count[0]);\n        prev.string = prev.pattern + toQuantifier(prev.count);\n        start = max + 1;\n        continue;\n      }\n      if (tok.isPadded) {\n        zeros = padZeros(max, tok, options);\n      }\n      obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n      tokens.push(obj);\n      start = max + 1;\n      prev = obj;\n    }\n    return tokens;\n  }\n  function filterPatterns(arr, comparison, prefix, intersection, options) {\n    let result = [];\n    for (let ele of arr) {\n      let {\n        string\n      } = ele;\n\n      // only push if _both_ are negative...\n      if (!intersection && !contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n\n      // or _both_ are positive\n      if (intersection && contains(comparison, 'string', string)) {\n        result.push(prefix + string);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Zip strings\n   */\n\n  function zip(a, b) {\n    let arr = [];\n    for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n    return arr;\n  }\n  function compare(a, b) {\n    return a > b ? 1 : b > a ? -1 : 0;\n  }\n  function contains(arr, key, val) {\n    return arr.some(ele => ele[key] === val);\n  }\n  function countNines(min, len) {\n    return Number(String(min).slice(0, -len) + '9'.repeat(len));\n  }\n  function countZeros(integer, zeros) {\n    return integer - integer % Math.pow(10, zeros);\n  }\n  function toQuantifier(digits) {\n    let [start = 0, stop = ''] = digits;\n    if (stop || start > 1) {\n      return `{${start + (stop ? ',' + stop : '')}}`;\n    }\n    return '';\n  }\n  function toCharacterClass(a, b, options) {\n    return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n  }\n  function hasPadding(str) {\n    return /^-?(0+)\\d/.test(str);\n  }\n  function padZeros(value, tok, options) {\n    if (!tok.isPadded) {\n      return value;\n    }\n    let diff = Math.abs(tok.maxLen - String(value).length);\n    let relax = options.relaxZeros !== false;\n    switch (diff) {\n      case 0:\n        return '';\n      case 1:\n        return relax ? '0?' : '0';\n      case 2:\n        return relax ? '0{0,2}' : '00';\n      default:\n        {\n          return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n    }\n  }\n\n  /**\n   * Cache\n   */\n\n  toRegexRange.cache = {};\n  toRegexRange.clearCache = () => toRegexRange.cache = {};\n\n  /**\n   * Expose `toRegexRange`\n   */\n\n  toRegexRange_1 = toRegexRange;\n  return toRegexRange_1;\n}\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar fillRange;\nvar hasRequiredFillRange;\nfunction requireFillRange() {\n  if (hasRequiredFillRange) return fillRange;\n  hasRequiredFillRange = 1;\n  const util = require$$2;\n  const toRegexRange = /*@__PURE__*/requireToRegexRange();\n  const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n  const transform = toNumber => {\n    return value => toNumber === true ? Number(value) : String(value);\n  };\n  const isValidValue = value => {\n    return typeof value === 'number' || typeof value === 'string' && value !== '';\n  };\n  const isNumber = num => Number.isInteger(+num);\n  const zeros = input => {\n    let value = `${input}`;\n    let index = -1;\n    if (value[0] === '-') value = value.slice(1);\n    if (value === '0') return false;\n    while (value[++index] === '0');\n    return index > 0;\n  };\n  const stringify = (start, end, options) => {\n    if (typeof start === 'string' || typeof end === 'string') {\n      return true;\n    }\n    return options.stringify === true;\n  };\n  const pad = (input, maxLength, toNumber) => {\n    if (maxLength > 0) {\n      let dash = input[0] === '-' ? '-' : '';\n      if (dash) input = input.slice(1);\n      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n    }\n    if (toNumber === false) {\n      return String(input);\n    }\n    return input;\n  };\n  const toMaxLen = (input, maxLength) => {\n    let negative = input[0] === '-' ? '-' : '';\n    if (negative) {\n      input = input.slice(1);\n      maxLength--;\n    }\n    while (input.length < maxLength) input = '0' + input;\n    return negative ? '-' + input : input;\n  };\n  const toSequence = (parts, options, maxLen) => {\n    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n    let prefix = options.capture ? '' : '?:';\n    let positives = '';\n    let negatives = '';\n    let result;\n    if (parts.positives.length) {\n      positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n    }\n    if (parts.negatives.length) {\n      negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n    }\n    if (positives && negatives) {\n      result = `${positives}|${negatives}`;\n    } else {\n      result = positives || negatives;\n    }\n    if (options.wrap) {\n      return `(${prefix}${result})`;\n    }\n    return result;\n  };\n  const toRange = (a, b, isNumbers, options) => {\n    if (isNumbers) {\n      return toRegexRange(a, b, {\n        wrap: false,\n        ...options\n      });\n    }\n    let start = String.fromCharCode(a);\n    if (a === b) return start;\n    let stop = String.fromCharCode(b);\n    return `[${start}-${stop}]`;\n  };\n  const toRegex = (start, end, options) => {\n    if (Array.isArray(start)) {\n      let wrap = options.wrap === true;\n      let prefix = options.capture ? '' : '?:';\n      return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n    }\n    return toRegexRange(start, end, options);\n  };\n  const rangeError = (...args) => {\n    return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n  };\n  const invalidRange = (start, end, options) => {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  };\n  const invalidStep = (step, options) => {\n    if (options.strictRanges === true) {\n      throw new TypeError(`Expected step \"${step}\" to be a number`);\n    }\n    return [];\n  };\n  const fillNumbers = (start, end, step = 1, options = {}) => {\n    let a = Number(start);\n    let b = Number(end);\n    if (!Number.isInteger(a) || !Number.isInteger(b)) {\n      if (options.strictRanges === true) throw rangeError([start, end]);\n      return [];\n    }\n\n    // fix negative zero\n    if (a === 0) a = 0;\n    if (b === 0) b = 0;\n    let descending = a > b;\n    let startString = String(start);\n    let endString = String(end);\n    let stepString = String(step);\n    step = Math.max(Math.abs(step), 1);\n    let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n    let toNumber = padded === false && stringify(start, end, options) === false;\n    let format = options.transform || transform(toNumber);\n    if (options.toRegex && step === 1) {\n      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n    }\n    let parts = {\n      negatives: [],\n      positives: []\n    };\n    let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n      if (options.toRegex === true && step > 1) {\n        push(a);\n      } else {\n        range.push(pad(format(a, index), maxLen, toNumber));\n      }\n      a = descending ? a - step : a + step;\n      index++;\n    }\n    if (options.toRegex === true) {\n      return step > 1 ? toSequence(parts, options, maxLen) : toRegex(range, null, {\n        wrap: false,\n        ...options\n      });\n    }\n    return range;\n  };\n  const fillLetters = (start, end, step = 1, options = {}) => {\n    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n      return invalidRange(start, end, options);\n    }\n    let format = options.transform || (val => String.fromCharCode(val));\n    let a = `${start}`.charCodeAt(0);\n    let b = `${end}`.charCodeAt(0);\n    let descending = a > b;\n    let min = Math.min(a, b);\n    let max = Math.max(a, b);\n    if (options.toRegex && step === 1) {\n      return toRange(min, max, false, options);\n    }\n    let range = [];\n    let index = 0;\n    while (descending ? a >= b : a <= b) {\n      range.push(format(a, index));\n      a = descending ? a - step : a + step;\n      index++;\n    }\n    if (options.toRegex === true) {\n      return toRegex(range, null, {\n        wrap: false,\n        options\n      });\n    }\n    return range;\n  };\n  const fill = (start, end, step, options = {}) => {\n    if (end == null && isValidValue(start)) {\n      return [start];\n    }\n    if (!isValidValue(start) || !isValidValue(end)) {\n      return invalidRange(start, end, options);\n    }\n    if (typeof step === 'function') {\n      return fill(start, end, 1, {\n        transform: step\n      });\n    }\n    if (isObject(step)) {\n      return fill(start, end, 0, step);\n    }\n    let opts = {\n      ...options\n    };\n    if (opts.capture === true) opts.wrap = true;\n    step = step || opts.step || 1;\n    if (!isNumber(step)) {\n      if (step != null && !isObject(step)) return invalidStep(step, opts);\n      return fill(start, end, 1, step);\n    }\n    if (isNumber(start) && isNumber(end)) {\n      return fillNumbers(start, end, step, opts);\n    }\n    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n  };\n  fillRange = fill;\n  return fillRange;\n}\nvar compile_1;\nvar hasRequiredCompile;\nfunction requireCompile() {\n  if (hasRequiredCompile) return compile_1;\n  hasRequiredCompile = 1;\n  const fill = /*@__PURE__*/requireFillRange();\n  const utils = /*@__PURE__*/requireUtils();\n  const compile = (ast, options = {}) => {\n    const walk = (node, parent = {}) => {\n      const invalidBlock = utils.isInvalidBrace(parent);\n      const invalidNode = node.invalid === true && options.escapeInvalid === true;\n      const invalid = invalidBlock === true || invalidNode === true;\n      const prefix = options.escapeInvalid === true ? '\\\\' : '';\n      let output = '';\n      if (node.isOpen === true) {\n        return prefix + node.value;\n      }\n      if (node.isClose === true) {\n        console.log('node.isClose', prefix, node.value);\n        return prefix + node.value;\n      }\n      if (node.type === 'open') {\n        return invalid ? prefix + node.value : '(';\n      }\n      if (node.type === 'close') {\n        return invalid ? prefix + node.value : ')';\n      }\n      if (node.type === 'comma') {\n        return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n      }\n      if (node.value) {\n        return node.value;\n      }\n      if (node.nodes && node.ranges > 0) {\n        const args = utils.reduce(node.nodes);\n        const range = fill(...args, {\n          ...options,\n          wrap: false,\n          toRegex: true,\n          strictZeros: true\n        });\n        if (range.length !== 0) {\n          return args.length > 1 && range.length > 1 ? `(${range})` : range;\n        }\n      }\n      if (node.nodes) {\n        for (const child of node.nodes) {\n          output += walk(child, node);\n        }\n      }\n      return output;\n    };\n    return walk(ast);\n  };\n  compile_1 = compile;\n  return compile_1;\n}\nvar expand_1;\nvar hasRequiredExpand;\nfunction requireExpand() {\n  if (hasRequiredExpand) return expand_1;\n  hasRequiredExpand = 1;\n  const fill = /*@__PURE__*/requireFillRange();\n  const stringify = /*@__PURE__*/requireStringify();\n  const utils = /*@__PURE__*/requireUtils();\n  const append = (queue = '', stash = '', enclose = false) => {\n    const result = [];\n    queue = [].concat(queue);\n    stash = [].concat(stash);\n    if (!stash.length) return queue;\n    if (!queue.length) {\n      return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n    }\n    for (const item of queue) {\n      if (Array.isArray(item)) {\n        for (const value of item) {\n          result.push(append(value, stash, enclose));\n        }\n      } else {\n        for (let ele of stash) {\n          if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n        }\n      }\n    }\n    return utils.flatten(result);\n  };\n  const expand = (ast, options = {}) => {\n    const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n    const walk = (node, parent = {}) => {\n      node.queue = [];\n      let p = parent;\n      let q = parent.queue;\n      while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n        p = p.parent;\n        q = p.queue;\n      }\n      if (node.invalid || node.dollar) {\n        q.push(append(q.pop(), stringify(node, options)));\n        return;\n      }\n      if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n        q.push(append(q.pop(), ['{}']));\n        return;\n      }\n      if (node.nodes && node.ranges > 0) {\n        const args = utils.reduce(node.nodes);\n        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n        }\n        let range = fill(...args, options);\n        if (range.length === 0) {\n          range = stringify(node, options);\n        }\n        q.push(append(q.pop(), range));\n        node.nodes = [];\n        return;\n      }\n      const enclose = utils.encloseBrace(node);\n      let queue = node.queue;\n      let block = node;\n      while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n        block = block.parent;\n        queue = block.queue;\n      }\n      for (let i = 0; i < node.nodes.length; i++) {\n        const child = node.nodes[i];\n        if (child.type === 'comma' && node.type === 'brace') {\n          if (i === 1) queue.push('');\n          queue.push('');\n          continue;\n        }\n        if (child.type === 'close') {\n          q.push(append(q.pop(), queue, enclose));\n          continue;\n        }\n        if (child.value && child.type !== 'open') {\n          queue.push(append(queue.pop(), child.value));\n          continue;\n        }\n        if (child.nodes) {\n          walk(child, node);\n        }\n      }\n      return queue;\n    };\n    return utils.flatten(walk(ast));\n  };\n  expand_1 = expand;\n  return expand_1;\n}\nvar constants$1;\nvar hasRequiredConstants$1;\nfunction requireConstants$1() {\n  if (hasRequiredConstants$1) return constants$1;\n  hasRequiredConstants$1 = 1;\n  constants$1 = {\n    MAX_LENGTH: 10000,\n    // Digits\n    CHAR_0: '0',\n    /* 0 */\n    CHAR_9: '9',\n    /* 9 */\n\n    // Alphabet chars.\n    CHAR_UPPERCASE_A: 'A',\n    /* A */\n    CHAR_LOWERCASE_A: 'a',\n    /* a */\n    CHAR_UPPERCASE_Z: 'Z',\n    /* Z */\n    CHAR_LOWERCASE_Z: 'z',\n    /* z */\n\n    CHAR_LEFT_PARENTHESES: '(',\n    /* ( */\n    CHAR_RIGHT_PARENTHESES: ')',\n    /* ) */\n\n    CHAR_ASTERISK: '*',\n    /* * */\n\n    // Non-alphabetic chars.\n    CHAR_AMPERSAND: '&',\n    /* & */\n    CHAR_AT: '@',\n    /* @ */\n    CHAR_BACKSLASH: '\\\\',\n    /* \\ */\n    CHAR_BACKTICK: '`',\n    /* ` */\n    CHAR_CARRIAGE_RETURN: '\\r',\n    /* \\r */\n    CHAR_CIRCUMFLEX_ACCENT: '^',\n    /* ^ */\n    CHAR_COLON: ':',\n    /* : */\n    CHAR_COMMA: ',',\n    /* , */\n    CHAR_DOLLAR: '$',\n    /* . */\n    CHAR_DOT: '.',\n    /* . */\n    CHAR_DOUBLE_QUOTE: '\"',\n    /* \" */\n    CHAR_EQUAL: '=',\n    /* = */\n    CHAR_EXCLAMATION_MARK: '!',\n    /* ! */\n    CHAR_FORM_FEED: '\\f',\n    /* \\f */\n    CHAR_FORWARD_SLASH: '/',\n    /* / */\n    CHAR_HASH: '#',\n    /* # */\n    CHAR_HYPHEN_MINUS: '-',\n    /* - */\n    CHAR_LEFT_ANGLE_BRACKET: '<',\n    /* < */\n    CHAR_LEFT_CURLY_BRACE: '{',\n    /* { */\n    CHAR_LEFT_SQUARE_BRACKET: '[',\n    /* [ */\n    CHAR_LINE_FEED: '\\n',\n    /* \\n */\n    CHAR_NO_BREAK_SPACE: '\\u00A0',\n    /* \\u00A0 */\n    CHAR_PERCENT: '%',\n    /* % */\n    CHAR_PLUS: '+',\n    /* + */\n    CHAR_QUESTION_MARK: '?',\n    /* ? */\n    CHAR_RIGHT_ANGLE_BRACKET: '>',\n    /* > */\n    CHAR_RIGHT_CURLY_BRACE: '}',\n    /* } */\n    CHAR_RIGHT_SQUARE_BRACKET: ']',\n    /* ] */\n    CHAR_SEMICOLON: ';',\n    /* ; */\n    CHAR_SINGLE_QUOTE: '\\'',\n    /* ' */\n    CHAR_SPACE: ' ',\n    /*   */\n    CHAR_TAB: '\\t',\n    /* \\t */\n    CHAR_UNDERSCORE: '_',\n    /* _ */\n    CHAR_VERTICAL_LINE: '|',\n    /* | */\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n  };\n  return constants$1;\n}\nvar parse_1;\nvar hasRequiredParse;\nfunction requireParse() {\n  if (hasRequiredParse) return parse_1;\n  hasRequiredParse = 1;\n  const stringify = /*@__PURE__*/requireStringify();\n\n  /**\n   * Constants\n   */\n\n  const {\n    MAX_LENGTH,\n    CHAR_BACKSLASH,\n    /* \\ */\n    CHAR_BACKTICK,\n    /* ` */\n    CHAR_COMMA,\n    /* , */\n    CHAR_DOT,\n    /* . */\n    CHAR_LEFT_PARENTHESES,\n    /* ( */\n    CHAR_RIGHT_PARENTHESES,\n    /* ) */\n    CHAR_LEFT_CURLY_BRACE,\n    /* { */\n    CHAR_RIGHT_CURLY_BRACE,\n    /* } */\n    CHAR_LEFT_SQUARE_BRACKET,\n    /* [ */\n    CHAR_RIGHT_SQUARE_BRACKET,\n    /* ] */\n    CHAR_DOUBLE_QUOTE,\n    /* \" */\n    CHAR_SINGLE_QUOTE,\n    /* ' */\n    CHAR_NO_BREAK_SPACE,\n    CHAR_ZERO_WIDTH_NOBREAK_SPACE\n  } = /*@__PURE__*/requireConstants$1();\n\n  /**\n   * parse\n   */\n\n  const parse = (input, options = {}) => {\n    if (typeof input !== 'string') {\n      throw new TypeError('Expected a string');\n    }\n    const opts = options || {};\n    const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n    if (input.length > max) {\n      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n    }\n    const ast = {\n      type: 'root',\n      input,\n      nodes: []\n    };\n    const stack = [ast];\n    let block = ast;\n    let prev = ast;\n    let brackets = 0;\n    const length = input.length;\n    let index = 0;\n    let depth = 0;\n    let value;\n\n    /**\n     * Helpers\n     */\n\n    const advance = () => input[index++];\n    const push = node => {\n      if (node.type === 'text' && prev.type === 'dot') {\n        prev.type = 'text';\n      }\n      if (prev && prev.type === 'text' && node.type === 'text') {\n        prev.value += node.value;\n        return;\n      }\n      block.nodes.push(node);\n      node.parent = block;\n      node.prev = prev;\n      prev = node;\n      return node;\n    };\n    push({\n      type: 'bos'\n    });\n    while (index < length) {\n      block = stack[stack.length - 1];\n      value = advance();\n\n      /**\n       * Invalid chars\n       */\n\n      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n        continue;\n      }\n\n      /**\n       * Escaped chars\n       */\n\n      if (value === CHAR_BACKSLASH) {\n        push({\n          type: 'text',\n          value: (options.keepEscaping ? value : '') + advance()\n        });\n        continue;\n      }\n\n      /**\n       * Right square bracket (literal): ']'\n       */\n\n      if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n        push({\n          type: 'text',\n          value: '\\\\' + value\n        });\n        continue;\n      }\n\n      /**\n       * Left square bracket: '['\n       */\n\n      if (value === CHAR_LEFT_SQUARE_BRACKET) {\n        brackets++;\n        let next;\n        while (index < length && (next = advance())) {\n          value += next;\n          if (next === CHAR_LEFT_SQUARE_BRACKET) {\n            brackets++;\n            continue;\n          }\n          if (next === CHAR_BACKSLASH) {\n            value += advance();\n            continue;\n          }\n          if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n            brackets--;\n            if (brackets === 0) {\n              break;\n            }\n          }\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Parentheses\n       */\n\n      if (value === CHAR_LEFT_PARENTHESES) {\n        block = push({\n          type: 'paren',\n          nodes: []\n        });\n        stack.push(block);\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n      if (value === CHAR_RIGHT_PARENTHESES) {\n        if (block.type !== 'paren') {\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n        block = stack.pop();\n        push({\n          type: 'text',\n          value\n        });\n        block = stack[stack.length - 1];\n        continue;\n      }\n\n      /**\n       * Quotes: '|\"|`\n       */\n\n      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n        const open = value;\n        let next;\n        if (options.keepQuotes !== true) {\n          value = '';\n        }\n        while (index < length && (next = advance())) {\n          if (next === CHAR_BACKSLASH) {\n            value += next + advance();\n            continue;\n          }\n          if (next === open) {\n            if (options.keepQuotes === true) value += next;\n            break;\n          }\n          value += next;\n        }\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Left curly brace: '{'\n       */\n\n      if (value === CHAR_LEFT_CURLY_BRACE) {\n        depth++;\n        const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n        const brace = {\n          type: 'brace',\n          open: true,\n          close: false,\n          dollar,\n          depth,\n          commas: 0,\n          ranges: 0,\n          nodes: []\n        };\n        block = push(brace);\n        stack.push(block);\n        push({\n          type: 'open',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Right curly brace: '}'\n       */\n\n      if (value === CHAR_RIGHT_CURLY_BRACE) {\n        if (block.type !== 'brace') {\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n        const type = 'close';\n        block = stack.pop();\n        block.close = true;\n        push({\n          type,\n          value\n        });\n        depth--;\n        block = stack[stack.length - 1];\n        continue;\n      }\n\n      /**\n       * Comma: ','\n       */\n\n      if (value === CHAR_COMMA && depth > 0) {\n        if (block.ranges > 0) {\n          block.ranges = 0;\n          const open = block.nodes.shift();\n          block.nodes = [open, {\n            type: 'text',\n            value: stringify(block)\n          }];\n        }\n        push({\n          type: 'comma',\n          value\n        });\n        block.commas++;\n        continue;\n      }\n\n      /**\n       * Dot: '.'\n       */\n\n      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n        const siblings = block.nodes;\n        if (depth === 0 || siblings.length === 0) {\n          push({\n            type: 'text',\n            value\n          });\n          continue;\n        }\n        if (prev.type === 'dot') {\n          block.range = [];\n          prev.value += value;\n          prev.type = 'range';\n          if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n            block.invalid = true;\n            block.ranges = 0;\n            prev.type = 'text';\n            continue;\n          }\n          block.ranges++;\n          block.args = [];\n          continue;\n        }\n        if (prev.type === 'range') {\n          siblings.pop();\n          const before = siblings[siblings.length - 1];\n          before.value += prev.value + value;\n          prev = before;\n          block.ranges--;\n          continue;\n        }\n        push({\n          type: 'dot',\n          value\n        });\n        continue;\n      }\n\n      /**\n       * Text\n       */\n\n      push({\n        type: 'text',\n        value\n      });\n    }\n\n    // Mark imbalanced braces and brackets as invalid\n    do {\n      block = stack.pop();\n      if (block.type !== 'root') {\n        block.nodes.forEach(node => {\n          if (!node.nodes) {\n            if (node.type === 'open') node.isOpen = true;\n            if (node.type === 'close') node.isClose = true;\n            if (!node.nodes) node.type = 'text';\n            node.invalid = true;\n          }\n        });\n\n        // get the location of the block on parent.nodes (block's siblings)\n        const parent = stack[stack.length - 1];\n        const index = parent.nodes.indexOf(block);\n        // replace the (invalid) block with it's nodes\n        parent.nodes.splice(index, 1, ...block.nodes);\n      }\n    } while (stack.length > 0);\n    push({\n      type: 'eos'\n    });\n    return ast;\n  };\n  parse_1 = parse;\n  return parse_1;\n}\nvar braces_1;\nvar hasRequiredBraces;\nfunction requireBraces() {\n  if (hasRequiredBraces) return braces_1;\n  hasRequiredBraces = 1;\n  const stringify = /*@__PURE__*/requireStringify();\n  const compile = /*@__PURE__*/requireCompile();\n  const expand = /*@__PURE__*/requireExpand();\n  const parse = /*@__PURE__*/requireParse();\n\n  /**\n   * Expand the given pattern or create a regex-compatible string.\n   *\n   * ```js\n   * const braces = require('braces');\n   * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n   * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n   * ```\n   * @param {String} `str`\n   * @param {Object} `options`\n   * @return {String}\n   * @api public\n   */\n\n  const braces = (input, options = {}) => {\n    let output = [];\n    if (Array.isArray(input)) {\n      for (const pattern of input) {\n        const result = braces.create(pattern, options);\n        if (Array.isArray(result)) {\n          output.push(...result);\n        } else {\n          output.push(result);\n        }\n      }\n    } else {\n      output = [].concat(braces.create(input, options));\n    }\n    if (options && options.expand === true && options.nodupes === true) {\n      output = [...new Set(output)];\n    }\n    return output;\n  };\n\n  /**\n   * Parse the given `str` with the given `options`.\n   *\n   * ```js\n   * // braces.parse(pattern, [, options]);\n   * const ast = braces.parse('a/{b,c}/d');\n   * console.log(ast);\n   * ```\n   * @param {String} pattern Brace pattern to parse\n   * @param {Object} options\n   * @return {Object} Returns an AST\n   * @api public\n   */\n\n  braces.parse = (input, options = {}) => parse(input, options);\n\n  /**\n   * Creates a braces string from an AST, or an AST node.\n   *\n   * ```js\n   * const braces = require('braces');\n   * let ast = braces.parse('foo/{a,b}/bar');\n   * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n   * ```\n   * @param {String} `input` Brace pattern or AST.\n   * @param {Object} `options`\n   * @return {Array} Returns an array of expanded values.\n   * @api public\n   */\n\n  braces.stringify = (input, options = {}) => {\n    if (typeof input === 'string') {\n      return stringify(braces.parse(input, options), options);\n    }\n    return stringify(input, options);\n  };\n\n  /**\n   * Compiles a brace pattern into a regex-compatible, optimized string.\n   * This method is called by the main [braces](#braces) function by default.\n   *\n   * ```js\n   * const braces = require('braces');\n   * console.log(braces.compile('a/{b,c}/d'));\n   * //=> ['a/(b|c)/d']\n   * ```\n   * @param {String} `input` Brace pattern or AST.\n   * @param {Object} `options`\n   * @return {Array} Returns an array of expanded values.\n   * @api public\n   */\n\n  braces.compile = (input, options = {}) => {\n    if (typeof input === 'string') {\n      input = braces.parse(input, options);\n    }\n    return compile(input, options);\n  };\n\n  /**\n   * Expands a brace pattern into an array. This method is called by the\n   * main [braces](#braces) function when `options.expand` is true. Before\n   * using this method it's recommended that you read the [performance notes](#performance))\n   * and advantages of using [.compile](#compile) instead.\n   *\n   * ```js\n   * const braces = require('braces');\n   * console.log(braces.expand('a/{b,c}/d'));\n   * //=> ['a/b/d', 'a/c/d'];\n   * ```\n   * @param {String} `pattern` Brace pattern\n   * @param {Object} `options`\n   * @return {Array} Returns an array of expanded values.\n   * @api public\n   */\n\n  braces.expand = (input, options = {}) => {\n    if (typeof input === 'string') {\n      input = braces.parse(input, options);\n    }\n    let result = expand(input, options);\n\n    // filter out empty strings if specified\n    if (options.noempty === true) {\n      result = result.filter(Boolean);\n    }\n\n    // filter out duplicates if specified\n    if (options.nodupes === true) {\n      result = [...new Set(result)];\n    }\n    return result;\n  };\n\n  /**\n   * Processes a brace pattern and returns either an expanded array\n   * (if `options.expand` is true), a highly optimized regex-compatible string.\n   * This method is called by the main [braces](#braces) function.\n   *\n   * ```js\n   * const braces = require('braces');\n   * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n   * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n   * ```\n   * @param {String} `pattern` Brace pattern\n   * @param {Object} `options`\n   * @return {Array} Returns an array of expanded values.\n   * @api public\n   */\n\n  braces.create = (input, options = {}) => {\n    if (input === '' || input.length < 3) {\n      return [input];\n    }\n    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n  };\n\n  /**\n   * Expose \"braces\"\n   */\n\n  braces_1 = braces;\n  return braces_1;\n}\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"afdesign\", \"afphoto\", \"afpub\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\nvar binaryExtensions;\nvar hasRequiredBinaryExtensions;\nfunction requireBinaryExtensions() {\n  if (hasRequiredBinaryExtensions) return binaryExtensions;\n  hasRequiredBinaryExtensions = 1;\n  binaryExtensions = require$$0;\n  return binaryExtensions;\n}\nvar isBinaryPath;\nvar hasRequiredIsBinaryPath;\nfunction requireIsBinaryPath() {\n  if (hasRequiredIsBinaryPath) return isBinaryPath;\n  hasRequiredIsBinaryPath = 1;\n  const path = require$$0$1;\n  const binaryExtensions = /*@__PURE__*/requireBinaryExtensions();\n  const extensions = new Set(binaryExtensions);\n  isBinaryPath = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n  return isBinaryPath;\n}\nvar constants = {};\nvar hasRequiredConstants;\nfunction requireConstants() {\n  if (hasRequiredConstants) return constants;\n  hasRequiredConstants = 1;\n  (function (exports) {\n    const {\n      sep\n    } = require$$0$1;\n    const {\n      platform\n    } = process;\n    const os = require$$2$1;\n    exports.EV_ALL = 'all';\n    exports.EV_READY = 'ready';\n    exports.EV_ADD = 'add';\n    exports.EV_CHANGE = 'change';\n    exports.EV_ADD_DIR = 'addDir';\n    exports.EV_UNLINK = 'unlink';\n    exports.EV_UNLINK_DIR = 'unlinkDir';\n    exports.EV_RAW = 'raw';\n    exports.EV_ERROR = 'error';\n    exports.STR_DATA = 'data';\n    exports.STR_END = 'end';\n    exports.STR_CLOSE = 'close';\n    exports.FSEVENT_CREATED = 'created';\n    exports.FSEVENT_MODIFIED = 'modified';\n    exports.FSEVENT_DELETED = 'deleted';\n    exports.FSEVENT_MOVED = 'moved';\n    exports.FSEVENT_CLONED = 'cloned';\n    exports.FSEVENT_UNKNOWN = 'unknown';\n    exports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;\n    exports.FSEVENT_TYPE_FILE = 'file';\n    exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n    exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n    exports.KEY_LISTENERS = 'listeners';\n    exports.KEY_ERR = 'errHandlers';\n    exports.KEY_RAW = 'rawEmitters';\n    exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n    exports.DOT_SLASH = `.${sep}`;\n    exports.BACK_SLASH_RE = /\\\\/g;\n    exports.DOUBLE_SLASH_RE = /\\/\\//;\n    exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n    exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n    exports.REPLACER_RE = /^\\.[/\\\\]/;\n    exports.SLASH = '/';\n    exports.SLASH_SLASH = '//';\n    exports.BRACE_START = '{';\n    exports.BANG = '!';\n    exports.ONE_DOT = '.';\n    exports.TWO_DOTS = '..';\n    exports.STAR = '*';\n    exports.GLOBSTAR = '**';\n    exports.ROOT_GLOBSTAR = '/**/*';\n    exports.SLASH_GLOBSTAR = '/**';\n    exports.DIR_SUFFIX = 'Dir';\n    exports.ANYMATCH_OPTS = {\n      dot: true\n    };\n    exports.STRING_TYPE = 'string';\n    exports.FUNCTION_TYPE = 'function';\n    exports.EMPTY_STR = '';\n    exports.EMPTY_FN = () => {};\n    exports.IDENTITY_FN = val => val;\n    exports.isWindows = platform === 'win32';\n    exports.isMacos = platform === 'darwin';\n    exports.isLinux = platform === 'linux';\n    exports.isIBMi = os.type() === 'OS400';\n  })(constants);\n  return constants;\n}\nvar nodefsHandler;\nvar hasRequiredNodefsHandler;\nfunction requireNodefsHandler() {\n  if (hasRequiredNodefsHandler) return nodefsHandler;\n  hasRequiredNodefsHandler = 1;\n  const fs = require$$0$2;\n  const sysPath = require$$0$1;\n  const {\n    promisify\n  } = require$$2;\n  const isBinaryPath = /*@__PURE__*/requireIsBinaryPath();\n  const {\n    isWindows,\n    isLinux,\n    EMPTY_FN,\n    EMPTY_STR,\n    KEY_LISTENERS,\n    KEY_ERR,\n    KEY_RAW,\n    HANDLER_KEYS,\n    EV_CHANGE,\n    EV_ADD,\n    EV_ADD_DIR,\n    EV_ERROR,\n    STR_DATA,\n    STR_END,\n    BRACE_START,\n    STAR\n  } = /*@__PURE__*/requireConstants();\n  const THROTTLE_MODE_WATCH = 'watch';\n  const open = promisify(fs.open);\n  const stat = promisify(fs.stat);\n  const lstat = promisify(fs.lstat);\n  const close = promisify(fs.close);\n  const fsrealpath = promisify(fs.realpath);\n  const statMethods = {\n    lstat,\n    stat\n  };\n\n  // TODO: emit errors properly. Example: EMFILE on Macos.\n  const foreach = (val, fn) => {\n    if (val instanceof Set) {\n      val.forEach(fn);\n    } else {\n      fn(val);\n    }\n  };\n  const addAndConvert = (main, prop, item) => {\n    let container = main[prop];\n    if (!(container instanceof Set)) {\n      main[prop] = container = new Set([container]);\n    }\n    container.add(item);\n  };\n  const clearItem = cont => key => {\n    const set = cont[key];\n    if (set instanceof Set) {\n      set.clear();\n    } else {\n      delete cont[key];\n    }\n  };\n  const delFromSet = (main, prop, item) => {\n    const container = main[prop];\n    if (container instanceof Set) {\n      container.delete(item);\n    } else if (container === item) {\n      delete main[prop];\n    }\n  };\n  const isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n\n  /**\n   * @typedef {String} Path\n   */\n\n  // fs_watch helpers\n\n  // object to hold per-process fs_watch instances\n  // (may be shared across chokidar FSWatcher instances)\n\n  /**\n   * @typedef {Object} FsWatchContainer\n   * @property {Set} listeners\n   * @property {Set} errHandlers\n   * @property {Set} rawEmitters\n   * @property {fs.FSWatcher=} watcher\n   * @property {Boolean=} watcherUnusable\n   */\n\n  /**\n   * @type {Map<String,FsWatchContainer>}\n   */\n  const FsWatchInstances = new Map();\n\n  /**\n   * Instantiates the fs_watch interface\n   * @param {String} path to be watched\n   * @param {Object} options to be passed to fs_watch\n   * @param {Function} listener main event handler\n   * @param {Function} errHandler emits info about errors\n   * @param {Function} emitRaw emits raw event data\n   * @returns {fs.FSWatcher} new fsevents instance\n   */\n  function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n    const handleEvent = (rawEvent, evPath) => {\n      listener(path);\n      emitRaw(rawEvent, evPath, {\n        watchedPath: path\n      });\n\n      // emit based on events occurring for files from a directory's watcher in\n      // case the file's watcher misses it (and rely on throttling to de-dupe)\n      if (evPath && path !== evPath) {\n        fsWatchBroadcast(sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath));\n      }\n    };\n    try {\n      return fs.watch(path, options, handleEvent);\n    } catch (error) {\n      errHandler(error);\n    }\n  }\n\n  /**\n   * Helper for passing fs_watch event data to a collection of listeners\n   * @param {Path} fullPath absolute path bound to fs_watch instance\n   * @param {String} type listener type\n   * @param {*=} val1 arguments to be passed to listeners\n   * @param {*=} val2\n   * @param {*=} val3\n   */\n  const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n    const cont = FsWatchInstances.get(fullPath);\n    if (!cont) return;\n    foreach(cont[type], listener => {\n      listener(val1, val2, val3);\n    });\n  };\n\n  /**\n   * Instantiates the fs_watch interface or binds listeners\n   * to an existing one covering the same file system entry\n   * @param {String} path\n   * @param {String} fullPath absolute path\n   * @param {Object} options to be passed to fs_watch\n   * @param {Object} handlers container for event listener functions\n   */\n  const setFsWatchListener = (path, fullPath, options, handlers) => {\n    const {\n      listener,\n      errHandler,\n      rawEmitter\n    } = handlers;\n    let cont = FsWatchInstances.get(fullPath);\n\n    /** @type {fs.FSWatcher=} */\n    let watcher;\n    if (!options.persistent) {\n      watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n      return watcher.close.bind(watcher);\n    }\n    if (cont) {\n      addAndConvert(cont, KEY_LISTENERS, listener);\n      addAndConvert(cont, KEY_ERR, errHandler);\n      addAndConvert(cont, KEY_RAW, rawEmitter);\n    } else {\n      watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler,\n      // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n      if (!watcher) return;\n      watcher.on(EV_ERROR, async error => {\n        const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n        cont.watcherUnusable = true; // documented since Node 10.4.1\n        // Workaround for https://github.com/joyent/node/issues/4337\n        if (isWindows && error.code === 'EPERM') {\n          try {\n            const fd = await open(path, 'r');\n            await close(fd);\n            broadcastErr(error);\n          } catch (err) {}\n        } else {\n          broadcastErr(error);\n        }\n      });\n      cont = {\n        listeners: listener,\n        errHandlers: errHandler,\n        rawEmitters: rawEmitter,\n        watcher\n      };\n      FsWatchInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n\n    // removes this instance's listeners and closes the underlying fs_watch\n    // instance if there are no more listeners left\n    return () => {\n      delFromSet(cont, KEY_LISTENERS, listener);\n      delFromSet(cont, KEY_ERR, errHandler);\n      delFromSet(cont, KEY_RAW, rawEmitter);\n      if (isEmptySet(cont.listeners)) {\n        // Check to protect against issue gh-730.\n        // if (cont.watcherUnusable) {\n        cont.watcher.close();\n        // }\n        FsWatchInstances.delete(fullPath);\n        HANDLER_KEYS.forEach(clearItem(cont));\n        cont.watcher = undefined;\n        Object.freeze(cont);\n      }\n    };\n  };\n\n  // fs_watchFile helpers\n\n  // object to hold per-process fs_watchFile instances\n  // (may be shared across chokidar FSWatcher instances)\n  const FsWatchFileInstances = new Map();\n\n  /**\n   * Instantiates the fs_watchFile interface or binds listeners\n   * to an existing one covering the same file system entry\n   * @param {String} path to be watched\n   * @param {String} fullPath absolute path\n   * @param {Object} options options to be passed to fs_watchFile\n   * @param {Object} handlers container for event listener functions\n   * @returns {Function} closer\n   */\n  const setFsWatchFileListener = (path, fullPath, options, handlers) => {\n    const {\n      listener,\n      rawEmitter\n    } = handlers;\n    let cont = FsWatchFileInstances.get(fullPath);\n    const copts = cont && cont.options;\n    if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n      fs.unwatchFile(fullPath);\n      cont = undefined;\n    }\n\n    /* eslint-enable no-unused-vars, prefer-destructuring */\n\n    if (cont) {\n      addAndConvert(cont, KEY_LISTENERS, listener);\n      addAndConvert(cont, KEY_RAW, rawEmitter);\n    } else {\n      // TODO\n      // listeners.add(listener);\n      // rawEmitters.add(rawEmitter);\n      cont = {\n        listeners: listener,\n        rawEmitters: rawEmitter,\n        options,\n        watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n          foreach(cont.rawEmitters, rawEmitter => {\n            rawEmitter(EV_CHANGE, fullPath, {\n              curr,\n              prev\n            });\n          });\n          const currmtime = curr.mtimeMs;\n          if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n            foreach(cont.listeners, listener => listener(path, curr));\n          }\n        })\n      };\n      FsWatchFileInstances.set(fullPath, cont);\n    }\n    // const index = cont.listeners.indexOf(listener);\n\n    // Removes this instance's listeners and closes the underlying fs_watchFile\n    // instance if there are no more listeners left.\n    return () => {\n      delFromSet(cont, KEY_LISTENERS, listener);\n      delFromSet(cont, KEY_RAW, rawEmitter);\n      if (isEmptySet(cont.listeners)) {\n        FsWatchFileInstances.delete(fullPath);\n        fs.unwatchFile(fullPath);\n        cont.options = cont.watcher = undefined;\n        Object.freeze(cont);\n      }\n    };\n  };\n\n  /**\n   * @mixin\n   */\n  class NodeFsHandler {\n    /**\n     * @param {import(\"../index\").FSWatcher} fsW\n     */\n    constructor(fsW) {\n      this.fsw = fsW;\n      this._boundHandleError = error => fsW._handleError(error);\n    }\n\n    /**\n     * Watch file for changes with fs_watchFile or fs_watch.\n     * @param {String} path to file or dir\n     * @param {Function} listener on fs change\n     * @returns {Function} closer for the watcher instance\n     */\n    _watchWithNodeFs(path, listener) {\n      const opts = this.fsw.options;\n      const directory = sysPath.dirname(path);\n      const basename = sysPath.basename(path);\n      const parent = this.fsw._getWatchedDir(directory);\n      parent.add(basename);\n      const absolutePath = sysPath.resolve(path);\n      const options = {\n        persistent: opts.persistent\n      };\n      if (!listener) listener = EMPTY_FN;\n      let closer;\n      if (opts.usePolling) {\n        options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n        closer = setFsWatchFileListener(path, absolutePath, options, {\n          listener,\n          rawEmitter: this.fsw._emitRaw\n        });\n      } else {\n        closer = setFsWatchListener(path, absolutePath, options, {\n          listener,\n          errHandler: this._boundHandleError,\n          rawEmitter: this.fsw._emitRaw\n        });\n      }\n      return closer;\n    }\n\n    /**\n     * Watch a file and emit add event if warranted.\n     * @param {Path} file Path\n     * @param {fs.Stats} stats result of fs_stat\n     * @param {Boolean} initialAdd was the file added at watch instantiation?\n     * @returns {Function} closer for the watcher instance\n     */\n    _handleFile(file, stats, initialAdd) {\n      if (this.fsw.closed) {\n        return;\n      }\n      const dirname = sysPath.dirname(file);\n      const basename = sysPath.basename(file);\n      const parent = this.fsw._getWatchedDir(dirname);\n      // stats is always present\n      let prevStats = stats;\n\n      // if the file is already being watched, do nothing\n      if (parent.has(basename)) return;\n      const listener = async (path, newStats) => {\n        if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n        if (!newStats || newStats.mtimeMs === 0) {\n          try {\n            const newStats = await stat(file);\n            if (this.fsw.closed) return;\n            // Check that change event was not fired because of changed only accessTime.\n            const at = newStats.atimeMs;\n            const mt = newStats.mtimeMs;\n            if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n              this.fsw._emit(EV_CHANGE, file, newStats);\n            }\n            if (isLinux && prevStats.ino !== newStats.ino) {\n              this.fsw._closeFile(path);\n              prevStats = newStats;\n              this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n            } else {\n              prevStats = newStats;\n            }\n          } catch (error) {\n            // Fix issues where mtime is null but file is still present\n            this.fsw._remove(dirname, basename);\n          }\n          // add is about to be emitted if file not already tracked in parent\n        } else if (parent.has(basename)) {\n          // Check that change event was not fired because of changed only accessTime.\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE, file, newStats);\n          }\n          prevStats = newStats;\n        }\n      };\n      // kick off the watcher\n      const closer = this._watchWithNodeFs(file, listener);\n\n      // emit an add event if we're supposed to\n      if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n        if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n        this.fsw._emit(EV_ADD, file, stats);\n      }\n      return closer;\n    }\n\n    /**\n     * Handle symlinks encountered while reading a dir.\n     * @param {Object} entry returned by readdirp\n     * @param {String} directory path of dir being read\n     * @param {String} path of this item\n     * @param {String} item basename of this item\n     * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n     */\n    async _handleSymlink(entry, directory, path, item) {\n      if (this.fsw.closed) {\n        return;\n      }\n      const full = entry.fullPath;\n      const dir = this.fsw._getWatchedDir(directory);\n      if (!this.fsw.options.followSymlinks) {\n        // watch symlink directly (don't follow) and detect changes\n        this.fsw._incrReadyCount();\n        let linkPath;\n        try {\n          linkPath = await fsrealpath(path);\n        } catch (e) {\n          this.fsw._emitReady();\n          return true;\n        }\n        if (this.fsw.closed) return;\n        if (dir.has(item)) {\n          if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n            this.fsw._symlinkPaths.set(full, linkPath);\n            this.fsw._emit(EV_CHANGE, path, entry.stats);\n          }\n        } else {\n          dir.add(item);\n          this.fsw._symlinkPaths.set(full, linkPath);\n          this.fsw._emit(EV_ADD, path, entry.stats);\n        }\n        this.fsw._emitReady();\n        return true;\n      }\n\n      // don't follow the same symlink more than once\n      if (this.fsw._symlinkPaths.has(full)) {\n        return true;\n      }\n      this.fsw._symlinkPaths.set(full, true);\n    }\n    _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n      // Normalize the directory name on Windows\n      directory = sysPath.join(directory, EMPTY_STR);\n      if (!wh.hasGlob) {\n        throttler = this.fsw._throttle('readdir', directory, 1000);\n        if (!throttler) return;\n      }\n      const previous = this.fsw._getWatchedDir(wh.path);\n      const current = new Set();\n      let stream = this.fsw._readdirp(directory, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        depth: 0\n      }).on(STR_DATA, async entry => {\n        if (this.fsw.closed) {\n          stream = undefined;\n          return;\n        }\n        const item = entry.path;\n        let path = sysPath.join(directory, item);\n        current.add(item);\n        if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n          return;\n        }\n        if (this.fsw.closed) {\n          stream = undefined;\n          return;\n        }\n        // Files that present in current directory snapshot\n        // but absent in previous are added to watch list and\n        // emit `add` event.\n        if (item === target || !target && !previous.has(item)) {\n          this.fsw._incrReadyCount();\n\n          // ensure relativeness of path is preserved in case of watcher reuse\n          path = sysPath.join(dir, sysPath.relative(dir, path));\n          this._addToNodeFs(path, initialAdd, wh, depth + 1);\n        }\n      }).on(EV_ERROR, this._boundHandleError);\n      return new Promise(resolve => stream.once(STR_END, () => {\n        if (this.fsw.closed) {\n          stream = undefined;\n          return;\n        }\n        const wasThrottled = throttler ? throttler.clear() : false;\n        resolve();\n\n        // Files that absent in current directory snapshot\n        // but present in previous emit `remove` event\n        // and are removed from @watched[directory].\n        previous.getChildren().filter(item => {\n          return item !== directory && !current.has(item) && (\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          !wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n        }).forEach(item => {\n          this.fsw._remove(directory, item);\n        });\n        stream = undefined;\n\n        // one more time for any missed in case changes came in extremely quickly\n        if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n      }));\n    }\n\n    /**\n     * Read directory to add / remove files from `@watched` list and re-read it on change.\n     * @param {String} dir fs path\n     * @param {fs.Stats} stats\n     * @param {Boolean} initialAdd\n     * @param {Number} depth relative to user-supplied path\n     * @param {String} target child path targeted for watch\n     * @param {Object} wh Common watch helpers for this path\n     * @param {String} realpath\n     * @returns {Promise<Function>} closer for the watcher instance.\n     */\n    async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n      const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n      const tracked = parentDir.has(sysPath.basename(dir));\n      if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n        if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n      }\n\n      // ensure dir is tracked (harmless if redundant)\n      parentDir.add(sysPath.basename(dir));\n      this.fsw._getWatchedDir(dir);\n      let throttler;\n      let closer;\n      const oDepth = this.fsw.options.depth;\n      if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n        if (!target) {\n          await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n          if (this.fsw.closed) return;\n        }\n        closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n          // if current directory is removed, do nothing\n          if (stats && stats.mtimeMs === 0) return;\n          this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n        });\n      }\n      return closer;\n    }\n\n    /**\n     * Handle added file, directory, or glob pattern.\n     * Delegates call to _handleFile / _handleDir after checks.\n     * @param {String} path to file or ir\n     * @param {Boolean} initialAdd was the file added at watch instantiation?\n     * @param {Object} priorWh depth relative to user-supplied path\n     * @param {Number} depth Child path actually targeted for watch\n     * @param {String=} target Child path actually targeted for watch\n     * @returns {Promise}\n     */\n    async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n      const ready = this.fsw._emitReady;\n      if (this.fsw._isIgnored(path) || this.fsw.closed) {\n        ready();\n        return false;\n      }\n      const wh = this.fsw._getWatchHelpers(path, depth);\n      if (!wh.hasGlob && priorWh) {\n        wh.hasGlob = priorWh.hasGlob;\n        wh.globFilter = priorWh.globFilter;\n        wh.filterPath = entry => priorWh.filterPath(entry);\n        wh.filterDir = entry => priorWh.filterDir(entry);\n      }\n\n      // evaluate what is at the path we're being asked to watch\n      try {\n        const stats = await statMethods[wh.statMethod](wh.watchPath);\n        if (this.fsw.closed) return;\n        if (this.fsw._isIgnored(wh.watchPath, stats)) {\n          ready();\n          return false;\n        }\n        const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n        let closer;\n        if (stats.isDirectory()) {\n          const absPath = sysPath.resolve(path);\n          const targetPath = follow ? await fsrealpath(path) : path;\n          if (this.fsw.closed) return;\n          closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n          if (this.fsw.closed) return;\n          // preserve this symlink's target path\n          if (absPath !== targetPath && targetPath !== undefined) {\n            this.fsw._symlinkPaths.set(absPath, targetPath);\n          }\n        } else if (stats.isSymbolicLink()) {\n          const targetPath = follow ? await fsrealpath(path) : path;\n          if (this.fsw.closed) return;\n          const parent = sysPath.dirname(wh.watchPath);\n          this.fsw._getWatchedDir(parent).add(wh.watchPath);\n          this.fsw._emit(EV_ADD, wh.watchPath, stats);\n          closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n          if (this.fsw.closed) return;\n\n          // preserve this symlink's target path\n          if (targetPath !== undefined) {\n            this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n          }\n        } else {\n          closer = this._handleFile(wh.watchPath, stats, initialAdd);\n        }\n        ready();\n        this.fsw._addPathCloser(path, closer);\n        return false;\n      } catch (error) {\n        if (this.fsw._handleError(error)) {\n          ready();\n          return path;\n        }\n      }\n    }\n  }\n  nodefsHandler = NodeFsHandler;\n  return nodefsHandler;\n}\nvar fseventsHandler = {\n  exports: {}\n};\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\nvar hasRequiredFseventsHandler;\nfunction requireFseventsHandler() {\n  if (hasRequiredFseventsHandler) return fseventsHandler.exports;\n  hasRequiredFseventsHandler = 1;\n  const fs = require$$0$2;\n  const sysPath = require$$0$1;\n  const {\n    promisify\n  } = require$$2;\n  let fsevents;\n  try {\n    fsevents = require$$3.getFsEvents();\n  } catch (error) {\n    if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n  }\n  if (fsevents) {\n    // TODO: real check\n    const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n    if (mtch && mtch[1] && mtch[2]) {\n      const maj = Number.parseInt(mtch[1], 10);\n      const min = Number.parseInt(mtch[2], 10);\n      if (maj === 8 && min < 16) {\n        fsevents = undefined;\n      }\n    }\n  }\n  const {\n    EV_ADD,\n    EV_CHANGE,\n    EV_ADD_DIR,\n    EV_UNLINK,\n    EV_ERROR,\n    STR_DATA,\n    STR_END,\n    FSEVENT_CREATED,\n    FSEVENT_MODIFIED,\n    FSEVENT_DELETED,\n    FSEVENT_MOVED,\n    // FSEVENT_CLONED,\n    FSEVENT_UNKNOWN,\n    FSEVENT_FLAG_MUST_SCAN_SUBDIRS,\n    FSEVENT_TYPE_FILE,\n    FSEVENT_TYPE_DIRECTORY,\n    FSEVENT_TYPE_SYMLINK,\n    ROOT_GLOBSTAR,\n    DIR_SUFFIX,\n    DOT_SLASH,\n    FUNCTION_TYPE,\n    EMPTY_FN,\n    IDENTITY_FN\n  } = /*@__PURE__*/requireConstants();\n  const Depth = value => isNaN(value) ? {} : {\n    depth: value\n  };\n  const stat = promisify(fs.stat);\n  const lstat = promisify(fs.lstat);\n  const realpath = promisify(fs.realpath);\n  const statMethods = {\n    stat,\n    lstat\n  };\n\n  /**\n   * @typedef {String} Path\n   */\n\n  /**\n   * @typedef {Object} FsEventsWatchContainer\n   * @property {Set<Function>} listeners\n   * @property {Function} rawEmitter\n   * @property {{stop: Function}} watcher\n   */\n\n  // fsevents instance helper functions\n  /**\n   * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n   * @type {Map<Path,FsEventsWatchContainer>}\n   */\n  const FSEventsWatchers = new Map();\n\n  // Threshold of duplicate path prefixes at which to start\n  // consolidating going forward\n  const consolidateThreshhold = 10;\n  const wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n\n  /**\n   * Instantiates the fsevents interface\n   * @param {Path} path path to be watched\n   * @param {Function} callback called when fsevents is bound and ready\n   * @returns {{stop: Function}} new fsevents instance\n   */\n  const createFSEventsInstance = (path, callback) => {\n    const stop = fsevents.watch(path, callback);\n    return {\n      stop\n    };\n  };\n\n  /**\n   * Instantiates the fsevents interface or binds listeners to an existing one covering\n   * the same file tree.\n   * @param {Path} path           - to be watched\n   * @param {Path} realPath       - real path for symlinks\n   * @param {Function} listener   - called when fsevents emits events\n   * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n   * @returns {Function} closer\n   */\n  function setFSEventsListener(path, realPath, listener, rawEmitter) {\n    let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n    const parentPath = sysPath.dirname(watchPath);\n    let cont = FSEventsWatchers.get(watchPath);\n\n    // If we've accumulated a substantial number of paths that\n    // could have been consolidated by watching one directory\n    // above the current one, create a watcher on the parent\n    // path instead, so that we do consolidate going forward.\n    if (couldConsolidate(parentPath)) {\n      watchPath = parentPath;\n    }\n    const resolvedPath = sysPath.resolve(path);\n    const hasSymlink = resolvedPath !== realPath;\n    const filteredListener = (fullPath, flags, info) => {\n      if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n      if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n    };\n\n    // check if there is already a watcher on a parent path\n    // modifies `watchPath` to the parent path when it finds a match\n    let watchedParent = false;\n    for (const watchedPath of FSEventsWatchers.keys()) {\n      if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n        watchPath = watchedPath;\n        cont = FSEventsWatchers.get(watchPath);\n        watchedParent = true;\n        break;\n      }\n    }\n    if (cont || watchedParent) {\n      cont.listeners.add(filteredListener);\n    } else {\n      cont = {\n        listeners: new Set([filteredListener]),\n        rawEmitter,\n        watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n          if (!cont.listeners.size) return;\n          if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;\n          const info = fsevents.getInfo(fullPath, flags);\n          cont.listeners.forEach(list => {\n            list(fullPath, flags, info);\n          });\n          cont.rawEmitter(info.event, fullPath, info);\n        })\n      };\n      FSEventsWatchers.set(watchPath, cont);\n    }\n\n    // removes this instance's listeners and closes the underlying fsevents\n    // instance if there are no more listeners left\n    return () => {\n      const lst = cont.listeners;\n      lst.delete(filteredListener);\n      if (!lst.size) {\n        FSEventsWatchers.delete(watchPath);\n        if (cont.watcher) return cont.watcher.stop().then(() => {\n          cont.rawEmitter = cont.watcher = undefined;\n          Object.freeze(cont);\n        });\n      }\n    };\n  }\n\n  // Decide whether or not we should start a new higher-level\n  // parent watcher\n  const couldConsolidate = path => {\n    let count = 0;\n    for (const watchPath of FSEventsWatchers.keys()) {\n      if (watchPath.indexOf(path) === 0) {\n        count++;\n        if (count >= consolidateThreshhold) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n\n  // returns boolean indicating whether fsevents can be used\n  const canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n  // determines subdirectory traversal levels from root to path\n  const calcDepth = (path, root) => {\n    let i = 0;\n    while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n    return i;\n  };\n\n  // returns boolean indicating whether the fsevents' event info has the same type\n  // as the one returned by fs.stat\n  const sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n\n  /**\n   * @mixin\n   */\n  class FsEventsHandler {\n    /**\n     * @param {import('../index').FSWatcher} fsw\n     */\n    constructor(fsw) {\n      this.fsw = fsw;\n    }\n    checkIgnored(path, stats) {\n      const ipaths = this.fsw._ignoredPaths;\n      if (this.fsw._isIgnored(path, stats)) {\n        ipaths.add(path);\n        if (stats && stats.isDirectory()) {\n          ipaths.add(path + ROOT_GLOBSTAR);\n        }\n        return true;\n      }\n      ipaths.delete(path);\n      ipaths.delete(path + ROOT_GLOBSTAR);\n    }\n    addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n      this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n    async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      try {\n        const stats = await stat(path);\n        if (this.fsw.closed) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } catch (error) {\n        if (error.code === 'EACCES') {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    }\n    handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n      if (this.fsw.closed || this.checkIgnored(path)) return;\n      if (event === EV_UNLINK) {\n        const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n        // suppress unlink events on never before seen files\n        if (isDirectory || watchedDir.has(item)) {\n          this.fsw._remove(parent, item, isDirectory);\n        }\n      } else {\n        if (event === EV_ADD) {\n          // track new directories\n          if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n          if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          }\n\n          // track new paths\n          // (other than symlinks being followed, which will be tracked soon)\n          this.fsw._getWatchedDir(parent).add(item);\n        }\n        /**\n         * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n         */\n        const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n        this.fsw._emit(eventName, path);\n        if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n      }\n    }\n\n    /**\n     * Handle symlinks encountered during directory scan\n     * @param {String} watchPath  - file/dir path to be watched with fsevents\n     * @param {String} realPath   - real path (in case of symlinks)\n     * @param {Function} transform  - path transformer\n     * @param {Function} globFilter - path filter in case a glob pattern was provided\n     * @returns {Function} closer for the watcher instance\n    */\n    _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n      if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n      const opts = this.fsw.options;\n      const watchCallback = async (fullPath, flags, info) => {\n        if (this.fsw.closed) return;\n        if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n        const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n        if (globFilter && !globFilter(path)) return;\n        // ensure directories are tracked\n        const parent = sysPath.dirname(path);\n        const item = sysPath.basename(path);\n        const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent);\n\n        // correct for wrong events emitted\n        if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n          if (typeof opts.ignored === FUNCTION_TYPE) {\n            let stats;\n            try {\n              stats = await stat(path);\n            } catch (error) {}\n            if (this.fsw.closed) return;\n            if (this.checkIgnored(path, stats)) return;\n            if (sameTypes(info, stats)) {\n              this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n            } else {\n              this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n            }\n          } else {\n            this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          switch (info.event) {\n            case FSEVENT_CREATED:\n            case FSEVENT_MODIFIED:\n              return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n            case FSEVENT_DELETED:\n            case FSEVENT_MOVED:\n              return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        }\n      };\n      const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n      this.fsw._emitReady();\n      return closer;\n    }\n\n    /**\n     * Handle symlinks encountered during directory scan\n     * @param {String} linkPath path to symlink\n     * @param {String} fullPath absolute path to the symlink\n     * @param {Function} transform pre-existing path transformer\n     * @param {Number} curDepth level of subdirectories traversed to where symlink is\n     * @returns {Promise<void>}\n     */\n    async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n      // don't follow the same symlink more than once\n      if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n      this.fsw._symlinkPaths.set(fullPath, true);\n      this.fsw._incrReadyCount();\n      try {\n        const linkTarget = await realpath(linkPath);\n        if (this.fsw.closed) return;\n        if (this.fsw._isIgnored(linkTarget)) {\n          return this.fsw._emitReady();\n        }\n        this.fsw._incrReadyCount();\n\n        // add the linkTarget for watching with a wrapper for transform\n        // that causes emitted paths to incorporate the link's path\n        this._addToFsEvents(linkTarget || linkPath, path => {\n          let aliasedPath = linkPath;\n          if (linkTarget && linkTarget !== DOT_SLASH) {\n            aliasedPath = path.replace(linkTarget, linkPath);\n          } else if (path !== DOT_SLASH) {\n            aliasedPath = sysPath.join(linkPath, path);\n          }\n          return transform(aliasedPath);\n        }, false, curDepth);\n      } catch (error) {\n        if (this.fsw._handleError(error)) {\n          return this.fsw._emitReady();\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {Path} newPath\n     * @param {fs.Stats} stats\n     */\n    emitAdd(newPath, stats, processPath, opts, forceAdd) {\n      const pp = processPath(newPath);\n      const isDir = stats.isDirectory();\n      const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n      const base = sysPath.basename(pp);\n\n      // ensure empty dirs get tracked\n      if (isDir) this.fsw._getWatchedDir(pp);\n      if (dirObj.has(base)) return;\n      dirObj.add(base);\n      if (!opts.ignoreInitial || forceAdd === true) {\n        this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n      }\n    }\n    initWatch(realPath, path, wh, processPath) {\n      if (this.fsw.closed) return;\n      const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n      this.fsw._addPathCloser(path, closer);\n    }\n\n    /**\n     * Handle added path with fsevents\n     * @param {String} path file/dir path or glob pattern\n     * @param {Function|Boolean=} transform converts working path to what the user expects\n     * @param {Boolean=} forceAdd ensure add is emitted\n     * @param {Number=} priorDepth Level of subdirectories already traversed.\n     * @returns {Promise<void>}\n     */\n    async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n      if (this.fsw.closed) {\n        return;\n      }\n      const opts = this.fsw.options;\n      const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n      const wh = this.fsw._getWatchHelpers(path);\n\n      // evaluate what is at the path we're being asked to watch\n      try {\n        const stats = await statMethods[wh.statMethod](wh.watchPath);\n        if (this.fsw.closed) return;\n        if (this.fsw._isIgnored(wh.watchPath, stats)) {\n          throw null;\n        }\n        if (stats.isDirectory()) {\n          // emit addDir unless this is a glob parent\n          if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n          // don't recurse further if it would exceed depth setting\n          if (priorDepth && priorDepth > opts.depth) return;\n\n          // scan the contents of the dir\n          this.fsw._readdirp(wh.watchPath, {\n            fileFilter: entry => wh.filterPath(entry),\n            directoryFilter: entry => wh.filterDir(entry),\n            ...Depth(opts.depth - (priorDepth || 0))\n          }).on(STR_DATA, entry => {\n            // need to check filterPath on dirs b/c filterDir is less restrictive\n            if (this.fsw.closed) {\n              return;\n            }\n            if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n            const joinedPath = sysPath.join(wh.watchPath, entry.path);\n            const {\n              fullPath\n            } = entry;\n            if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n              // preserve the current depth here since it can't be derived from\n              // real paths past the symlink\n              const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n              this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n            } else {\n              this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n            }\n          }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n            this.fsw._emitReady();\n          });\n        } else {\n          this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n          this.fsw._emitReady();\n        }\n      } catch (error) {\n        if (!error || this.fsw._handleError(error)) {\n          // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n          this.fsw._emitReady();\n          this.fsw._emitReady();\n        }\n      }\n      if (opts.persistent && forceAdd !== true) {\n        if (typeof transform === FUNCTION_TYPE) {\n          // realpath has already been resolved\n          this.initWatch(undefined, path, wh, processPath);\n        } else {\n          let realPath;\n          try {\n            realPath = await realpath(wh.watchPath);\n          } catch (e) {}\n          this.initWatch(realPath, path, wh, processPath);\n        }\n      }\n    }\n  }\n  fseventsHandler.exports = FsEventsHandler;\n  fseventsHandler.exports.canUse = canUse;\n  return fseventsHandler.exports;\n}\nvar hasRequiredChokidar;\nfunction requireChokidar() {\n  if (hasRequiredChokidar) return chokidar$1;\n  hasRequiredChokidar = 1;\n  const {\n    EventEmitter\n  } = require$$0$3;\n  const fs = require$$0$2;\n  const sysPath = require$$0$1;\n  const {\n    promisify\n  } = require$$2;\n  const readdirp = /*@__PURE__*/requireReaddirp();\n  const anymatch = /*@__PURE__*/requireAnymatch().default;\n  const globParent = /*@__PURE__*/requireGlobParent();\n  const isGlob = /*@__PURE__*/requireIsGlob();\n  const braces = /*@__PURE__*/requireBraces();\n  const normalizePath = /*@__PURE__*/requireNormalizePath();\n  const NodeFsHandler = /*@__PURE__*/requireNodefsHandler();\n  const FsEventsHandler = /*@__PURE__*/requireFseventsHandler();\n  const {\n    EV_ALL,\n    EV_READY,\n    EV_ADD,\n    EV_CHANGE,\n    EV_UNLINK,\n    EV_ADD_DIR,\n    EV_UNLINK_DIR,\n    EV_RAW,\n    EV_ERROR,\n    STR_CLOSE,\n    STR_END,\n    BACK_SLASH_RE,\n    DOUBLE_SLASH_RE,\n    SLASH_OR_BACK_SLASH_RE,\n    DOT_RE,\n    REPLACER_RE,\n    SLASH,\n    SLASH_SLASH,\n    BRACE_START,\n    BANG,\n    ONE_DOT,\n    TWO_DOTS,\n    GLOBSTAR,\n    SLASH_GLOBSTAR,\n    ANYMATCH_OPTS,\n    STRING_TYPE,\n    FUNCTION_TYPE,\n    EMPTY_STR,\n    EMPTY_FN,\n    isWindows,\n    isMacos,\n    isIBMi\n  } = /*@__PURE__*/requireConstants();\n  const stat = promisify(fs.stat);\n  const readdir = promisify(fs.readdir);\n\n  /**\n   * @typedef {String} Path\n   * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n   * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n   */\n\n  /**\n   *\n   * @typedef {Object} WatchHelpers\n   * @property {Boolean} followSymlinks\n   * @property {'stat'|'lstat'} statMethod\n   * @property {Path} path\n   * @property {Path} watchPath\n   * @property {Function} entryPath\n   * @property {Boolean} hasGlob\n   * @property {Object} globFilter\n   * @property {Function} filterPath\n   * @property {Function} filterDir\n   */\n\n  const arrify = (value = []) => Array.isArray(value) ? value : [value];\n  const flatten = (list, result = []) => {\n    list.forEach(item => {\n      if (Array.isArray(item)) {\n        flatten(item, result);\n      } else {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  const unifyPaths = paths_ => {\n    /**\n     * @type {Array<String>}\n     */\n    const paths = flatten(arrify(paths_));\n    if (!paths.every(p => typeof p === STRING_TYPE)) {\n      throw new TypeError(`Non-string provided as watch path: ${paths}`);\n    }\n    return paths.map(normalizePathToUnix);\n  };\n\n  // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n  //     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n  const toUnix = string => {\n    let str = string.replace(BACK_SLASH_RE, SLASH);\n    let prepend = false;\n    if (str.startsWith(SLASH_SLASH)) {\n      prepend = true;\n    }\n    while (str.match(DOUBLE_SLASH_RE)) {\n      str = str.replace(DOUBLE_SLASH_RE, SLASH);\n    }\n    if (prepend) {\n      str = SLASH + str;\n    }\n    return str;\n  };\n\n  // Our version of upath.normalize\n  // TODO: this is not equal to path-normalize module - investigate why\n  const normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\n  const normalizeIgnored = (cwd = EMPTY_STR) => path => {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n  const getAbsolutePath = (path, cwd) => {\n    if (sysPath.isAbsolute(path)) {\n      return path;\n    }\n    if (path.startsWith(BANG)) {\n      return BANG + sysPath.join(cwd, path.slice(1));\n    }\n    return sysPath.join(cwd, path);\n  };\n  const undef = (opts, key) => opts[key] === undefined;\n\n  /**\n   * Directory entry.\n   * @property {Path} path\n   * @property {Set<Path>} items\n   */\n  class DirEntry {\n    /**\n     * @param {Path} dir\n     * @param {Function} removeWatcher\n     */\n    constructor(dir, removeWatcher) {\n      this.path = dir;\n      this._removeWatcher = removeWatcher;\n      /** @type {Set<Path>} */\n      this.items = new Set();\n    }\n    add(item) {\n      const {\n        items\n      } = this;\n      if (!items) return;\n      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n    }\n    async remove(item) {\n      const {\n        items\n      } = this;\n      if (!items) return;\n      items.delete(item);\n      if (items.size > 0) return;\n      const dir = this.path;\n      try {\n        await readdir(dir);\n      } catch (err) {\n        if (this._removeWatcher) {\n          this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n        }\n      }\n    }\n    has(item) {\n      const {\n        items\n      } = this;\n      if (!items) return;\n      return items.has(item);\n    }\n\n    /**\n     * @returns {Array<String>}\n     */\n    getChildren() {\n      const {\n        items\n      } = this;\n      if (!items) return;\n      return [...items.values()];\n    }\n    dispose() {\n      this.items.clear();\n      delete this.path;\n      delete this._removeWatcher;\n      delete this.items;\n      Object.freeze(this);\n    }\n  }\n  const STAT_METHOD_F = 'stat';\n  const STAT_METHOD_L = 'lstat';\n  class WatchHelper {\n    constructor(path, watchPath, follow, fsw) {\n      this.fsw = fsw;\n      this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n      this.watchPath = watchPath;\n      this.fullWatchPath = sysPath.resolve(watchPath);\n      this.hasGlob = watchPath !== path;\n      /** @type {object|boolean} */\n      if (path === EMPTY_STR) this.hasGlob = false;\n      this.globSymlink = this.hasGlob && follow ? undefined : false;\n      this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n      this.dirParts = this.getDirParts(path);\n      this.dirParts.forEach(parts => {\n        if (parts.length > 1) parts.pop();\n      });\n      this.followSymlinks = follow;\n      this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n    }\n    checkGlobSymlink(entry) {\n      // only need to resolve once\n      // first entry should always have entry.parentDir === EMPTY_STR\n      if (this.globSymlink === undefined) {\n        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n          realPath: entry.fullParentDir,\n          linkPath: this.fullWatchPath\n        };\n      }\n      if (this.globSymlink) {\n        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n      }\n      return entry.fullPath;\n    }\n    entryPath(entry) {\n      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n    }\n    filterPath(entry) {\n      const {\n        stats\n      } = entry;\n      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n      const resolvedPath = this.entryPath(entry);\n      const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n    getDirParts(path) {\n      if (!this.hasGlob) return [];\n      const parts = [];\n      const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n      expandedPath.forEach(path => {\n        parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n      });\n      return parts;\n    }\n    filterDir(entry) {\n      if (this.hasGlob) {\n        const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n        let globstar = false;\n        this.unmatchedGlob = !this.dirParts.some(parts => {\n          return parts.every((part, i) => {\n            if (part === GLOBSTAR) globstar = true;\n            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n          });\n        });\n      }\n      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n  }\n\n  /**\n   * Watches files & directories for changes. Emitted events:\n   * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n   *\n   *     new FSWatcher()\n   *       .add(directories)\n   *       .on('add', path => log('File', path, 'was added'))\n   */\n  class FSWatcher extends EventEmitter {\n    // Not indenting methods for history sake; for now.\n    constructor(_opts) {\n      super();\n      const opts = {};\n      if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n      /** @type {Map<String, DirEntry>} */\n      this._watched = new Map();\n      /** @type {Map<String, Array>} */\n      this._closers = new Map();\n      /** @type {Set<String>} */\n      this._ignoredPaths = new Set();\n\n      /** @type {Map<ThrottleType, Map>} */\n      this._throttled = new Map();\n\n      /** @type {Map<Path, String|Boolean>} */\n      this._symlinkPaths = new Map();\n      this._streams = new Set();\n      this.closed = false;\n\n      // Set up default options.\n      if (undef(opts, 'persistent')) opts.persistent = true;\n      if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n      if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n      if (undef(opts, 'interval')) opts.interval = 100;\n      if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n      if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n      opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n      // Enable fsevents on OS X when polling isn't explicitly enabled.\n      if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n      // If we can't use fsevents, ensure the options reflect it's disabled.\n      const canUseFsEvents = FsEventsHandler.canUse();\n      if (!canUseFsEvents) opts.useFsEvents = false;\n\n      // Use polling on Mac if not using fsevents.\n      // Other platforms use non-polling fs_watch.\n      if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n        opts.usePolling = isMacos;\n      }\n\n      // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n      if (isIBMi) {\n        opts.usePolling = true;\n      }\n\n      // Global override (useful for end-developers that need to force polling for all\n      // instances of chokidar, regardless of usage/dependency depth)\n      const envPoll = process.env.CHOKIDAR_USEPOLLING;\n      if (envPoll !== undefined) {\n        const envLower = envPoll.toLowerCase();\n        if (envLower === 'false' || envLower === '0') {\n          opts.usePolling = false;\n        } else if (envLower === 'true' || envLower === '1') {\n          opts.usePolling = true;\n        } else {\n          opts.usePolling = !!envLower;\n        }\n      }\n      const envInterval = process.env.CHOKIDAR_INTERVAL;\n      if (envInterval) {\n        opts.interval = Number.parseInt(envInterval, 10);\n      }\n\n      // Editor atomic write normalization enabled by default with fs.watch\n      if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n      if (opts.atomic) this._pendingUnlinks = new Map();\n      if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n      if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n      if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n      const awf = opts.awaitWriteFinish;\n      if (awf) {\n        if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n        if (!awf.pollInterval) awf.pollInterval = 100;\n        this._pendingWrites = new Map();\n      }\n      if (opts.ignored) opts.ignored = arrify(opts.ignored);\n      let readyCalls = 0;\n      this._emitReady = () => {\n        readyCalls++;\n        if (readyCalls >= this._readyCount) {\n          this._emitReady = EMPTY_FN;\n          this._readyEmitted = true;\n          // use process.nextTick to allow time for listener to be bound\n          process.nextTick(() => this.emit(EV_READY));\n        }\n      };\n      this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n      this._readyEmitted = false;\n      this.options = opts;\n\n      // Initialize with proper watcher.\n      if (opts.useFsEvents) {\n        this._fsEventsHandler = new FsEventsHandler(this);\n      } else {\n        this._nodeFsHandler = new NodeFsHandler(this);\n      }\n\n      // You’re frozen when your heart’s not open.\n      Object.freeze(opts);\n    }\n\n    // Public methods\n\n    /**\n     * Adds paths to be watched on an existing FSWatcher instance\n     * @param {Path|Array<Path>} paths_\n     * @param {String=} _origAdd private; for handling non-existent paths to be watched\n     * @param {Boolean=} _internal private; indicates a non-user add\n     * @returns {FSWatcher} for chaining\n     */\n    add(paths_, _origAdd, _internal) {\n      const {\n        cwd,\n        disableGlobbing\n      } = this.options;\n      this.closed = false;\n      let paths = unifyPaths(paths_);\n      if (cwd) {\n        paths = paths.map(path => {\n          const absPath = getAbsolutePath(path, cwd);\n\n          // Check `path` instead of `absPath` because the cwd portion can't be a glob\n          if (disableGlobbing || !isGlob(path)) {\n            return absPath;\n          }\n          return normalizePath(absPath);\n        });\n      }\n\n      // set aside negated glob strings\n      paths = paths.filter(path => {\n        if (path.startsWith(BANG)) {\n          this._ignoredPaths.add(path.slice(1));\n          return false;\n        }\n\n        // if a path is being added that was previously ignored, stop ignoring it\n        this._ignoredPaths.delete(path);\n        this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n        // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n        this._userIgnored = undefined;\n        return true;\n      });\n      if (this.options.useFsEvents && this._fsEventsHandler) {\n        if (!this._readyCount) this._readyCount = paths.length;\n        if (this.options.persistent) this._readyCount += paths.length;\n        paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n      } else {\n        if (!this._readyCount) this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map(async path => {\n          const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n          if (res) this._emitReady();\n          return res;\n        })).then(results => {\n          if (this.closed) return;\n          results.filter(item => item).forEach(item => {\n            this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n          });\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n     * @returns {FSWatcher} for chaining\n    */\n    unwatch(paths_) {\n      if (this.closed) return this;\n      const paths = unifyPaths(paths_);\n      const {\n        cwd\n      } = this.options;\n      paths.forEach(path => {\n        // convert to absolute path unless relative path already matches\n        if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n          if (cwd) path = sysPath.join(cwd, path);\n          path = sysPath.resolve(path);\n        }\n        this._closePath(path);\n        this._ignoredPaths.add(path);\n        if (this._watched.has(path)) {\n          this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n        }\n\n        // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n        this._userIgnored = undefined;\n      });\n      return this;\n    }\n\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     * @returns {Promise<void>}.\n    */\n    close() {\n      if (this.closed) return this._closePromise;\n      this.closed = true;\n\n      // Memory management.\n      this.removeAllListeners();\n      const closers = [];\n      this._closers.forEach(closerList => closerList.forEach(closer => {\n        const promise = closer();\n        if (promise instanceof Promise) closers.push(promise);\n      }));\n      this._streams.forEach(stream => stream.destroy());\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n      this._watched.forEach(dirent => dirent.dispose());\n      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n        this[`_${key}`].clear();\n      });\n      this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n      return this._closePromise;\n    }\n\n    /**\n     * Expose list of watched paths\n     * @returns {Object} for chaining\n    */\n    getWatched() {\n      const watchList = {};\n      this._watched.forEach((entry, dir) => {\n        const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n        watchList[key || ONE_DOT] = entry.getChildren().sort();\n      });\n      return watchList;\n    }\n    emitWithAll(event, args) {\n      this.emit(...args);\n      if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n    }\n\n    // Common helpers\n    // --------------\n\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param {EventName} event Type of event\n     * @param {Path} path File or directory path\n     * @param {*=} val1 arguments to be passed with event\n     * @param {*=} val2\n     * @param {*=} val3\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    async _emit(event, path, val1, val2, val3) {\n      if (this.closed) return;\n      const opts = this.options;\n      if (isWindows) path = sysPath.normalize(path);\n      if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n      /** @type Array<any> */\n      const args = [event, path];\n      if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n      const awf = opts.awaitWriteFinish;\n      let pw;\n      if (awf && (pw = this._pendingWrites.get(path))) {\n        pw.lastChange = new Date();\n        return this;\n      }\n      if (opts.atomic) {\n        if (event === EV_UNLINK) {\n          this._pendingUnlinks.set(path, args);\n          setTimeout(() => {\n            this._pendingUnlinks.forEach((entry, path) => {\n              this.emit(...entry);\n              this.emit(EV_ALL, ...entry);\n              this._pendingUnlinks.delete(path);\n            });\n          }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n          return this;\n        }\n        if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n          event = args[0] = EV_CHANGE;\n          this._pendingUnlinks.delete(path);\n        }\n      }\n      if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n        const awfEmit = (err, stats) => {\n          if (err) {\n            event = args[0] = EV_ERROR;\n            args[1] = err;\n            this.emitWithAll(event, args);\n          } else if (stats) {\n            // if stats doesn't exist the file must have been deleted\n            if (args.length > 2) {\n              args[2] = stats;\n            } else {\n              args.push(stats);\n            }\n            this.emitWithAll(event, args);\n          }\n        };\n        this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n        return this;\n      }\n      if (event === EV_CHANGE) {\n        const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n        if (isThrottled) return this;\n      }\n      if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n        const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n        let stats;\n        try {\n          stats = await stat(fullPath);\n        } catch (err) {}\n        // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n        if (!stats || this.closed) return;\n        args.push(stats);\n      }\n      this.emitWithAll(event, args);\n      return this;\n    }\n\n    /**\n     * Common handler for errors\n     * @param {Error} error\n     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n    _handleError(error) {\n      const code = error && error.code;\n      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n        this.emit(EV_ERROR, error);\n      }\n      return error || this.closed;\n    }\n\n    /**\n     * Helper utility for throttling\n     * @param {ThrottleType} actionType type being throttled\n     * @param {Path} path being acted upon\n     * @param {Number} timeout duration of time to suppress duplicate actions\n     * @returns {Object|false} tracking object or false if action should be suppressed\n     */\n    _throttle(actionType, path, timeout) {\n      if (!this._throttled.has(actionType)) {\n        this._throttled.set(actionType, new Map());\n      }\n\n      /** @type {Map<Path, Object>} */\n      const action = this._throttled.get(actionType);\n      /** @type {Object} */\n      const actionPath = action.get(path);\n      if (actionPath) {\n        actionPath.count++;\n        return false;\n      }\n      let timeoutObject;\n      const clear = () => {\n        const item = action.get(path);\n        const count = item ? item.count : 0;\n        action.delete(path);\n        clearTimeout(timeoutObject);\n        if (item) clearTimeout(item.timeoutObject);\n        return count;\n      };\n      timeoutObject = setTimeout(clear, timeout);\n      const thr = {\n        timeoutObject,\n        clear,\n        count: 0\n      };\n      action.set(path, thr);\n      return thr;\n    }\n    _incrReadyCount() {\n      return this._readyCount++;\n    }\n\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param {Path} path being acted upon\n     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param {EventName} event\n     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n     */\n    _awaitWriteFinish(path, threshold, event, awfEmit) {\n      let timeoutHandler;\n      let fullPath = path;\n      if (this.options.cwd && !sysPath.isAbsolute(path)) {\n        fullPath = sysPath.join(this.options.cwd, path);\n      }\n      const now = new Date();\n      const awaitWriteFinish = prevStat => {\n        fs.stat(fullPath, (err, curStat) => {\n          if (err || !this._pendingWrites.has(path)) {\n            if (err && err.code !== 'ENOENT') awfEmit(err);\n            return;\n          }\n          const now = Number(new Date());\n          if (prevStat && curStat.size !== prevStat.size) {\n            this._pendingWrites.get(path).lastChange = now;\n          }\n          const pw = this._pendingWrites.get(path);\n          const df = now - pw.lastChange;\n          if (df >= threshold) {\n            this._pendingWrites.delete(path);\n            awfEmit(undefined, curStat);\n          } else {\n            timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n          }\n        });\n      };\n      if (!this._pendingWrites.has(path)) {\n        this._pendingWrites.set(path, {\n          lastChange: now,\n          cancelWait: () => {\n            this._pendingWrites.delete(path);\n            clearTimeout(timeoutHandler);\n            return event;\n          }\n        });\n        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n      }\n    }\n    _getGlobIgnored() {\n      return [...this._ignoredPaths.values()];\n    }\n\n    /**\n     * Determines whether user has asked to ignore this path.\n     * @param {Path} path filepath or dir\n     * @param {fs.Stats=} stats result of fs.stat\n     * @returns {Boolean}\n     */\n    _isIgnored(path, stats) {\n      if (this.options.atomic && DOT_RE.test(path)) return true;\n      if (!this._userIgnored) {\n        const {\n          cwd\n        } = this.options;\n        const ign = this.options.ignored;\n        const ignored = ign && ign.map(normalizeIgnored(cwd));\n        const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n        const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n      }\n      return this._userIgnored([path, stats]);\n    }\n    _isntIgnored(path, stat) {\n      return !this._isIgnored(path, stat);\n    }\n\n    /**\n     * Provides a set of common helpers and properties relating to symlink and glob handling.\n     * @param {Path} path file, directory, or glob pattern being watched\n     * @param {Number=} depth at any depth > 0, this isn't a glob\n     * @returns {WatchHelper} object containing helpers for this path\n     */\n    _getWatchHelpers(path, depth) {\n      const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n      const follow = this.options.followSymlinks;\n      return new WatchHelper(path, watchPath, follow, this);\n    }\n\n    // Directory helpers\n    // -----------------\n\n    /**\n     * Provides directory tracking objects\n     * @param {String} directory path of the directory\n     * @returns {DirEntry} the directory's tracking object\n     */\n    _getWatchedDir(directory) {\n      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n      const dir = sysPath.resolve(directory);\n      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n      return this._watched.get(dir);\n    }\n\n    // File helpers\n    // ------------\n\n    /**\n     * Check for read permissions.\n     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n     * @param {fs.Stats} stats - object, result of fs_stat\n     * @returns {Boolean} indicates whether the file can be read\n    */\n    _hasReadPermissions(stats) {\n      if (this.options.ignorePermissionErrors) return true;\n\n      // stats.mode may be bigint\n      const md = stats && Number.parseInt(stats.mode, 10);\n      const st = md & 0o777;\n      const it = Number.parseInt(st.toString(8)[0], 10);\n      return Boolean(4 & it);\n    }\n\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param {String} directory within which the following item is located\n     * @param {String} item      base path of item/directory\n     * @returns {void}\n    */\n    _remove(directory, item, isDirectory) {\n      // if what is being deleted is a directory, get that directory's paths\n      // for recursive deleting and cleaning of watched object\n      // if it is not a directory, nestedDirectoryChildren will be empty array\n      const path = sysPath.join(directory, item);\n      const fullPath = sysPath.resolve(path);\n      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);\n\n      // prevent duplicate handling in case of arriving here nearly simultaneously\n      // via multiple paths (such as _handleFile and _handleDir)\n      if (!this._throttle('remove', path, 100)) return;\n\n      // if the only watched file is removed, watch for its return\n      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n        this.add(directory, item, true);\n      }\n\n      // This will create a new entry in the watched object in either case\n      // so we got to do the directory check beforehand\n      const wp = this._getWatchedDir(path);\n      const nestedDirectoryChildren = wp.getChildren();\n\n      // Recursively remove children directories / files.\n      nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n      // Check if item was on the watched list and remove it\n      const parent = this._getWatchedDir(directory);\n      const wasTracked = parent.has(item);\n      parent.remove(item);\n\n      // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n      // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n      // but never removed from the map in case the path was deleted.\n      // This leads to an incorrect state if the path was recreated:\n      // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n      if (this._symlinkPaths.has(fullPath)) {\n        this._symlinkPaths.delete(fullPath);\n      }\n\n      // If we wait for this file to be fully written, cancel the wait.\n      let relPath = path;\n      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n        const event = this._pendingWrites.get(relPath).cancelWait();\n        if (event === EV_ADD) return;\n      }\n\n      // The Entry will either be a directory that just got removed\n      // or a bogus entry to a file, in either case we have to remove it\n      this._watched.delete(path);\n      this._watched.delete(fullPath);\n      const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n      // Avoid conflicts if we later create another file with the same name\n      if (!this.options.useFsEvents) {\n        this._closePath(path);\n      }\n    }\n\n    /**\n     * Closes all watchers for a path\n     * @param {Path} path\n     */\n    _closePath(path) {\n      this._closeFile(path);\n      const dir = sysPath.dirname(path);\n      this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n\n    /**\n     * Closes only file-specific watchers\n     * @param {Path} path\n     */\n    _closeFile(path) {\n      const closers = this._closers.get(path);\n      if (!closers) return;\n      closers.forEach(closer => closer());\n      this._closers.delete(path);\n    }\n\n    /**\n     *\n     * @param {Path} path\n     * @param {Function} closer\n     */\n    _addPathCloser(path, closer) {\n      if (!closer) return;\n      let list = this._closers.get(path);\n      if (!list) {\n        list = [];\n        this._closers.set(path, list);\n      }\n      list.push(closer);\n    }\n    _readdirp(root, opts) {\n      if (this.closed) return;\n      const options = {\n        type: EV_ALL,\n        alwaysStat: true,\n        lstat: true,\n        ...opts\n      };\n      let stream = readdirp(root, options);\n      this._streams.add(stream);\n      stream.once(STR_CLOSE, () => {\n        stream = undefined;\n      });\n      stream.once(STR_END, () => {\n        if (stream) {\n          this._streams.delete(stream);\n          stream = undefined;\n        }\n      });\n      return stream;\n    }\n  }\n\n  // Export FSWatcher class\n  chokidar$1.FSWatcher = FSWatcher;\n\n  /**\n   * Instantiates watcher with paths to be tracked.\n   * @param {String|Array<String>} paths file/directory paths and/or globs\n   * @param {Object=} options chokidar opts\n   * @returns an instance of FSWatcher for chaining.\n   */\n  const watch = (paths, options) => {\n    const watcher = new FSWatcher(options);\n    watcher.add(paths);\n    return watcher;\n  };\n  chokidar$1.watch = watch;\n  return chokidar$1;\n}\nvar chokidarExports = /*@__PURE__*/requireChokidar();\nconst chokidar = /*@__PURE__*/getDefaultExportFromCjs(chokidarExports);\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n  close() {\n    this.watcher.close();\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n  watch(id, isTransformDependency) {\n    if (isTransformDependency) {\n      const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = platform() === 'linux';\n    const isFreeBSD = platform() === 'freebsd';\n    const isTransformDependency = transformWatcherId !== null;\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n      if (isLinux || isFreeBSD) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n    const watcher = chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n}\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    //delete file from map\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\nclass Watcher {\n  constructor(optionsList, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.closed = false;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = optionsList.map(options => new Task(this, options));\n    for (const {\n      watch\n    } of optionsList) {\n      if (watch && typeof watch.buildDelay === 'number') {\n        this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n      }\n    }\n    process$1.nextTick(() => this.run());\n  }\n  async close() {\n    if (this.closed) return;\n    this.closed = true;\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    for (const task of this.tasks) {\n      task.close();\n    }\n    await this.emitter.emit('close');\n    this.emitter.removeAllListeners();\n  }\n  invalidate(file) {\n    if (file) {\n      const previousEvent = this.invalidatedIds.get(file.id);\n      const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n      try {\n        await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, {\n          event\n        })));\n        this.invalidatedIds.clear();\n        await this.emitter.emit('restart');\n        this.emitter.removeListenersForCurrentRun();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        await this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        await this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n  async run() {\n    this.running = true;\n    await this.emitter.emit('event', {\n      code: 'START'\n    });\n    for (const task of this.tasks) {\n      await task.run();\n    }\n    this.running = false;\n    await this.emitter.emit('event', {\n      code: 'END'\n    });\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n}\nclass Task {\n  constructor(watcher, options) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.options = options;\n    this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return path.resolve(output.file || output.dir);\n      return undefined;\n    });\n    this.watchOptions = this.options.watch || {};\n    this.filter = createFilter(this.watchOptions.include, this.watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, {\n      ...this.watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n  invalidate(id, details) {\n    this.invalidated = true;\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue;\n        // effective invalidation\n        module.originalCode = null;\n      }\n    }\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n    this.watchOptions.onInvalidate?.(id);\n  }\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = {\n      ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    await this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n    try {\n      result = await rollupInternal(options, this.watcher.emitter);\n      if (this.closed) {\n        return;\n      }\n      this.updateWatchedFiles(result);\n      if (!this.skipWrite) {\n        await Promise.all(this.outputs.map(output => result.write(output)));\n        if (this.closed) {\n          return;\n        }\n        this.updateWatchedFiles(result);\n      }\n      await this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n      await this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n  watchFile(id, isTransformDependency = false) {\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n    if (this.outputFiles.includes(id)) {\n      throw new Error('Cannot import the generated bundle');\n    }\n    // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n}\nexport { Task, Watcher };","map":{"version":3,"names":["getAugmentedNamespace","fseventsImporter","getDefaultExportFromCjs","createFilter","rollupInternal","path","process$1","require$$0$1","require$$2","require$$0$2","require$$1","require$$2$1","require$$0$3","platform","chokidar$1","utils$2","constants$3","hasRequiredConstants$3","requireConstants$3","WIN_SLASH","WIN_NO_SLASH","DOT_LITERAL","PLUS_LITERAL","QMARK_LITERAL","SLASH_LITERAL","ONE_CHAR","QMARK","END_ANCHOR","START_ANCHOR","DOTS_SLASH","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","POSIX_CHARS","WINDOWS_CHARS","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","MAX_LENGTH","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_GRAVE_ACCENT","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","SEP","sep","extglobChars","chars","type","open","close","globChars","win32","hasRequiredUtils$2","requireUtils$2","exports","process","isObject","val","Array","isArray","hasRegexChars","str","test","isRegexChar","length","escapeRegex","replace","toPosixSlashes","removeBackslashes","match","supportsLookbehinds","segs","version","slice","split","map","Number","isWindows","options","windows","escapeLast","input","char","lastIdx","idx","lastIndexOf","removePrefix","state","output","startsWith","prefix","wrapOutput","prepend","contains","append","negated","scan_1$1","hasRequiredScan$1","requireScan$1","utils","isPathSeparator","code","depth","token","isPrefix","isGlobstar","Infinity","scan","opts","scanToEnd","parts","slashes","tokens","index","start","lastIndex","isBrace","isBracket","isGlob","isExtglob","braceEscaped","backslashes","negatedExtglob","finished","braces","prev","value","eos","peek","charCodeAt","advance","next","push","noext","isExtglobChar","nonegate","noparen","base","glob","unescape","maxDepth","prevIndex","n","i","parse_1$2","hasRequiredParse$2","requireParse$2","constants","expandRange","args","sort","join","syntaxError","parse","TypeError","max","maxLength","Math","min","len","SyntaxError","bos","capture","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noextglob","consumed","backtrack","brackets","parens","quotes","extglobs","stack","remaining","consume","num","negate","count","increment","decrement","pop","tok","extglob","inner","extglobOpen","conditions","extglobClose","rest","extglobStar","includes","expression","fastpaths","m","esc","first","repeat","exec","posix","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","unshift","comma","out","toks","t","isGroup","Error","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","suffix","slashDot","create","source","picomatch_1$1","hasRequiredPicomatch$3","requirePicomatch$3","picomatch","returnState","fns","arrayMatcher","isMatch","isState","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","result","onIgnore","format","matchBase","basename","Boolean","RegExp","patterns","pattern","p","returnOutput","toRegex","parsed","flags","nocase","err","debug","picomatch$1","hasRequiredPicomatch$2","requirePicomatch$2","readdirp_1","hasRequiredReaddirp","requireReaddirp","fs","Readable","sysPath","promisify","readdir","stat","lstat","realpath","BANG","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","maj","versions","node","parseInt","wantBigintFsStats","normalizeFilter","filter","undefined","trim","entry","positive","negative","item","trimmed","charAt","some","f","ReaddirpStream","defaultOptions","root","fileFilter","directoryFilter","alwaysStat","constructor","objectMode","autoDestroy","highWaterMark","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","destroy","_onError","name","relative","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","substr","recursiveError","readdirp","readdirpPromise","reject","on","promise","default","anymatch","utils$1","constants$2","hasRequiredConstants$2","requireConstants$2","hasRequiredUtils$1","requireUtils$1","scan_1","hasRequiredScan","requireScan","parse_1$1","hasRequiredParse$1","requireParse$1","picomatch_1","hasRequiredPicomatch$1","requirePicomatch$1","hasRequiredPicomatch","requirePicomatch","normalizePath","hasRequiredNormalizePath","requireNormalizePath","stripTrailing","ch","anymatch_1","hasRequiredAnymatch","requireAnymatch","Object","defineProperty","DEFAULT_OPTIONS","returnIndex","arrify","createPattern","string","matchPatterns","negPatterns","isList","_path","prototype","toString","call","nglob","applied","concat","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","hasRequiredIsExtglob","requireIsExtglob","hasRequiredIsGlob","requireIsGlob","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","relaxedCheck","check","strict","globParent","hasRequiredGlobParent","requireGlobParent","pathPosixDirname","dirname","isWin32","slash","backslash","enclosure","globby","assign","flipBackslashes","hasRequiredUtils","requireUtils","isInteger","find","nodes","exceedsLimit","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","reduce","acc","flatten","flat","ele","stringify","hasRequiredStringify","requireStringify","ast","invalidBlock","escapeInvalid","invalidNode","child","isNumber","hasRequiredIsNumber","requireIsNumber","isFinite","toRegexRange_1","hasRequiredToRegexRange","requireToRegexRange","toRegexRange","String","relaxZeros","strictZeros","relax","shorthand","wrap","cacheKey","cache","hasOwnProperty","a","b","abs","isPadded","hasPadding","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","compare","rangeToPattern","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","obj","toQuantifier","padZeros","comparison","intersection","key","integer","pow","diff","clearCache","fillRange","hasRequiredFillRange","requireFillRange","util","transform","toNumber","isValidValue","pad","dash","padStart","toMaxLen","toSequence","v","toRange","isNumbers","fromCharCode","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","fillLetters","fill","compile_1","hasRequiredCompile","requireCompile","compile","walk","isOpen","isClose","console","log","expand_1","hasRequiredExpand","requireExpand","queue","stash","enclose","expand","rangeLimit","q","constants$1","hasRequiredConstants$1","requireConstants$1","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_DOLLAR","parse_1","hasRequiredParse","requireParse","keepEscaping","shift","siblings","forEach","braces_1","hasRequiredBraces","requireBraces","nodupes","noempty","require$$0","binaryExtensions","hasRequiredBinaryExtensions","requireBinaryExtensions","isBinaryPath","hasRequiredIsBinaryPath","requireIsBinaryPath","extensions","filePath","extname","toLowerCase","hasRequiredConstants","requireConstants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_FLAG_MUST_SCAN_SUBDIRS","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","ONE_DOT","TWO_DOTS","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isMacos","isLinux","isIBMi","nodefsHandler","hasRequiredNodefsHandler","requireNodefsHandler","THROTTLE_MODE_WATCH","fsrealpath","statMethods","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","watch","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","fseventsHandler","require$$3","hasRequiredFseventsHandler","requireFseventsHandler","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","mtch","Depth","isNaN","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","info","watchedParent","keys","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","initWatch","priorDepth","joinedPath","hasRequiredChokidar","requireChokidar","EventEmitter","unifyPaths","paths_","paths","every","normalizePathToUnix","toUnix","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","unmatchedGlob","part","FSWatcher","_opts","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath","chokidarExports","chokidar","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","id","transformWatcher","isTransformDependency","transformWatcherId","isFreeBSD","handleChange","changedId","invalidate","eventsRewrites","update","Watcher","optionsList","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","tasks","Task","run","previousEvent","removeListenersForCurrentRun","modules","watchFiles","invalidated","watched","skipWrite","outputs","outputFiles","watchOptions","include","exclude","fileWatcher","details","module","transformDependencies","originalCode","onInvalidate","updateWatchedFiles","write","duration","previouslyWatched","depId"],"sources":["/Users/linhankuan/fvl2025/node_modules/rollup/dist/es/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v4.46.2\n\tTue, 29 Jul 2025 19:44:27 GMT - commit 4e19badeda6f116a13a2f617ae3c6e1e14606023\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { getAugmentedNamespace, fseventsImporter, getDefaultExportFromCjs, createFilter, rollupInternal } from './node-entry.js';\nimport path from 'node:path';\nimport process$1 from 'node:process';\nimport require$$0$1 from 'path';\nimport require$$2 from 'util';\nimport require$$0$2 from 'fs';\nimport require$$1 from 'stream';\nimport require$$2$1 from 'os';\nimport require$$0$3 from 'events';\nimport { platform } from 'node:os';\nimport './parseAst.js';\nimport '../../native.js';\nimport 'node:perf_hooks';\nimport 'node:fs/promises';\n\nvar chokidar$1 = {};\n\nvar utils$2 = {};\n\nvar constants$3;\nvar hasRequiredConstants$3;\n\nfunction requireConstants$3 () {\n\tif (hasRequiredConstants$3) return constants$3;\n\thasRequiredConstants$3 = 1;\n\n\tconst path = require$$0$1;\n\tconst WIN_SLASH = '\\\\\\\\/';\n\tconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n\t/**\n\t * Posix glob regex\n\t */\n\n\tconst DOT_LITERAL = '\\\\.';\n\tconst PLUS_LITERAL = '\\\\+';\n\tconst QMARK_LITERAL = '\\\\?';\n\tconst SLASH_LITERAL = '\\\\/';\n\tconst ONE_CHAR = '(?=.)';\n\tconst QMARK = '[^/]';\n\tconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n\tconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n\tconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n\tconst NO_DOT = `(?!${DOT_LITERAL})`;\n\tconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n\tconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n\tconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n\tconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n\tconst STAR = `${QMARK}*?`;\n\n\tconst POSIX_CHARS = {\n\t  DOT_LITERAL,\n\t  PLUS_LITERAL,\n\t  QMARK_LITERAL,\n\t  SLASH_LITERAL,\n\t  ONE_CHAR,\n\t  QMARK,\n\t  END_ANCHOR,\n\t  DOTS_SLASH,\n\t  NO_DOT,\n\t  NO_DOTS,\n\t  NO_DOT_SLASH,\n\t  NO_DOTS_SLASH,\n\t  QMARK_NO_DOT,\n\t  STAR,\n\t  START_ANCHOR\n\t};\n\n\t/**\n\t * Windows glob regex\n\t */\n\n\tconst WINDOWS_CHARS = {\n\t  ...POSIX_CHARS,\n\n\t  SLASH_LITERAL: `[${WIN_SLASH}]`,\n\t  QMARK: WIN_NO_SLASH,\n\t  STAR: `${WIN_NO_SLASH}*?`,\n\t  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n\t  NO_DOT: `(?!${DOT_LITERAL})`,\n\t  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n\t  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n\t  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n\t};\n\n\t/**\n\t * POSIX Bracket Regex\n\t */\n\n\tconst POSIX_REGEX_SOURCE = {\n\t  alnum: 'a-zA-Z0-9',\n\t  alpha: 'a-zA-Z',\n\t  ascii: '\\\\x00-\\\\x7F',\n\t  blank: ' \\\\t',\n\t  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n\t  digit: '0-9',\n\t  graph: '\\\\x21-\\\\x7E',\n\t  lower: 'a-z',\n\t  print: '\\\\x20-\\\\x7E ',\n\t  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n\t  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n\t  upper: 'A-Z',\n\t  word: 'A-Za-z0-9_',\n\t  xdigit: 'A-Fa-f0-9'\n\t};\n\n\tconstants$3 = {\n\t  MAX_LENGTH: 1024 * 64,\n\t  POSIX_REGEX_SOURCE,\n\n\t  // regular expressions\n\t  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n\t  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n\t  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n\t  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n\t  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n\t  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n\t  // Replace globs with equivalent patterns to reduce parsing time.\n\t  REPLACEMENTS: {\n\t    '***': '*',\n\t    '**/**': '**',\n\t    '**/**/**': '**'\n\t  },\n\n\t  // Digits\n\t  CHAR_0: 48, /* 0 */\n\t  CHAR_9: 57, /* 9 */\n\n\t  // Alphabet chars.\n\t  CHAR_UPPERCASE_A: 65, /* A */\n\t  CHAR_LOWERCASE_A: 97, /* a */\n\t  CHAR_UPPERCASE_Z: 90, /* Z */\n\t  CHAR_LOWERCASE_Z: 122, /* z */\n\n\t  CHAR_LEFT_PARENTHESES: 40, /* ( */\n\t  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n\t  CHAR_ASTERISK: 42, /* * */\n\n\t  // Non-alphabetic chars.\n\t  CHAR_AMPERSAND: 38, /* & */\n\t  CHAR_AT: 64, /* @ */\n\t  CHAR_BACKWARD_SLASH: 92, /* \\ */\n\t  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n\t  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n\t  CHAR_COLON: 58, /* : */\n\t  CHAR_COMMA: 44, /* , */\n\t  CHAR_DOT: 46, /* . */\n\t  CHAR_DOUBLE_QUOTE: 34, /* \" */\n\t  CHAR_EQUAL: 61, /* = */\n\t  CHAR_EXCLAMATION_MARK: 33, /* ! */\n\t  CHAR_FORM_FEED: 12, /* \\f */\n\t  CHAR_FORWARD_SLASH: 47, /* / */\n\t  CHAR_GRAVE_ACCENT: 96, /* ` */\n\t  CHAR_HASH: 35, /* # */\n\t  CHAR_HYPHEN_MINUS: 45, /* - */\n\t  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n\t  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n\t  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n\t  CHAR_LINE_FEED: 10, /* \\n */\n\t  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n\t  CHAR_PERCENT: 37, /* % */\n\t  CHAR_PLUS: 43, /* + */\n\t  CHAR_QUESTION_MARK: 63, /* ? */\n\t  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n\t  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n\t  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n\t  CHAR_SEMICOLON: 59, /* ; */\n\t  CHAR_SINGLE_QUOTE: 39, /* ' */\n\t  CHAR_SPACE: 32, /*   */\n\t  CHAR_TAB: 9, /* \\t */\n\t  CHAR_UNDERSCORE: 95, /* _ */\n\t  CHAR_VERTICAL_LINE: 124, /* | */\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n\t  SEP: path.sep,\n\n\t  /**\n\t   * Create EXTGLOB_CHARS\n\t   */\n\n\t  extglobChars(chars) {\n\t    return {\n\t      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n\t      '?': { type: 'qmark', open: '(?:', close: ')?' },\n\t      '+': { type: 'plus', open: '(?:', close: ')+' },\n\t      '*': { type: 'star', open: '(?:', close: ')*' },\n\t      '@': { type: 'at', open: '(?:', close: ')' }\n\t    };\n\t  },\n\n\t  /**\n\t   * Create GLOB_CHARS\n\t   */\n\n\t  globChars(win32) {\n\t    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n\t  }\n\t};\n\treturn constants$3;\n}\n\nvar hasRequiredUtils$2;\n\nfunction requireUtils$2 () {\n\tif (hasRequiredUtils$2) return utils$2;\n\thasRequiredUtils$2 = 1;\n\t(function (exports) {\n\n\t\tconst path = require$$0$1;\n\t\tconst win32 = process.platform === 'win32';\n\t\tconst {\n\t\t  REGEX_BACKSLASH,\n\t\t  REGEX_REMOVE_BACKSLASH,\n\t\t  REGEX_SPECIAL_CHARS,\n\t\t  REGEX_SPECIAL_CHARS_GLOBAL\n\t\t} = /*@__PURE__*/ requireConstants$3();\n\n\t\texports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\t\texports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\t\texports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\t\texports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\t\texports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\n\t\texports.removeBackslashes = str => {\n\t\t  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n\t\t    return match === '\\\\' ? '' : match;\n\t\t  });\n\t\t};\n\n\t\texports.supportsLookbehinds = () => {\n\t\t  const segs = process.version.slice(1).split('.').map(Number);\n\t\t  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t};\n\n\t\texports.isWindows = options => {\n\t\t  if (options && typeof options.windows === 'boolean') {\n\t\t    return options.windows;\n\t\t  }\n\t\t  return win32 === true || path.sep === '\\\\';\n\t\t};\n\n\t\texports.escapeLast = (input, char, lastIdx) => {\n\t\t  const idx = input.lastIndexOf(char, lastIdx);\n\t\t  if (idx === -1) return input;\n\t\t  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n\t\t  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n\t\t};\n\n\t\texports.removePrefix = (input, state = {}) => {\n\t\t  let output = input;\n\t\t  if (output.startsWith('./')) {\n\t\t    output = output.slice(2);\n\t\t    state.prefix = './';\n\t\t  }\n\t\t  return output;\n\t\t};\n\n\t\texports.wrapOutput = (input, state = {}, options = {}) => {\n\t\t  const prepend = options.contains ? '' : '^';\n\t\t  const append = options.contains ? '' : '$';\n\n\t\t  let output = `${prepend}(?:${input})${append}`;\n\t\t  if (state.negated === true) {\n\t\t    output = `(?:^(?!${output}).*$)`;\n\t\t  }\n\t\t  return output;\n\t\t}; \n\t} (utils$2));\n\treturn utils$2;\n}\n\nvar scan_1$1;\nvar hasRequiredScan$1;\n\nfunction requireScan$1 () {\n\tif (hasRequiredScan$1) return scan_1$1;\n\thasRequiredScan$1 = 1;\n\n\tconst utils = /*@__PURE__*/ requireUtils$2();\n\tconst {\n\t  CHAR_ASTERISK,             /* * */\n\t  CHAR_AT,                   /* @ */\n\t  CHAR_BACKWARD_SLASH,       /* \\ */\n\t  CHAR_COMMA,                /* , */\n\t  CHAR_DOT,                  /* . */\n\t  CHAR_EXCLAMATION_MARK,     /* ! */\n\t  CHAR_FORWARD_SLASH,        /* / */\n\t  CHAR_LEFT_CURLY_BRACE,     /* { */\n\t  CHAR_LEFT_PARENTHESES,     /* ( */\n\t  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n\t  CHAR_PLUS,                 /* + */\n\t  CHAR_QUESTION_MARK,        /* ? */\n\t  CHAR_RIGHT_CURLY_BRACE,    /* } */\n\t  CHAR_RIGHT_PARENTHESES,    /* ) */\n\t  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n\t} = /*@__PURE__*/ requireConstants$3();\n\n\tconst isPathSeparator = code => {\n\t  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n\t};\n\n\tconst depth = token => {\n\t  if (token.isPrefix !== true) {\n\t    token.depth = token.isGlobstar ? Infinity : 1;\n\t  }\n\t};\n\n\t/**\n\t * Quickly scans a glob pattern and returns an object with a handful of\n\t * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n\t * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n\t * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n\t *\n\t * ```js\n\t * const pm = require('picomatch');\n\t * console.log(pm.scan('foo/bar/*.js'));\n\t * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n\t * ```\n\t * @param {String} `str`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with tokens and regex source string.\n\t * @api public\n\t */\n\n\tconst scan = (input, options) => {\n\t  const opts = options || {};\n\n\t  const length = input.length - 1;\n\t  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n\t  const slashes = [];\n\t  const tokens = [];\n\t  const parts = [];\n\n\t  let str = input;\n\t  let index = -1;\n\t  let start = 0;\n\t  let lastIndex = 0;\n\t  let isBrace = false;\n\t  let isBracket = false;\n\t  let isGlob = false;\n\t  let isExtglob = false;\n\t  let isGlobstar = false;\n\t  let braceEscaped = false;\n\t  let backslashes = false;\n\t  let negated = false;\n\t  let negatedExtglob = false;\n\t  let finished = false;\n\t  let braces = 0;\n\t  let prev;\n\t  let code;\n\t  let token = { value: '', depth: 0, isGlob: false };\n\n\t  const eos = () => index >= length;\n\t  const peek = () => str.charCodeAt(index + 1);\n\t  const advance = () => {\n\t    prev = code;\n\t    return str.charCodeAt(++index);\n\t  };\n\n\t  while (index < length) {\n\t    code = advance();\n\t    let next;\n\n\t    if (code === CHAR_BACKWARD_SLASH) {\n\t      backslashes = token.backslashes = true;\n\t      code = advance();\n\n\t      if (code === CHAR_LEFT_CURLY_BRACE) {\n\t        braceEscaped = true;\n\t      }\n\t      continue;\n\t    }\n\n\t    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n\t      braces++;\n\n\t      while (eos() !== true && (code = advance())) {\n\t        if (code === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (code === CHAR_LEFT_CURLY_BRACE) {\n\t          braces++;\n\t          continue;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_COMMA) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (code === CHAR_RIGHT_CURLY_BRACE) {\n\t          braces--;\n\n\t          if (braces === 0) {\n\t            braceEscaped = false;\n\t            isBrace = token.isBrace = true;\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (code === CHAR_FORWARD_SLASH) {\n\t      slashes.push(index);\n\t      tokens.push(token);\n\t      token = { value: '', depth: 0, isGlob: false };\n\n\t      if (finished === true) continue;\n\t      if (prev === CHAR_DOT && index === (start + 1)) {\n\t        start += 2;\n\t        continue;\n\t      }\n\n\t      lastIndex = index + 1;\n\t      continue;\n\t    }\n\n\t    if (opts.noext !== true) {\n\t      const isExtglobChar = code === CHAR_PLUS\n\t        || code === CHAR_AT\n\t        || code === CHAR_ASTERISK\n\t        || code === CHAR_QUESTION_MARK\n\t        || code === CHAR_EXCLAMATION_MARK;\n\n\t      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n\t        isGlob = token.isGlob = true;\n\t        isExtglob = token.isExtglob = true;\n\t        finished = true;\n\t        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n\t          negatedExtglob = true;\n\t        }\n\n\t        if (scanToEnd === true) {\n\t          while (eos() !== true && (code = advance())) {\n\t            if (code === CHAR_BACKWARD_SLASH) {\n\t              backslashes = token.backslashes = true;\n\t              code = advance();\n\t              continue;\n\t            }\n\n\t            if (code === CHAR_RIGHT_PARENTHESES) {\n\t              isGlob = token.isGlob = true;\n\t              finished = true;\n\t              break;\n\t            }\n\t          }\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t    }\n\n\t    if (code === CHAR_ASTERISK) {\n\t      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_QUESTION_MARK) {\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n\t      while (eos() !== true && (next = advance())) {\n\t        if (next === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n\t          isBracket = token.isBracket = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\t          break;\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n\t      negated = token.negated = true;\n\t      start++;\n\t      continue;\n\t    }\n\n\t    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n\t      isGlob = token.isGlob = true;\n\n\t      if (scanToEnd === true) {\n\t        while (eos() !== true && (code = advance())) {\n\t          if (code === CHAR_LEFT_PARENTHESES) {\n\t            backslashes = token.backslashes = true;\n\t            code = advance();\n\t            continue;\n\t          }\n\n\t          if (code === CHAR_RIGHT_PARENTHESES) {\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (isGlob === true) {\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\t  }\n\n\t  if (opts.noext === true) {\n\t    isExtglob = false;\n\t    isGlob = false;\n\t  }\n\n\t  let base = str;\n\t  let prefix = '';\n\t  let glob = '';\n\n\t  if (start > 0) {\n\t    prefix = str.slice(0, start);\n\t    str = str.slice(start);\n\t    lastIndex -= start;\n\t  }\n\n\t  if (base && isGlob === true && lastIndex > 0) {\n\t    base = str.slice(0, lastIndex);\n\t    glob = str.slice(lastIndex);\n\t  } else if (isGlob === true) {\n\t    base = '';\n\t    glob = str;\n\t  } else {\n\t    base = str;\n\t  }\n\n\t  if (base && base !== '' && base !== '/' && base !== str) {\n\t    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n\t      base = base.slice(0, -1);\n\t    }\n\t  }\n\n\t  if (opts.unescape === true) {\n\t    if (glob) glob = utils.removeBackslashes(glob);\n\n\t    if (base && backslashes === true) {\n\t      base = utils.removeBackslashes(base);\n\t    }\n\t  }\n\n\t  const state = {\n\t    prefix,\n\t    input,\n\t    start,\n\t    base,\n\t    glob,\n\t    isBrace,\n\t    isBracket,\n\t    isGlob,\n\t    isExtglob,\n\t    isGlobstar,\n\t    negated,\n\t    negatedExtglob\n\t  };\n\n\t  if (opts.tokens === true) {\n\t    state.maxDepth = 0;\n\t    if (!isPathSeparator(code)) {\n\t      tokens.push(token);\n\t    }\n\t    state.tokens = tokens;\n\t  }\n\n\t  if (opts.parts === true || opts.tokens === true) {\n\t    let prevIndex;\n\n\t    for (let idx = 0; idx < slashes.length; idx++) {\n\t      const n = prevIndex ? prevIndex + 1 : start;\n\t      const i = slashes[idx];\n\t      const value = input.slice(n, i);\n\t      if (opts.tokens) {\n\t        if (idx === 0 && start !== 0) {\n\t          tokens[idx].isPrefix = true;\n\t          tokens[idx].value = prefix;\n\t        } else {\n\t          tokens[idx].value = value;\n\t        }\n\t        depth(tokens[idx]);\n\t        state.maxDepth += tokens[idx].depth;\n\t      }\n\t      if (idx !== 0 || value !== '') {\n\t        parts.push(value);\n\t      }\n\t      prevIndex = i;\n\t    }\n\n\t    if (prevIndex && prevIndex + 1 < input.length) {\n\t      const value = input.slice(prevIndex + 1);\n\t      parts.push(value);\n\n\t      if (opts.tokens) {\n\t        tokens[tokens.length - 1].value = value;\n\t        depth(tokens[tokens.length - 1]);\n\t        state.maxDepth += tokens[tokens.length - 1].depth;\n\t      }\n\t    }\n\n\t    state.slashes = slashes;\n\t    state.parts = parts;\n\t  }\n\n\t  return state;\n\t};\n\n\tscan_1$1 = scan;\n\treturn scan_1$1;\n}\n\nvar parse_1$2;\nvar hasRequiredParse$2;\n\nfunction requireParse$2 () {\n\tif (hasRequiredParse$2) return parse_1$2;\n\thasRequiredParse$2 = 1;\n\n\tconst constants = /*@__PURE__*/ requireConstants$3();\n\tconst utils = /*@__PURE__*/ requireUtils$2();\n\n\t/**\n\t * Constants\n\t */\n\n\tconst {\n\t  MAX_LENGTH,\n\t  POSIX_REGEX_SOURCE,\n\t  REGEX_NON_SPECIAL_CHARS,\n\t  REGEX_SPECIAL_CHARS_BACKREF,\n\t  REPLACEMENTS\n\t} = constants;\n\n\t/**\n\t * Helpers\n\t */\n\n\tconst expandRange = (args, options) => {\n\t  if (typeof options.expandRange === 'function') {\n\t    return options.expandRange(...args, options);\n\t  }\n\n\t  args.sort();\n\t  const value = `[${args.join('-')}]`;\n\n\t  return value;\n\t};\n\n\t/**\n\t * Create the message for a syntax error\n\t */\n\n\tconst syntaxError = (type, char) => {\n\t  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n\t};\n\n\t/**\n\t * Parse the given input string.\n\t * @param {String} input\n\t * @param {Object} options\n\t * @return {Object}\n\t */\n\n\tconst parse = (input, options) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected a string');\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n\t  let len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n\t  const tokens = [bos];\n\n\t  const capture = opts.capture ? '' : '?:';\n\t  const win32 = utils.isWindows(options);\n\n\t  // create constants based on platform, for windows or posix\n\t  const PLATFORM_CHARS = constants.globChars(win32);\n\t  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n\t  const {\n\t    DOT_LITERAL,\n\t    PLUS_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOT_SLASH,\n\t    NO_DOTS_SLASH,\n\t    QMARK,\n\t    QMARK_NO_DOT,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = PLATFORM_CHARS;\n\n\t  const globstar = opts => {\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const nodot = opts.dot ? '' : NO_DOT;\n\t  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n\t  let star = opts.bash === true ? globstar(opts) : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  // minimatch options support\n\t  if (typeof opts.noext === 'boolean') {\n\t    opts.noextglob = opts.noext;\n\t  }\n\n\t  const state = {\n\t    input,\n\t    index: -1,\n\t    start: 0,\n\t    dot: opts.dot === true,\n\t    consumed: '',\n\t    output: '',\n\t    prefix: '',\n\t    backtrack: false,\n\t    negated: false,\n\t    brackets: 0,\n\t    braces: 0,\n\t    parens: 0,\n\t    quotes: 0,\n\t    globstar: false,\n\t    tokens\n\t  };\n\n\t  input = utils.removePrefix(input, state);\n\t  len = input.length;\n\n\t  const extglobs = [];\n\t  const braces = [];\n\t  const stack = [];\n\t  let prev = bos;\n\t  let value;\n\n\t  /**\n\t   * Tokenizing helpers\n\t   */\n\n\t  const eos = () => state.index === len - 1;\n\t  const peek = state.peek = (n = 1) => input[state.index + n];\n\t  const advance = state.advance = () => input[++state.index] || '';\n\t  const remaining = () => input.slice(state.index + 1);\n\t  const consume = (value = '', num = 0) => {\n\t    state.consumed += value;\n\t    state.index += num;\n\t  };\n\n\t  const append = token => {\n\t    state.output += token.output != null ? token.output : token.value;\n\t    consume(token.value);\n\t  };\n\n\t  const negate = () => {\n\t    let count = 1;\n\n\t    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n\t      advance();\n\t      state.start++;\n\t      count++;\n\t    }\n\n\t    if (count % 2 === 0) {\n\t      return false;\n\t    }\n\n\t    state.negated = true;\n\t    state.start++;\n\t    return true;\n\t  };\n\n\t  const increment = type => {\n\t    state[type]++;\n\t    stack.push(type);\n\t  };\n\n\t  const decrement = type => {\n\t    state[type]--;\n\t    stack.pop();\n\t  };\n\n\t  /**\n\t   * Push tokens onto the tokens array. This helper speeds up\n\t   * tokenizing by 1) helping us avoid backtracking as much as possible,\n\t   * and 2) helping us avoid creating extra tokens when consecutive\n\t   * characters are plain text. This improves performance and simplifies\n\t   * lookbehinds.\n\t   */\n\n\t  const push = tok => {\n\t    if (prev.type === 'globstar') {\n\t      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n\t      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n\t      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n\t        state.output = state.output.slice(0, -prev.output.length);\n\t        prev.type = 'star';\n\t        prev.value = '*';\n\t        prev.output = star;\n\t        state.output += prev.output;\n\t      }\n\t    }\n\n\t    if (extglobs.length && tok.type !== 'paren') {\n\t      extglobs[extglobs.length - 1].inner += tok.value;\n\t    }\n\n\t    if (tok.value || tok.output) append(tok);\n\t    if (prev && prev.type === 'text' && tok.type === 'text') {\n\t      prev.value += tok.value;\n\t      prev.output = (prev.output || '') + tok.value;\n\t      return;\n\t    }\n\n\t    tok.prev = prev;\n\t    tokens.push(tok);\n\t    prev = tok;\n\t  };\n\n\t  const extglobOpen = (type, value) => {\n\t    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n\t    token.prev = prev;\n\t    token.parens = state.parens;\n\t    token.output = state.output;\n\t    const output = (opts.capture ? '(' : '') + token.open;\n\n\t    increment('parens');\n\t    push({ type, value, output: state.output ? '' : ONE_CHAR });\n\t    push({ type: 'paren', extglob: true, value: advance(), output });\n\t    extglobs.push(token);\n\t  };\n\n\t  const extglobClose = token => {\n\t    let output = token.close + (opts.capture ? ')' : '');\n\t    let rest;\n\n\t    if (token.type === 'negate') {\n\t      let extglobStar = star;\n\n\t      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n\t        extglobStar = globstar(opts);\n\t      }\n\n\t      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n\t        output = token.close = `)$))${extglobStar}`;\n\t      }\n\n\t      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n\t        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n\t        // In this case, we need to parse the string and use it in the output of the original pattern.\n\t        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n\t        //\n\t        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n\t        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n\t        output = token.close = `)${expression})${extglobStar})`;\n\t      }\n\n\t      if (token.prev.type === 'bos') {\n\t        state.negatedExtglob = true;\n\t      }\n\t    }\n\n\t    push({ type: 'paren', extglob: true, value, output });\n\t    decrement('parens');\n\t  };\n\n\t  /**\n\t   * Fast paths\n\t   */\n\n\t  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n\t    let backslashes = false;\n\n\t    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n\t      if (first === '\\\\') {\n\t        backslashes = true;\n\t        return m;\n\t      }\n\n\t      if (first === '?') {\n\t        if (esc) {\n\t          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        if (index === 0) {\n\t          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        return QMARK.repeat(chars.length);\n\t      }\n\n\t      if (first === '.') {\n\t        return DOT_LITERAL.repeat(chars.length);\n\t      }\n\n\t      if (first === '*') {\n\t        if (esc) {\n\t          return esc + first + (rest ? star : '');\n\t        }\n\t        return star;\n\t      }\n\t      return esc ? m : `\\\\${m}`;\n\t    });\n\n\t    if (backslashes === true) {\n\t      if (opts.unescape === true) {\n\t        output = output.replace(/\\\\/g, '');\n\t      } else {\n\t        output = output.replace(/\\\\+/g, m => {\n\t          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n\t        });\n\t      }\n\t    }\n\n\t    if (output === input && opts.contains === true) {\n\t      state.output = input;\n\t      return state;\n\t    }\n\n\t    state.output = utils.wrapOutput(output, state, options);\n\t    return state;\n\t  }\n\n\t  /**\n\t   * Tokenize input until we reach end-of-string\n\t   */\n\n\t  while (!eos()) {\n\t    value = advance();\n\n\t    if (value === '\\u0000') {\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Escaped characters\n\t     */\n\n\t    if (value === '\\\\') {\n\t      const next = peek();\n\n\t      if (next === '/' && opts.bash !== true) {\n\t        continue;\n\t      }\n\n\t      if (next === '.' || next === ';') {\n\t        continue;\n\t      }\n\n\t      if (!next) {\n\t        value += '\\\\';\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\n\t      // collapse slashes to reduce potential for exploits\n\t      const match = /^\\\\+/.exec(remaining());\n\t      let slashes = 0;\n\n\t      if (match && match[0].length > 2) {\n\t        slashes = match[0].length;\n\t        state.index += slashes;\n\t        if (slashes % 2 !== 0) {\n\t          value += '\\\\';\n\t        }\n\t      }\n\n\t      if (opts.unescape === true) {\n\t        value = advance();\n\t      } else {\n\t        value += advance();\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * If we're inside a regex character class, continue\n\t     * until we reach the closing bracket.\n\t     */\n\n\t    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n\t      if (opts.posix !== false && value === ':') {\n\t        const inner = prev.value.slice(1);\n\t        if (inner.includes('[')) {\n\t          prev.posix = true;\n\n\t          if (inner.includes(':')) {\n\t            const idx = prev.value.lastIndexOf('[');\n\t            const pre = prev.value.slice(0, idx);\n\t            const rest = prev.value.slice(idx + 2);\n\t            const posix = POSIX_REGEX_SOURCE[rest];\n\t            if (posix) {\n\t              prev.value = pre + posix;\n\t              state.backtrack = true;\n\t              advance();\n\n\t              if (!bos.output && tokens.indexOf(prev) === 1) {\n\t                bos.output = ONE_CHAR;\n\t              }\n\t              continue;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (opts.posix === true && value === '!' && prev.value === '[') {\n\t        value = '^';\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * If we're inside a quoted string, continue\n\t     * until we reach the closing double quote.\n\t     */\n\n\t    if (state.quotes === 1 && value !== '\"') {\n\t      value = utils.escapeRegex(value);\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Double quotes\n\t     */\n\n\t    if (value === '\"') {\n\t      state.quotes = state.quotes === 1 ? 0 : 1;\n\t      if (opts.keepQuotes === true) {\n\t        push({ type: 'text', value });\n\t      }\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Parentheses\n\t     */\n\n\t    if (value === '(') {\n\t      increment('parens');\n\t      push({ type: 'paren', value });\n\t      continue;\n\t    }\n\n\t    if (value === ')') {\n\t      if (state.parens === 0 && opts.strictBrackets === true) {\n\t        throw new SyntaxError(syntaxError('opening', '('));\n\t      }\n\n\t      const extglob = extglobs[extglobs.length - 1];\n\t      if (extglob && state.parens === extglob.parens + 1) {\n\t        extglobClose(extglobs.pop());\n\t        continue;\n\t      }\n\n\t      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n\t      decrement('parens');\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Square brackets\n\t     */\n\n\t    if (value === '[') {\n\t      if (opts.nobracket === true || !remaining().includes(']')) {\n\t        if (opts.nobracket !== true && opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('closing', ']'));\n\t        }\n\n\t        value = `\\\\${value}`;\n\t      } else {\n\t        increment('brackets');\n\t      }\n\n\t      push({ type: 'bracket', value });\n\t      continue;\n\t    }\n\n\t    if (value === ']') {\n\t      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        if (opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('opening', '['));\n\t        }\n\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      decrement('brackets');\n\n\t      const prevValue = prev.value.slice(1);\n\t      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n\t        value = `/${value}`;\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\n\t      // when literal brackets are explicitly disabled\n\t      // assume we should match with a regex character class\n\t      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n\t        continue;\n\t      }\n\n\t      const escaped = utils.escapeRegex(prev.value);\n\t      state.output = state.output.slice(0, -prev.value.length);\n\n\t      // when literal brackets are explicitly enabled\n\t      // assume we should escape the brackets to match literal characters\n\t      if (opts.literalBrackets === true) {\n\t        state.output += escaped;\n\t        prev.value = escaped;\n\t        continue;\n\t      }\n\n\t      // when the user specifies nothing, try to match both\n\t      prev.value = `(${capture}${escaped}|${prev.value})`;\n\t      state.output += prev.value;\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Braces\n\t     */\n\n\t    if (value === '{' && opts.nobrace !== true) {\n\t      increment('braces');\n\n\t      const open = {\n\t        type: 'brace',\n\t        value,\n\t        output: '(',\n\t        outputIndex: state.output.length,\n\t        tokensIndex: state.tokens.length\n\t      };\n\n\t      braces.push(open);\n\t      push(open);\n\t      continue;\n\t    }\n\n\t    if (value === '}') {\n\t      const brace = braces[braces.length - 1];\n\n\t      if (opts.nobrace === true || !brace) {\n\t        push({ type: 'text', value, output: value });\n\t        continue;\n\t      }\n\n\t      let output = ')';\n\n\t      if (brace.dots === true) {\n\t        const arr = tokens.slice();\n\t        const range = [];\n\n\t        for (let i = arr.length - 1; i >= 0; i--) {\n\t          tokens.pop();\n\t          if (arr[i].type === 'brace') {\n\t            break;\n\t          }\n\t          if (arr[i].type !== 'dots') {\n\t            range.unshift(arr[i].value);\n\t          }\n\t        }\n\n\t        output = expandRange(range, opts);\n\t        state.backtrack = true;\n\t      }\n\n\t      if (brace.comma !== true && brace.dots !== true) {\n\t        const out = state.output.slice(0, brace.outputIndex);\n\t        const toks = state.tokens.slice(brace.tokensIndex);\n\t        brace.value = brace.output = '\\\\{';\n\t        value = output = '\\\\}';\n\t        state.output = out;\n\t        for (const t of toks) {\n\t          state.output += (t.output || t.value);\n\t        }\n\t      }\n\n\t      push({ type: 'brace', value, output });\n\t      decrement('braces');\n\t      braces.pop();\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Pipes\n\t     */\n\n\t    if (value === '|') {\n\t      if (extglobs.length > 0) {\n\t        extglobs[extglobs.length - 1].conditions++;\n\t      }\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Commas\n\t     */\n\n\t    if (value === ',') {\n\t      let output = value;\n\n\t      const brace = braces[braces.length - 1];\n\t      if (brace && stack[stack.length - 1] === 'braces') {\n\t        brace.comma = true;\n\t        output = '|';\n\t      }\n\n\t      push({ type: 'comma', value, output });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Slashes\n\t     */\n\n\t    if (value === '/') {\n\t      // if the beginning of the glob is \"./\", advance the start\n\t      // to the current index, and don't add the \"./\" characters\n\t      // to the state. This greatly simplifies lookbehinds when\n\t      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n\t      if (prev.type === 'dot' && state.index === state.start + 1) {\n\t        state.start = state.index + 1;\n\t        state.consumed = '';\n\t        state.output = '';\n\t        tokens.pop();\n\t        prev = bos; // reset \"prev\" to the first token\n\t        continue;\n\t      }\n\n\t      push({ type: 'slash', value, output: SLASH_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Dots\n\t     */\n\n\t    if (value === '.') {\n\t      if (state.braces > 0 && prev.type === 'dot') {\n\t        if (prev.value === '.') prev.output = DOT_LITERAL;\n\t        const brace = braces[braces.length - 1];\n\t        prev.type = 'dots';\n\t        prev.output += value;\n\t        prev.value += value;\n\t        brace.dots = true;\n\t        continue;\n\t      }\n\n\t      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n\t        push({ type: 'text', value, output: DOT_LITERAL });\n\t        continue;\n\t      }\n\n\t      push({ type: 'dot', value, output: DOT_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Question marks\n\t     */\n\n\t    if (value === '?') {\n\t      const isGroup = prev && prev.value === '(';\n\t      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('qmark', value);\n\t        continue;\n\t      }\n\n\t      if (prev && prev.type === 'paren') {\n\t        const next = peek();\n\t        let output = value;\n\n\t        if (next === '<' && !utils.supportsLookbehinds()) {\n\t          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n\t        }\n\n\t        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n\t          output = `\\\\${value}`;\n\t        }\n\n\t        push({ type: 'text', value, output });\n\t        continue;\n\t      }\n\n\t      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n\t        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n\t        continue;\n\t      }\n\n\t      push({ type: 'qmark', value, output: QMARK });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Exclamation\n\t     */\n\n\t    if (value === '!') {\n\t      if (opts.noextglob !== true && peek() === '(') {\n\t        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n\t          extglobOpen('negate', value);\n\t          continue;\n\t        }\n\t      }\n\n\t      if (opts.nonegate !== true && state.index === 0) {\n\t        negate();\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * Plus\n\t     */\n\n\t    if (value === '+') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('plus', value);\n\t        continue;\n\t      }\n\n\t      if ((prev && prev.value === '(') || opts.regex === false) {\n\t        push({ type: 'plus', value, output: PLUS_LITERAL });\n\t        continue;\n\t      }\n\n\t      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n\t        push({ type: 'plus', value });\n\t        continue;\n\t      }\n\n\t      push({ type: 'plus', value: PLUS_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value === '@') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        push({ type: 'at', extglob: true, value, output: '' });\n\t        continue;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value !== '*') {\n\t      if (value === '$' || value === '^') {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\t      if (match) {\n\t        value += match[0];\n\t        state.index += match[0].length;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Stars\n\t     */\n\n\t    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n\t      prev.type = 'star';\n\t      prev.star = true;\n\t      prev.value += value;\n\t      prev.output = star;\n\t      state.backtrack = true;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    let rest = remaining();\n\t    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n\t      extglobOpen('star', value);\n\t      continue;\n\t    }\n\n\t    if (prev.type === 'star') {\n\t      if (opts.noglobstar === true) {\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      const prior = prev.prev;\n\t      const before = prior.prev;\n\t      const isStart = prior.type === 'slash' || prior.type === 'bos';\n\t      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n\t      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n\t      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\t      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      // strip consecutive `/**/`\n\t      while (rest.slice(0, 3) === '/**') {\n\t        const after = input[state.index + 4];\n\t        if (after && after !== '/') {\n\t          break;\n\t        }\n\t        rest = rest.slice(3);\n\t        consume('/**', 3);\n\t      }\n\n\t      if (prior.type === 'bos' && eos()) {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = globstar(opts);\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n\t        prev.value += value;\n\t        state.globstar = true;\n\t        state.output += prior.output + prev.output;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n\t        const end = rest[1] !== void 0 ? '|$' : '';\n\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n\t        prev.value += value;\n\n\t        state.output += prior.output + prev.output;\n\t        state.globstar = true;\n\n\t        consume(value + advance());\n\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'bos' && rest[0] === '/') {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value + advance());\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      // remove single star from output\n\t      state.output = state.output.slice(0, -prev.output.length);\n\n\t      // reset previous token to globstar\n\t      prev.type = 'globstar';\n\t      prev.output = globstar(opts);\n\t      prev.value += value;\n\n\t      // reset output with globstar\n\t      state.output += prev.output;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    const token = { type: 'star', value, output: star };\n\n\t    if (opts.bash === true) {\n\t      token.output = '.*?';\n\t      if (prev.type === 'bos' || prev.type === 'slash') {\n\t        token.output = nodot + token.output;\n\t      }\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n\t      token.output = value;\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n\t      if (prev.type === 'dot') {\n\t        state.output += NO_DOT_SLASH;\n\t        prev.output += NO_DOT_SLASH;\n\n\t      } else if (opts.dot === true) {\n\t        state.output += NO_DOTS_SLASH;\n\t        prev.output += NO_DOTS_SLASH;\n\n\t      } else {\n\t        state.output += nodot;\n\t        prev.output += nodot;\n\t      }\n\n\t      if (peek() !== '*') {\n\t        state.output += ONE_CHAR;\n\t        prev.output += ONE_CHAR;\n\t      }\n\t    }\n\n\t    push(token);\n\t  }\n\n\t  while (state.brackets > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n\t    state.output = utils.escapeLast(state.output, '[');\n\t    decrement('brackets');\n\t  }\n\n\t  while (state.parens > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n\t    state.output = utils.escapeLast(state.output, '(');\n\t    decrement('parens');\n\t  }\n\n\t  while (state.braces > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n\t    state.output = utils.escapeLast(state.output, '{');\n\t    decrement('braces');\n\t  }\n\n\t  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n\t    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n\t  }\n\n\t  // rebuild the output if we had to backtrack at any point\n\t  if (state.backtrack === true) {\n\t    state.output = '';\n\n\t    for (const token of state.tokens) {\n\t      state.output += token.output != null ? token.output : token.value;\n\n\t      if (token.suffix) {\n\t        state.output += token.suffix;\n\t      }\n\t    }\n\t  }\n\n\t  return state;\n\t};\n\n\t/**\n\t * Fast paths for creating regular expressions for common glob patterns.\n\t * This can significantly speed up processing and has very little downside\n\t * impact when none of the fast paths match.\n\t */\n\n\tparse.fastpaths = (input, options) => {\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\t  const len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\t  const win32 = utils.isWindows(options);\n\n\t  // create constants based on platform, for windows or posix\n\t  const {\n\t    DOT_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOTS,\n\t    NO_DOTS_SLASH,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = constants.globChars(win32);\n\n\t  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n\t  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n\t  const capture = opts.capture ? '' : '?:';\n\t  const state = { negated: false, prefix: '' };\n\t  let star = opts.bash === true ? '.*?' : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  const globstar = opts => {\n\t    if (opts.noglobstar === true) return star;\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const create = str => {\n\t    switch (str) {\n\t      case '*':\n\t        return `${nodot}${ONE_CHAR}${star}`;\n\n\t      case '.*':\n\t        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*.*':\n\t        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*/*':\n\t        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n\t      case '**':\n\t        return nodot + globstar(opts);\n\n\t      case '**/*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n\t      case '**/*.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '**/.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      default: {\n\t        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n\t        if (!match) return;\n\n\t        const source = create(match[1]);\n\t        if (!source) return;\n\n\t        return source + DOT_LITERAL + match[2];\n\t      }\n\t    }\n\t  };\n\n\t  const output = utils.removePrefix(input, state);\n\t  let source = create(output);\n\n\t  if (source && opts.strictSlashes !== true) {\n\t    source += `${SLASH_LITERAL}?`;\n\t  }\n\n\t  return source;\n\t};\n\n\tparse_1$2 = parse;\n\treturn parse_1$2;\n}\n\nvar picomatch_1$1;\nvar hasRequiredPicomatch$3;\n\nfunction requirePicomatch$3 () {\n\tif (hasRequiredPicomatch$3) return picomatch_1$1;\n\thasRequiredPicomatch$3 = 1;\n\n\tconst path = require$$0$1;\n\tconst scan = /*@__PURE__*/ requireScan$1();\n\tconst parse = /*@__PURE__*/ requireParse$2();\n\tconst utils = /*@__PURE__*/ requireUtils$2();\n\tconst constants = /*@__PURE__*/ requireConstants$3();\n\tconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n\t/**\n\t * Creates a matcher function from one or more glob patterns. The\n\t * returned function takes a string to match as its first argument,\n\t * and returns true if the string is a match. The returned matcher\n\t * function also takes a boolean as the second argument that, when true,\n\t * returns an object with additional information.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch(glob[, options]);\n\t *\n\t * const isMatch = picomatch('*.!(*a)');\n\t * console.log(isMatch('a.a')); //=> false\n\t * console.log(isMatch('a.b')); //=> true\n\t * ```\n\t * @name picomatch\n\t * @param {String|Array} `globs` One or more glob patterns.\n\t * @param {Object=} `options`\n\t * @return {Function=} Returns a matcher function.\n\t * @api public\n\t */\n\n\tconst picomatch = (glob, options, returnState = false) => {\n\t  if (Array.isArray(glob)) {\n\t    const fns = glob.map(input => picomatch(input, options, returnState));\n\t    const arrayMatcher = str => {\n\t      for (const isMatch of fns) {\n\t        const state = isMatch(str);\n\t        if (state) return state;\n\t      }\n\t      return false;\n\t    };\n\t    return arrayMatcher;\n\t  }\n\n\t  const isState = isObject(glob) && glob.tokens && glob.input;\n\n\t  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n\t    throw new TypeError('Expected pattern to be a non-empty string');\n\t  }\n\n\t  const opts = options || {};\n\t  const posix = utils.isWindows(options);\n\t  const regex = isState\n\t    ? picomatch.compileRe(glob, options)\n\t    : picomatch.makeRe(glob, options, false, true);\n\n\t  const state = regex.state;\n\t  delete regex.state;\n\n\t  let isIgnored = () => false;\n\t  if (opts.ignore) {\n\t    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n\t    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n\t  }\n\n\t  const matcher = (input, returnObject = false) => {\n\t    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n\t    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n\t    if (typeof opts.onResult === 'function') {\n\t      opts.onResult(result);\n\t    }\n\n\t    if (isMatch === false) {\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (isIgnored(input)) {\n\t      if (typeof opts.onIgnore === 'function') {\n\t        opts.onIgnore(result);\n\t      }\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (typeof opts.onMatch === 'function') {\n\t      opts.onMatch(result);\n\t    }\n\t    return returnObject ? result : true;\n\t  };\n\n\t  if (returnState) {\n\t    matcher.state = state;\n\t  }\n\n\t  return matcher;\n\t};\n\n\t/**\n\t * Test `input` with the given `regex`. This is used by the main\n\t * `picomatch()` function to test the input string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.test(input, regex[, options]);\n\t *\n\t * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n\t * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp} `regex`\n\t * @return {Object} Returns an object with matching info.\n\t * @api public\n\t */\n\n\tpicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected input to be a string');\n\t  }\n\n\t  if (input === '') {\n\t    return { isMatch: false, output: '' };\n\t  }\n\n\t  const opts = options || {};\n\t  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n\t  let match = input === glob;\n\t  let output = (match && format) ? format(input) : input;\n\n\t  if (match === false) {\n\t    output = format ? format(input) : input;\n\t    match = output === glob;\n\t  }\n\n\t  if (match === false || opts.capture === true) {\n\t    if (opts.matchBase === true || opts.basename === true) {\n\t      match = picomatch.matchBase(input, regex, options, posix);\n\t    } else {\n\t      match = regex.exec(output);\n\t    }\n\t  }\n\n\t  return { isMatch: Boolean(match), match, output };\n\t};\n\n\t/**\n\t * Match the basename of a filepath.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.matchBase(input, glob[, options]);\n\t * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n\t * @return {Boolean}\n\t * @api public\n\t */\n\n\tpicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n\t  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n\t  return regex.test(path.basename(input));\n\t};\n\n\t/**\n\t * Returns true if **any** of the given glob `patterns` match the specified `string`.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.isMatch(string, patterns[, options]);\n\t *\n\t * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n\t * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n\t * ```\n\t * @param {String|Array} str The string to test.\n\t * @param {String|Array} patterns One or more glob patterns to use for matching.\n\t * @param {Object} [options] See available [options](#options).\n\t * @return {Boolean} Returns true if any patterns match `str`\n\t * @api public\n\t */\n\n\tpicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n\t/**\n\t * Parse a glob pattern to create the source string for a regular\n\t * expression.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const result = picomatch.parse(pattern[, options]);\n\t * ```\n\t * @param {String} `pattern`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n\t * @api public\n\t */\n\n\tpicomatch.parse = (pattern, options) => {\n\t  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n\t  return parse(pattern, { ...options, fastpaths: false });\n\t};\n\n\t/**\n\t * Scan a glob pattern to separate the pattern into segments.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.scan(input[, options]);\n\t *\n\t * const result = picomatch.scan('!./foo/*.js');\n\t * console.log(result);\n\t * { prefix: '!./',\n\t *   input: '!./foo/*.js',\n\t *   start: 3,\n\t *   base: 'foo',\n\t *   glob: '*.js',\n\t *   isBrace: false,\n\t *   isBracket: false,\n\t *   isGlob: true,\n\t *   isExtglob: false,\n\t *   isGlobstar: false,\n\t *   negated: true }\n\t * ```\n\t * @param {String} `input` Glob pattern to scan.\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with\n\t * @api public\n\t */\n\n\tpicomatch.scan = (input, options) => scan(input, options);\n\n\t/**\n\t * Compile a regular expression from the `state` object returned by the\n\t * [parse()](#parse) method.\n\t *\n\t * @param {Object} `state`\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n\t * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n\t  if (returnOutput === true) {\n\t    return state.output;\n\t  }\n\n\t  const opts = options || {};\n\t  const prepend = opts.contains ? '' : '^';\n\t  const append = opts.contains ? '' : '$';\n\n\t  let source = `${prepend}(?:${state.output})${append}`;\n\t  if (state && state.negated === true) {\n\t    source = `^(?!${source}).*$`;\n\t  }\n\n\t  const regex = picomatch.toRegex(source, options);\n\t  if (returnState === true) {\n\t    regex.state = state;\n\t  }\n\n\t  return regex;\n\t};\n\n\t/**\n\t * Create a regular expression from a parsed glob pattern.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const state = picomatch.parse('*.js');\n\t * // picomatch.compileRe(state[, options]);\n\t *\n\t * console.log(picomatch.compileRe(state));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `state` The object returned from the `.parse` method.\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n\t * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n\t * @return {RegExp} Returns a regex created from the given pattern.\n\t * @api public\n\t */\n\n\tpicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n\t  if (!input || typeof input !== 'string') {\n\t    throw new TypeError('Expected a non-empty string');\n\t  }\n\n\t  let parsed = { negated: false, fastpaths: true };\n\n\t  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n\t    parsed.output = parse.fastpaths(input, options);\n\t  }\n\n\t  if (!parsed.output) {\n\t    parsed = parse(input, options);\n\t  }\n\n\t  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n\t};\n\n\t/**\n\t * Create a regular expression from the given regex source string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.toRegex(source[, options]);\n\t *\n\t * const { output } = picomatch.parse('*.js');\n\t * console.log(picomatch.toRegex(output));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `source` Regular expression source string.\n\t * @param {Object} `options`\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.toRegex = (source, options) => {\n\t  try {\n\t    const opts = options || {};\n\t    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n\t  } catch (err) {\n\t    if (options && options.debug === true) throw err;\n\t    return /$^/;\n\t  }\n\t};\n\n\t/**\n\t * Picomatch constants.\n\t * @return {Object}\n\t */\n\n\tpicomatch.constants = constants;\n\n\t/**\n\t * Expose \"picomatch\"\n\t */\n\n\tpicomatch_1$1 = picomatch;\n\treturn picomatch_1$1;\n}\n\nvar picomatch$1;\nvar hasRequiredPicomatch$2;\n\nfunction requirePicomatch$2 () {\n\tif (hasRequiredPicomatch$2) return picomatch$1;\n\thasRequiredPicomatch$2 = 1;\n\n\tpicomatch$1 = /*@__PURE__*/ requirePicomatch$3();\n\treturn picomatch$1;\n}\n\nvar readdirp_1;\nvar hasRequiredReaddirp;\n\nfunction requireReaddirp () {\n\tif (hasRequiredReaddirp) return readdirp_1;\n\thasRequiredReaddirp = 1;\n\n\tconst fs = require$$0$2;\n\tconst { Readable } = require$$1;\n\tconst sysPath = require$$0$1;\n\tconst { promisify } = require$$2;\n\tconst picomatch = /*@__PURE__*/ requirePicomatch$2();\n\n\tconst readdir = promisify(fs.readdir);\n\tconst stat = promisify(fs.stat);\n\tconst lstat = promisify(fs.lstat);\n\tconst realpath = promisify(fs.realpath);\n\n\t/**\n\t * @typedef {Object} EntryInfo\n\t * @property {String} path\n\t * @property {String} fullPath\n\t * @property {fs.Stats=} stats\n\t * @property {fs.Dirent=} dirent\n\t * @property {String} basename\n\t */\n\n\tconst BANG = '!';\n\tconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\n\tconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\n\tconst FILE_TYPE = 'files';\n\tconst DIR_TYPE = 'directories';\n\tconst FILE_DIR_TYPE = 'files_directories';\n\tconst EVERYTHING_TYPE = 'all';\n\tconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\n\tconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\tconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\n\tconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\n\tconst normalizeFilter = filter => {\n\t  if (filter === undefined) return;\n\t  if (typeof filter === 'function') return filter;\n\n\t  if (typeof filter === 'string') {\n\t    const glob = picomatch(filter.trim());\n\t    return entry => glob(entry.basename);\n\t  }\n\n\t  if (Array.isArray(filter)) {\n\t    const positive = [];\n\t    const negative = [];\n\t    for (const item of filter) {\n\t      const trimmed = item.trim();\n\t      if (trimmed.charAt(0) === BANG) {\n\t        negative.push(picomatch(trimmed.slice(1)));\n\t      } else {\n\t        positive.push(picomatch(trimmed));\n\t      }\n\t    }\n\n\t    if (negative.length > 0) {\n\t      if (positive.length > 0) {\n\t        return entry =>\n\t          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n\t      }\n\t      return entry => !negative.some(f => f(entry.basename));\n\t    }\n\t    return entry => positive.some(f => f(entry.basename));\n\t  }\n\t};\n\n\tclass ReaddirpStream extends Readable {\n\t  static get defaultOptions() {\n\t    return {\n\t      root: '.',\n\t      /* eslint-disable no-unused-vars */\n\t      fileFilter: (path) => true,\n\t      directoryFilter: (path) => true,\n\t      /* eslint-enable no-unused-vars */\n\t      type: FILE_TYPE,\n\t      lstat: false,\n\t      depth: 2147483648,\n\t      alwaysStat: false\n\t    };\n\t  }\n\n\t  constructor(options = {}) {\n\t    super({\n\t      objectMode: true,\n\t      autoDestroy: true,\n\t      highWaterMark: options.highWaterMark || 4096\n\t    });\n\t    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n\t    const { root, type } = opts;\n\n\t    this._fileFilter = normalizeFilter(opts.fileFilter);\n\t    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n\t    const statMethod = opts.lstat ? lstat : stat;\n\t    // Use bigint stats if it's windows and stat() supports options (node 10+).\n\t    if (wantBigintFsStats) {\n\t      this._stat = path => statMethod(path, { bigint: true });\n\t    } else {\n\t      this._stat = statMethod;\n\t    }\n\n\t    this._maxDepth = opts.depth;\n\t    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n\t    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n\t    this._wantsEverything = type === EVERYTHING_TYPE;\n\t    this._root = sysPath.resolve(root);\n\t    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n\t    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n\t    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n\t    // Launch stream with one parent, the root dir.\n\t    this.parents = [this._exploreDir(root, 1)];\n\t    this.reading = false;\n\t    this.parent = undefined;\n\t  }\n\n\t  async _read(batch) {\n\t    if (this.reading) return;\n\t    this.reading = true;\n\n\t    try {\n\t      while (!this.destroyed && batch > 0) {\n\t        const { path, depth, files = [] } = this.parent || {};\n\n\t        if (files.length > 0) {\n\t          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\t          for (const entry of await Promise.all(slice)) {\n\t            if (this.destroyed) return;\n\n\t            const entryType = await this._getEntryType(entry);\n\t            if (entryType === 'directory' && this._directoryFilter(entry)) {\n\t              if (depth <= this._maxDepth) {\n\t                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n\t              }\n\n\t              if (this._wantsDir) {\n\t                this.push(entry);\n\t                batch--;\n\t              }\n\t            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n\t              if (this._wantsFile) {\n\t                this.push(entry);\n\t                batch--;\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          const parent = this.parents.pop();\n\t          if (!parent) {\n\t            this.push(null);\n\t            break;\n\t          }\n\t          this.parent = await parent;\n\t          if (this.destroyed) return;\n\t        }\n\t      }\n\t    } catch (error) {\n\t      this.destroy(error);\n\t    } finally {\n\t      this.reading = false;\n\t    }\n\t  }\n\n\t  async _exploreDir(path, depth) {\n\t    let files;\n\t    try {\n\t      files = await readdir(path, this._rdOptions);\n\t    } catch (error) {\n\t      this._onError(error);\n\t    }\n\t    return { files, depth, path };\n\t  }\n\n\t  async _formatEntry(dirent, path) {\n\t    let entry;\n\t    try {\n\t      const basename = this._isDirent ? dirent.name : dirent;\n\t      const fullPath = sysPath.resolve(sysPath.join(path, basename));\n\t      entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename };\n\t      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n\t    } catch (err) {\n\t      this._onError(err);\n\t    }\n\t    return entry;\n\t  }\n\n\t  _onError(err) {\n\t    if (isNormalFlowError(err) && !this.destroyed) {\n\t      this.emit('warn', err);\n\t    } else {\n\t      this.destroy(err);\n\t    }\n\t  }\n\n\t  async _getEntryType(entry) {\n\t    // entry may be undefined, because a warning or an error were emitted\n\t    // and the statsProp is undefined\n\t    const stats = entry && entry[this._statsProp];\n\t    if (!stats) {\n\t      return;\n\t    }\n\t    if (stats.isFile()) {\n\t      return 'file';\n\t    }\n\t    if (stats.isDirectory()) {\n\t      return 'directory';\n\t    }\n\t    if (stats && stats.isSymbolicLink()) {\n\t      const full = entry.fullPath;\n\t      try {\n\t        const entryRealPath = await realpath(full);\n\t        const entryRealPathStats = await lstat(entryRealPath);\n\t        if (entryRealPathStats.isFile()) {\n\t          return 'file';\n\t        }\n\t        if (entryRealPathStats.isDirectory()) {\n\t          const len = entryRealPath.length;\n\t          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n\t            const recursiveError = new Error(\n\t              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n\t            );\n\t            recursiveError.code = RECURSIVE_ERROR_CODE;\n\t            return this._onError(recursiveError);\n\t          }\n\t          return 'directory';\n\t        }\n\t      } catch (error) {\n\t        this._onError(error);\n\t      }\n\t    }\n\t  }\n\n\t  _includeAsFile(entry) {\n\t    const stats = entry && entry[this._statsProp];\n\n\t    return stats && this._wantsEverything && !stats.isDirectory();\n\t  }\n\t}\n\n\t/**\n\t * @typedef {Object} ReaddirpArguments\n\t * @property {Function=} fileFilter\n\t * @property {Function=} directoryFilter\n\t * @property {String=} type\n\t * @property {Number=} depth\n\t * @property {String=} root\n\t * @property {Boolean=} lstat\n\t * @property {Boolean=} bigint\n\t */\n\n\t/**\n\t * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n\t * @param {String} root Root directory\n\t * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n\t */\n\tconst readdirp = (root, options = {}) => {\n\t  let type = options.entryType || options.type;\n\t  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\t  if (type) options.type = type;\n\t  if (!root) {\n\t    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n\t  } else if (typeof root !== 'string') {\n\t    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n\t  } else if (type && !ALL_TYPES.includes(type)) {\n\t    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n\t  }\n\n\t  options.root = root;\n\t  return new ReaddirpStream(options);\n\t};\n\n\tconst readdirpPromise = (root, options = {}) => {\n\t  return new Promise((resolve, reject) => {\n\t    const files = [];\n\t    readdirp(root, options)\n\t      .on('data', entry => files.push(entry))\n\t      .on('end', () => resolve(files))\n\t      .on('error', error => reject(error));\n\t  });\n\t};\n\n\treaddirp.promise = readdirpPromise;\n\treaddirp.ReaddirpStream = ReaddirpStream;\n\treaddirp.default = readdirp;\n\n\treaddirp_1 = readdirp;\n\treturn readdirp_1;\n}\n\nvar anymatch = {exports: {}};\n\nvar utils$1 = {};\n\nvar constants$2;\nvar hasRequiredConstants$2;\n\nfunction requireConstants$2 () {\n\tif (hasRequiredConstants$2) return constants$2;\n\thasRequiredConstants$2 = 1;\n\n\tconst path = require$$0$1;\n\tconst WIN_SLASH = '\\\\\\\\/';\n\tconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n\t/**\n\t * Posix glob regex\n\t */\n\n\tconst DOT_LITERAL = '\\\\.';\n\tconst PLUS_LITERAL = '\\\\+';\n\tconst QMARK_LITERAL = '\\\\?';\n\tconst SLASH_LITERAL = '\\\\/';\n\tconst ONE_CHAR = '(?=.)';\n\tconst QMARK = '[^/]';\n\tconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n\tconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n\tconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n\tconst NO_DOT = `(?!${DOT_LITERAL})`;\n\tconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n\tconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n\tconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n\tconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n\tconst STAR = `${QMARK}*?`;\n\n\tconst POSIX_CHARS = {\n\t  DOT_LITERAL,\n\t  PLUS_LITERAL,\n\t  QMARK_LITERAL,\n\t  SLASH_LITERAL,\n\t  ONE_CHAR,\n\t  QMARK,\n\t  END_ANCHOR,\n\t  DOTS_SLASH,\n\t  NO_DOT,\n\t  NO_DOTS,\n\t  NO_DOT_SLASH,\n\t  NO_DOTS_SLASH,\n\t  QMARK_NO_DOT,\n\t  STAR,\n\t  START_ANCHOR\n\t};\n\n\t/**\n\t * Windows glob regex\n\t */\n\n\tconst WINDOWS_CHARS = {\n\t  ...POSIX_CHARS,\n\n\t  SLASH_LITERAL: `[${WIN_SLASH}]`,\n\t  QMARK: WIN_NO_SLASH,\n\t  STAR: `${WIN_NO_SLASH}*?`,\n\t  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n\t  NO_DOT: `(?!${DOT_LITERAL})`,\n\t  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n\t  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n\t  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n\t  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n\t  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n\t};\n\n\t/**\n\t * POSIX Bracket Regex\n\t */\n\n\tconst POSIX_REGEX_SOURCE = {\n\t  alnum: 'a-zA-Z0-9',\n\t  alpha: 'a-zA-Z',\n\t  ascii: '\\\\x00-\\\\x7F',\n\t  blank: ' \\\\t',\n\t  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n\t  digit: '0-9',\n\t  graph: '\\\\x21-\\\\x7E',\n\t  lower: 'a-z',\n\t  print: '\\\\x20-\\\\x7E ',\n\t  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n\t  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n\t  upper: 'A-Z',\n\t  word: 'A-Za-z0-9_',\n\t  xdigit: 'A-Fa-f0-9'\n\t};\n\n\tconstants$2 = {\n\t  MAX_LENGTH: 1024 * 64,\n\t  POSIX_REGEX_SOURCE,\n\n\t  // regular expressions\n\t  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n\t  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n\t  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n\t  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n\t  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n\t  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n\t  // Replace globs with equivalent patterns to reduce parsing time.\n\t  REPLACEMENTS: {\n\t    '***': '*',\n\t    '**/**': '**',\n\t    '**/**/**': '**'\n\t  },\n\n\t  // Digits\n\t  CHAR_0: 48, /* 0 */\n\t  CHAR_9: 57, /* 9 */\n\n\t  // Alphabet chars.\n\t  CHAR_UPPERCASE_A: 65, /* A */\n\t  CHAR_LOWERCASE_A: 97, /* a */\n\t  CHAR_UPPERCASE_Z: 90, /* Z */\n\t  CHAR_LOWERCASE_Z: 122, /* z */\n\n\t  CHAR_LEFT_PARENTHESES: 40, /* ( */\n\t  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n\t  CHAR_ASTERISK: 42, /* * */\n\n\t  // Non-alphabetic chars.\n\t  CHAR_AMPERSAND: 38, /* & */\n\t  CHAR_AT: 64, /* @ */\n\t  CHAR_BACKWARD_SLASH: 92, /* \\ */\n\t  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n\t  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n\t  CHAR_COLON: 58, /* : */\n\t  CHAR_COMMA: 44, /* , */\n\t  CHAR_DOT: 46, /* . */\n\t  CHAR_DOUBLE_QUOTE: 34, /* \" */\n\t  CHAR_EQUAL: 61, /* = */\n\t  CHAR_EXCLAMATION_MARK: 33, /* ! */\n\t  CHAR_FORM_FEED: 12, /* \\f */\n\t  CHAR_FORWARD_SLASH: 47, /* / */\n\t  CHAR_GRAVE_ACCENT: 96, /* ` */\n\t  CHAR_HASH: 35, /* # */\n\t  CHAR_HYPHEN_MINUS: 45, /* - */\n\t  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n\t  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n\t  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n\t  CHAR_LINE_FEED: 10, /* \\n */\n\t  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n\t  CHAR_PERCENT: 37, /* % */\n\t  CHAR_PLUS: 43, /* + */\n\t  CHAR_QUESTION_MARK: 63, /* ? */\n\t  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n\t  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n\t  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n\t  CHAR_SEMICOLON: 59, /* ; */\n\t  CHAR_SINGLE_QUOTE: 39, /* ' */\n\t  CHAR_SPACE: 32, /*   */\n\t  CHAR_TAB: 9, /* \\t */\n\t  CHAR_UNDERSCORE: 95, /* _ */\n\t  CHAR_VERTICAL_LINE: 124, /* | */\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n\t  SEP: path.sep,\n\n\t  /**\n\t   * Create EXTGLOB_CHARS\n\t   */\n\n\t  extglobChars(chars) {\n\t    return {\n\t      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n\t      '?': { type: 'qmark', open: '(?:', close: ')?' },\n\t      '+': { type: 'plus', open: '(?:', close: ')+' },\n\t      '*': { type: 'star', open: '(?:', close: ')*' },\n\t      '@': { type: 'at', open: '(?:', close: ')' }\n\t    };\n\t  },\n\n\t  /**\n\t   * Create GLOB_CHARS\n\t   */\n\n\t  globChars(win32) {\n\t    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n\t  }\n\t};\n\treturn constants$2;\n}\n\nvar hasRequiredUtils$1;\n\nfunction requireUtils$1 () {\n\tif (hasRequiredUtils$1) return utils$1;\n\thasRequiredUtils$1 = 1;\n\t(function (exports) {\n\n\t\tconst path = require$$0$1;\n\t\tconst win32 = process.platform === 'win32';\n\t\tconst {\n\t\t  REGEX_BACKSLASH,\n\t\t  REGEX_REMOVE_BACKSLASH,\n\t\t  REGEX_SPECIAL_CHARS,\n\t\t  REGEX_SPECIAL_CHARS_GLOBAL\n\t\t} = /*@__PURE__*/ requireConstants$2();\n\n\t\texports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\t\texports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\t\texports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\t\texports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\t\texports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\n\t\texports.removeBackslashes = str => {\n\t\t  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n\t\t    return match === '\\\\' ? '' : match;\n\t\t  });\n\t\t};\n\n\t\texports.supportsLookbehinds = () => {\n\t\t  const segs = process.version.slice(1).split('.').map(Number);\n\t\t  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t};\n\n\t\texports.isWindows = options => {\n\t\t  if (options && typeof options.windows === 'boolean') {\n\t\t    return options.windows;\n\t\t  }\n\t\t  return win32 === true || path.sep === '\\\\';\n\t\t};\n\n\t\texports.escapeLast = (input, char, lastIdx) => {\n\t\t  const idx = input.lastIndexOf(char, lastIdx);\n\t\t  if (idx === -1) return input;\n\t\t  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n\t\t  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n\t\t};\n\n\t\texports.removePrefix = (input, state = {}) => {\n\t\t  let output = input;\n\t\t  if (output.startsWith('./')) {\n\t\t    output = output.slice(2);\n\t\t    state.prefix = './';\n\t\t  }\n\t\t  return output;\n\t\t};\n\n\t\texports.wrapOutput = (input, state = {}, options = {}) => {\n\t\t  const prepend = options.contains ? '' : '^';\n\t\t  const append = options.contains ? '' : '$';\n\n\t\t  let output = `${prepend}(?:${input})${append}`;\n\t\t  if (state.negated === true) {\n\t\t    output = `(?:^(?!${output}).*$)`;\n\t\t  }\n\t\t  return output;\n\t\t}; \n\t} (utils$1));\n\treturn utils$1;\n}\n\nvar scan_1;\nvar hasRequiredScan;\n\nfunction requireScan () {\n\tif (hasRequiredScan) return scan_1;\n\thasRequiredScan = 1;\n\n\tconst utils = /*@__PURE__*/ requireUtils$1();\n\tconst {\n\t  CHAR_ASTERISK,             /* * */\n\t  CHAR_AT,                   /* @ */\n\t  CHAR_BACKWARD_SLASH,       /* \\ */\n\t  CHAR_COMMA,                /* , */\n\t  CHAR_DOT,                  /* . */\n\t  CHAR_EXCLAMATION_MARK,     /* ! */\n\t  CHAR_FORWARD_SLASH,        /* / */\n\t  CHAR_LEFT_CURLY_BRACE,     /* { */\n\t  CHAR_LEFT_PARENTHESES,     /* ( */\n\t  CHAR_LEFT_SQUARE_BRACKET,  /* [ */\n\t  CHAR_PLUS,                 /* + */\n\t  CHAR_QUESTION_MARK,        /* ? */\n\t  CHAR_RIGHT_CURLY_BRACE,    /* } */\n\t  CHAR_RIGHT_PARENTHESES,    /* ) */\n\t  CHAR_RIGHT_SQUARE_BRACKET  /* ] */\n\t} = /*@__PURE__*/ requireConstants$2();\n\n\tconst isPathSeparator = code => {\n\t  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n\t};\n\n\tconst depth = token => {\n\t  if (token.isPrefix !== true) {\n\t    token.depth = token.isGlobstar ? Infinity : 1;\n\t  }\n\t};\n\n\t/**\n\t * Quickly scans a glob pattern and returns an object with a handful of\n\t * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n\t * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not\n\t * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).\n\t *\n\t * ```js\n\t * const pm = require('picomatch');\n\t * console.log(pm.scan('foo/bar/*.js'));\n\t * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n\t * ```\n\t * @param {String} `str`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with tokens and regex source string.\n\t * @api public\n\t */\n\n\tconst scan = (input, options) => {\n\t  const opts = options || {};\n\n\t  const length = input.length - 1;\n\t  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n\t  const slashes = [];\n\t  const tokens = [];\n\t  const parts = [];\n\n\t  let str = input;\n\t  let index = -1;\n\t  let start = 0;\n\t  let lastIndex = 0;\n\t  let isBrace = false;\n\t  let isBracket = false;\n\t  let isGlob = false;\n\t  let isExtglob = false;\n\t  let isGlobstar = false;\n\t  let braceEscaped = false;\n\t  let backslashes = false;\n\t  let negated = false;\n\t  let negatedExtglob = false;\n\t  let finished = false;\n\t  let braces = 0;\n\t  let prev;\n\t  let code;\n\t  let token = { value: '', depth: 0, isGlob: false };\n\n\t  const eos = () => index >= length;\n\t  const peek = () => str.charCodeAt(index + 1);\n\t  const advance = () => {\n\t    prev = code;\n\t    return str.charCodeAt(++index);\n\t  };\n\n\t  while (index < length) {\n\t    code = advance();\n\t    let next;\n\n\t    if (code === CHAR_BACKWARD_SLASH) {\n\t      backslashes = token.backslashes = true;\n\t      code = advance();\n\n\t      if (code === CHAR_LEFT_CURLY_BRACE) {\n\t        braceEscaped = true;\n\t      }\n\t      continue;\n\t    }\n\n\t    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n\t      braces++;\n\n\t      while (eos() !== true && (code = advance())) {\n\t        if (code === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (code === CHAR_LEFT_CURLY_BRACE) {\n\t          braces++;\n\t          continue;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (braceEscaped !== true && code === CHAR_COMMA) {\n\t          isBrace = token.isBrace = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\n\t          if (scanToEnd === true) {\n\t            continue;\n\t          }\n\n\t          break;\n\t        }\n\n\t        if (code === CHAR_RIGHT_CURLY_BRACE) {\n\t          braces--;\n\n\t          if (braces === 0) {\n\t            braceEscaped = false;\n\t            isBrace = token.isBrace = true;\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (code === CHAR_FORWARD_SLASH) {\n\t      slashes.push(index);\n\t      tokens.push(token);\n\t      token = { value: '', depth: 0, isGlob: false };\n\n\t      if (finished === true) continue;\n\t      if (prev === CHAR_DOT && index === (start + 1)) {\n\t        start += 2;\n\t        continue;\n\t      }\n\n\t      lastIndex = index + 1;\n\t      continue;\n\t    }\n\n\t    if (opts.noext !== true) {\n\t      const isExtglobChar = code === CHAR_PLUS\n\t        || code === CHAR_AT\n\t        || code === CHAR_ASTERISK\n\t        || code === CHAR_QUESTION_MARK\n\t        || code === CHAR_EXCLAMATION_MARK;\n\n\t      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n\t        isGlob = token.isGlob = true;\n\t        isExtglob = token.isExtglob = true;\n\t        finished = true;\n\t        if (code === CHAR_EXCLAMATION_MARK && index === start) {\n\t          negatedExtglob = true;\n\t        }\n\n\t        if (scanToEnd === true) {\n\t          while (eos() !== true && (code = advance())) {\n\t            if (code === CHAR_BACKWARD_SLASH) {\n\t              backslashes = token.backslashes = true;\n\t              code = advance();\n\t              continue;\n\t            }\n\n\t            if (code === CHAR_RIGHT_PARENTHESES) {\n\t              isGlob = token.isGlob = true;\n\t              finished = true;\n\t              break;\n\t            }\n\t          }\n\t          continue;\n\t        }\n\t        break;\n\t      }\n\t    }\n\n\t    if (code === CHAR_ASTERISK) {\n\t      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_QUESTION_MARK) {\n\t      isGlob = token.isGlob = true;\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n\t      while (eos() !== true && (next = advance())) {\n\t        if (next === CHAR_BACKWARD_SLASH) {\n\t          backslashes = token.backslashes = true;\n\t          advance();\n\t          continue;\n\t        }\n\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n\t          isBracket = token.isBracket = true;\n\t          isGlob = token.isGlob = true;\n\t          finished = true;\n\t          break;\n\t        }\n\t      }\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\n\t    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n\t      negated = token.negated = true;\n\t      start++;\n\t      continue;\n\t    }\n\n\t    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n\t      isGlob = token.isGlob = true;\n\n\t      if (scanToEnd === true) {\n\t        while (eos() !== true && (code = advance())) {\n\t          if (code === CHAR_LEFT_PARENTHESES) {\n\t            backslashes = token.backslashes = true;\n\t            code = advance();\n\t            continue;\n\t          }\n\n\t          if (code === CHAR_RIGHT_PARENTHESES) {\n\t            finished = true;\n\t            break;\n\t          }\n\t        }\n\t        continue;\n\t      }\n\t      break;\n\t    }\n\n\t    if (isGlob === true) {\n\t      finished = true;\n\n\t      if (scanToEnd === true) {\n\t        continue;\n\t      }\n\n\t      break;\n\t    }\n\t  }\n\n\t  if (opts.noext === true) {\n\t    isExtglob = false;\n\t    isGlob = false;\n\t  }\n\n\t  let base = str;\n\t  let prefix = '';\n\t  let glob = '';\n\n\t  if (start > 0) {\n\t    prefix = str.slice(0, start);\n\t    str = str.slice(start);\n\t    lastIndex -= start;\n\t  }\n\n\t  if (base && isGlob === true && lastIndex > 0) {\n\t    base = str.slice(0, lastIndex);\n\t    glob = str.slice(lastIndex);\n\t  } else if (isGlob === true) {\n\t    base = '';\n\t    glob = str;\n\t  } else {\n\t    base = str;\n\t  }\n\n\t  if (base && base !== '' && base !== '/' && base !== str) {\n\t    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n\t      base = base.slice(0, -1);\n\t    }\n\t  }\n\n\t  if (opts.unescape === true) {\n\t    if (glob) glob = utils.removeBackslashes(glob);\n\n\t    if (base && backslashes === true) {\n\t      base = utils.removeBackslashes(base);\n\t    }\n\t  }\n\n\t  const state = {\n\t    prefix,\n\t    input,\n\t    start,\n\t    base,\n\t    glob,\n\t    isBrace,\n\t    isBracket,\n\t    isGlob,\n\t    isExtglob,\n\t    isGlobstar,\n\t    negated,\n\t    negatedExtglob\n\t  };\n\n\t  if (opts.tokens === true) {\n\t    state.maxDepth = 0;\n\t    if (!isPathSeparator(code)) {\n\t      tokens.push(token);\n\t    }\n\t    state.tokens = tokens;\n\t  }\n\n\t  if (opts.parts === true || opts.tokens === true) {\n\t    let prevIndex;\n\n\t    for (let idx = 0; idx < slashes.length; idx++) {\n\t      const n = prevIndex ? prevIndex + 1 : start;\n\t      const i = slashes[idx];\n\t      const value = input.slice(n, i);\n\t      if (opts.tokens) {\n\t        if (idx === 0 && start !== 0) {\n\t          tokens[idx].isPrefix = true;\n\t          tokens[idx].value = prefix;\n\t        } else {\n\t          tokens[idx].value = value;\n\t        }\n\t        depth(tokens[idx]);\n\t        state.maxDepth += tokens[idx].depth;\n\t      }\n\t      if (idx !== 0 || value !== '') {\n\t        parts.push(value);\n\t      }\n\t      prevIndex = i;\n\t    }\n\n\t    if (prevIndex && prevIndex + 1 < input.length) {\n\t      const value = input.slice(prevIndex + 1);\n\t      parts.push(value);\n\n\t      if (opts.tokens) {\n\t        tokens[tokens.length - 1].value = value;\n\t        depth(tokens[tokens.length - 1]);\n\t        state.maxDepth += tokens[tokens.length - 1].depth;\n\t      }\n\t    }\n\n\t    state.slashes = slashes;\n\t    state.parts = parts;\n\t  }\n\n\t  return state;\n\t};\n\n\tscan_1 = scan;\n\treturn scan_1;\n}\n\nvar parse_1$1;\nvar hasRequiredParse$1;\n\nfunction requireParse$1 () {\n\tif (hasRequiredParse$1) return parse_1$1;\n\thasRequiredParse$1 = 1;\n\n\tconst constants = /*@__PURE__*/ requireConstants$2();\n\tconst utils = /*@__PURE__*/ requireUtils$1();\n\n\t/**\n\t * Constants\n\t */\n\n\tconst {\n\t  MAX_LENGTH,\n\t  POSIX_REGEX_SOURCE,\n\t  REGEX_NON_SPECIAL_CHARS,\n\t  REGEX_SPECIAL_CHARS_BACKREF,\n\t  REPLACEMENTS\n\t} = constants;\n\n\t/**\n\t * Helpers\n\t */\n\n\tconst expandRange = (args, options) => {\n\t  if (typeof options.expandRange === 'function') {\n\t    return options.expandRange(...args, options);\n\t  }\n\n\t  args.sort();\n\t  const value = `[${args.join('-')}]`;\n\n\t  return value;\n\t};\n\n\t/**\n\t * Create the message for a syntax error\n\t */\n\n\tconst syntaxError = (type, char) => {\n\t  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n\t};\n\n\t/**\n\t * Parse the given input string.\n\t * @param {String} input\n\t * @param {Object} options\n\t * @return {Object}\n\t */\n\n\tconst parse = (input, options) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected a string');\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n\t  let len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n\t  const tokens = [bos];\n\n\t  const capture = opts.capture ? '' : '?:';\n\t  const win32 = utils.isWindows(options);\n\n\t  // create constants based on platform, for windows or posix\n\t  const PLATFORM_CHARS = constants.globChars(win32);\n\t  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n\t  const {\n\t    DOT_LITERAL,\n\t    PLUS_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOT_SLASH,\n\t    NO_DOTS_SLASH,\n\t    QMARK,\n\t    QMARK_NO_DOT,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = PLATFORM_CHARS;\n\n\t  const globstar = opts => {\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const nodot = opts.dot ? '' : NO_DOT;\n\t  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n\t  let star = opts.bash === true ? globstar(opts) : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  // minimatch options support\n\t  if (typeof opts.noext === 'boolean') {\n\t    opts.noextglob = opts.noext;\n\t  }\n\n\t  const state = {\n\t    input,\n\t    index: -1,\n\t    start: 0,\n\t    dot: opts.dot === true,\n\t    consumed: '',\n\t    output: '',\n\t    prefix: '',\n\t    backtrack: false,\n\t    negated: false,\n\t    brackets: 0,\n\t    braces: 0,\n\t    parens: 0,\n\t    quotes: 0,\n\t    globstar: false,\n\t    tokens\n\t  };\n\n\t  input = utils.removePrefix(input, state);\n\t  len = input.length;\n\n\t  const extglobs = [];\n\t  const braces = [];\n\t  const stack = [];\n\t  let prev = bos;\n\t  let value;\n\n\t  /**\n\t   * Tokenizing helpers\n\t   */\n\n\t  const eos = () => state.index === len - 1;\n\t  const peek = state.peek = (n = 1) => input[state.index + n];\n\t  const advance = state.advance = () => input[++state.index] || '';\n\t  const remaining = () => input.slice(state.index + 1);\n\t  const consume = (value = '', num = 0) => {\n\t    state.consumed += value;\n\t    state.index += num;\n\t  };\n\n\t  const append = token => {\n\t    state.output += token.output != null ? token.output : token.value;\n\t    consume(token.value);\n\t  };\n\n\t  const negate = () => {\n\t    let count = 1;\n\n\t    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n\t      advance();\n\t      state.start++;\n\t      count++;\n\t    }\n\n\t    if (count % 2 === 0) {\n\t      return false;\n\t    }\n\n\t    state.negated = true;\n\t    state.start++;\n\t    return true;\n\t  };\n\n\t  const increment = type => {\n\t    state[type]++;\n\t    stack.push(type);\n\t  };\n\n\t  const decrement = type => {\n\t    state[type]--;\n\t    stack.pop();\n\t  };\n\n\t  /**\n\t   * Push tokens onto the tokens array. This helper speeds up\n\t   * tokenizing by 1) helping us avoid backtracking as much as possible,\n\t   * and 2) helping us avoid creating extra tokens when consecutive\n\t   * characters are plain text. This improves performance and simplifies\n\t   * lookbehinds.\n\t   */\n\n\t  const push = tok => {\n\t    if (prev.type === 'globstar') {\n\t      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n\t      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n\t      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n\t        state.output = state.output.slice(0, -prev.output.length);\n\t        prev.type = 'star';\n\t        prev.value = '*';\n\t        prev.output = star;\n\t        state.output += prev.output;\n\t      }\n\t    }\n\n\t    if (extglobs.length && tok.type !== 'paren') {\n\t      extglobs[extglobs.length - 1].inner += tok.value;\n\t    }\n\n\t    if (tok.value || tok.output) append(tok);\n\t    if (prev && prev.type === 'text' && tok.type === 'text') {\n\t      prev.value += tok.value;\n\t      prev.output = (prev.output || '') + tok.value;\n\t      return;\n\t    }\n\n\t    tok.prev = prev;\n\t    tokens.push(tok);\n\t    prev = tok;\n\t  };\n\n\t  const extglobOpen = (type, value) => {\n\t    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n\t    token.prev = prev;\n\t    token.parens = state.parens;\n\t    token.output = state.output;\n\t    const output = (opts.capture ? '(' : '') + token.open;\n\n\t    increment('parens');\n\t    push({ type, value, output: state.output ? '' : ONE_CHAR });\n\t    push({ type: 'paren', extglob: true, value: advance(), output });\n\t    extglobs.push(token);\n\t  };\n\n\t  const extglobClose = token => {\n\t    let output = token.close + (opts.capture ? ')' : '');\n\t    let rest;\n\n\t    if (token.type === 'negate') {\n\t      let extglobStar = star;\n\n\t      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n\t        extglobStar = globstar(opts);\n\t      }\n\n\t      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n\t        output = token.close = `)$))${extglobStar}`;\n\t      }\n\n\t      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n\t        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n\t        // In this case, we need to parse the string and use it in the output of the original pattern.\n\t        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n\t        //\n\t        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n\t        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n\t        output = token.close = `)${expression})${extglobStar})`;\n\t      }\n\n\t      if (token.prev.type === 'bos') {\n\t        state.negatedExtglob = true;\n\t      }\n\t    }\n\n\t    push({ type: 'paren', extglob: true, value, output });\n\t    decrement('parens');\n\t  };\n\n\t  /**\n\t   * Fast paths\n\t   */\n\n\t  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n\t    let backslashes = false;\n\n\t    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n\t      if (first === '\\\\') {\n\t        backslashes = true;\n\t        return m;\n\t      }\n\n\t      if (first === '?') {\n\t        if (esc) {\n\t          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        if (index === 0) {\n\t          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n\t        }\n\t        return QMARK.repeat(chars.length);\n\t      }\n\n\t      if (first === '.') {\n\t        return DOT_LITERAL.repeat(chars.length);\n\t      }\n\n\t      if (first === '*') {\n\t        if (esc) {\n\t          return esc + first + (rest ? star : '');\n\t        }\n\t        return star;\n\t      }\n\t      return esc ? m : `\\\\${m}`;\n\t    });\n\n\t    if (backslashes === true) {\n\t      if (opts.unescape === true) {\n\t        output = output.replace(/\\\\/g, '');\n\t      } else {\n\t        output = output.replace(/\\\\+/g, m => {\n\t          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n\t        });\n\t      }\n\t    }\n\n\t    if (output === input && opts.contains === true) {\n\t      state.output = input;\n\t      return state;\n\t    }\n\n\t    state.output = utils.wrapOutput(output, state, options);\n\t    return state;\n\t  }\n\n\t  /**\n\t   * Tokenize input until we reach end-of-string\n\t   */\n\n\t  while (!eos()) {\n\t    value = advance();\n\n\t    if (value === '\\u0000') {\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Escaped characters\n\t     */\n\n\t    if (value === '\\\\') {\n\t      const next = peek();\n\n\t      if (next === '/' && opts.bash !== true) {\n\t        continue;\n\t      }\n\n\t      if (next === '.' || next === ';') {\n\t        continue;\n\t      }\n\n\t      if (!next) {\n\t        value += '\\\\';\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\n\t      // collapse slashes to reduce potential for exploits\n\t      const match = /^\\\\+/.exec(remaining());\n\t      let slashes = 0;\n\n\t      if (match && match[0].length > 2) {\n\t        slashes = match[0].length;\n\t        state.index += slashes;\n\t        if (slashes % 2 !== 0) {\n\t          value += '\\\\';\n\t        }\n\t      }\n\n\t      if (opts.unescape === true) {\n\t        value = advance();\n\t      } else {\n\t        value += advance();\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * If we're inside a regex character class, continue\n\t     * until we reach the closing bracket.\n\t     */\n\n\t    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n\t      if (opts.posix !== false && value === ':') {\n\t        const inner = prev.value.slice(1);\n\t        if (inner.includes('[')) {\n\t          prev.posix = true;\n\n\t          if (inner.includes(':')) {\n\t            const idx = prev.value.lastIndexOf('[');\n\t            const pre = prev.value.slice(0, idx);\n\t            const rest = prev.value.slice(idx + 2);\n\t            const posix = POSIX_REGEX_SOURCE[rest];\n\t            if (posix) {\n\t              prev.value = pre + posix;\n\t              state.backtrack = true;\n\t              advance();\n\n\t              if (!bos.output && tokens.indexOf(prev) === 1) {\n\t                bos.output = ONE_CHAR;\n\t              }\n\t              continue;\n\t            }\n\t          }\n\t        }\n\t      }\n\n\t      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      if (opts.posix === true && value === '!' && prev.value === '[') {\n\t        value = '^';\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * If we're inside a quoted string, continue\n\t     * until we reach the closing double quote.\n\t     */\n\n\t    if (state.quotes === 1 && value !== '\"') {\n\t      value = utils.escapeRegex(value);\n\t      prev.value += value;\n\t      append({ value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Double quotes\n\t     */\n\n\t    if (value === '\"') {\n\t      state.quotes = state.quotes === 1 ? 0 : 1;\n\t      if (opts.keepQuotes === true) {\n\t        push({ type: 'text', value });\n\t      }\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Parentheses\n\t     */\n\n\t    if (value === '(') {\n\t      increment('parens');\n\t      push({ type: 'paren', value });\n\t      continue;\n\t    }\n\n\t    if (value === ')') {\n\t      if (state.parens === 0 && opts.strictBrackets === true) {\n\t        throw new SyntaxError(syntaxError('opening', '('));\n\t      }\n\n\t      const extglob = extglobs[extglobs.length - 1];\n\t      if (extglob && state.parens === extglob.parens + 1) {\n\t        extglobClose(extglobs.pop());\n\t        continue;\n\t      }\n\n\t      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n\t      decrement('parens');\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Square brackets\n\t     */\n\n\t    if (value === '[') {\n\t      if (opts.nobracket === true || !remaining().includes(']')) {\n\t        if (opts.nobracket !== true && opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('closing', ']'));\n\t        }\n\n\t        value = `\\\\${value}`;\n\t      } else {\n\t        increment('brackets');\n\t      }\n\n\t      push({ type: 'bracket', value });\n\t      continue;\n\t    }\n\n\t    if (value === ']') {\n\t      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      if (state.brackets === 0) {\n\t        if (opts.strictBrackets === true) {\n\t          throw new SyntaxError(syntaxError('opening', '['));\n\t        }\n\n\t        push({ type: 'text', value, output: `\\\\${value}` });\n\t        continue;\n\t      }\n\n\t      decrement('brackets');\n\n\t      const prevValue = prev.value.slice(1);\n\t      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n\t        value = `/${value}`;\n\t      }\n\n\t      prev.value += value;\n\t      append({ value });\n\n\t      // when literal brackets are explicitly disabled\n\t      // assume we should match with a regex character class\n\t      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n\t        continue;\n\t      }\n\n\t      const escaped = utils.escapeRegex(prev.value);\n\t      state.output = state.output.slice(0, -prev.value.length);\n\n\t      // when literal brackets are explicitly enabled\n\t      // assume we should escape the brackets to match literal characters\n\t      if (opts.literalBrackets === true) {\n\t        state.output += escaped;\n\t        prev.value = escaped;\n\t        continue;\n\t      }\n\n\t      // when the user specifies nothing, try to match both\n\t      prev.value = `(${capture}${escaped}|${prev.value})`;\n\t      state.output += prev.value;\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Braces\n\t     */\n\n\t    if (value === '{' && opts.nobrace !== true) {\n\t      increment('braces');\n\n\t      const open = {\n\t        type: 'brace',\n\t        value,\n\t        output: '(',\n\t        outputIndex: state.output.length,\n\t        tokensIndex: state.tokens.length\n\t      };\n\n\t      braces.push(open);\n\t      push(open);\n\t      continue;\n\t    }\n\n\t    if (value === '}') {\n\t      const brace = braces[braces.length - 1];\n\n\t      if (opts.nobrace === true || !brace) {\n\t        push({ type: 'text', value, output: value });\n\t        continue;\n\t      }\n\n\t      let output = ')';\n\n\t      if (brace.dots === true) {\n\t        const arr = tokens.slice();\n\t        const range = [];\n\n\t        for (let i = arr.length - 1; i >= 0; i--) {\n\t          tokens.pop();\n\t          if (arr[i].type === 'brace') {\n\t            break;\n\t          }\n\t          if (arr[i].type !== 'dots') {\n\t            range.unshift(arr[i].value);\n\t          }\n\t        }\n\n\t        output = expandRange(range, opts);\n\t        state.backtrack = true;\n\t      }\n\n\t      if (brace.comma !== true && brace.dots !== true) {\n\t        const out = state.output.slice(0, brace.outputIndex);\n\t        const toks = state.tokens.slice(brace.tokensIndex);\n\t        brace.value = brace.output = '\\\\{';\n\t        value = output = '\\\\}';\n\t        state.output = out;\n\t        for (const t of toks) {\n\t          state.output += (t.output || t.value);\n\t        }\n\t      }\n\n\t      push({ type: 'brace', value, output });\n\t      decrement('braces');\n\t      braces.pop();\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Pipes\n\t     */\n\n\t    if (value === '|') {\n\t      if (extglobs.length > 0) {\n\t        extglobs[extglobs.length - 1].conditions++;\n\t      }\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Commas\n\t     */\n\n\t    if (value === ',') {\n\t      let output = value;\n\n\t      const brace = braces[braces.length - 1];\n\t      if (brace && stack[stack.length - 1] === 'braces') {\n\t        brace.comma = true;\n\t        output = '|';\n\t      }\n\n\t      push({ type: 'comma', value, output });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Slashes\n\t     */\n\n\t    if (value === '/') {\n\t      // if the beginning of the glob is \"./\", advance the start\n\t      // to the current index, and don't add the \"./\" characters\n\t      // to the state. This greatly simplifies lookbehinds when\n\t      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n\t      if (prev.type === 'dot' && state.index === state.start + 1) {\n\t        state.start = state.index + 1;\n\t        state.consumed = '';\n\t        state.output = '';\n\t        tokens.pop();\n\t        prev = bos; // reset \"prev\" to the first token\n\t        continue;\n\t      }\n\n\t      push({ type: 'slash', value, output: SLASH_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Dots\n\t     */\n\n\t    if (value === '.') {\n\t      if (state.braces > 0 && prev.type === 'dot') {\n\t        if (prev.value === '.') prev.output = DOT_LITERAL;\n\t        const brace = braces[braces.length - 1];\n\t        prev.type = 'dots';\n\t        prev.output += value;\n\t        prev.value += value;\n\t        brace.dots = true;\n\t        continue;\n\t      }\n\n\t      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n\t        push({ type: 'text', value, output: DOT_LITERAL });\n\t        continue;\n\t      }\n\n\t      push({ type: 'dot', value, output: DOT_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Question marks\n\t     */\n\n\t    if (value === '?') {\n\t      const isGroup = prev && prev.value === '(';\n\t      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('qmark', value);\n\t        continue;\n\t      }\n\n\t      if (prev && prev.type === 'paren') {\n\t        const next = peek();\n\t        let output = value;\n\n\t        if (next === '<' && !utils.supportsLookbehinds()) {\n\t          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n\t        }\n\n\t        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n\t          output = `\\\\${value}`;\n\t        }\n\n\t        push({ type: 'text', value, output });\n\t        continue;\n\t      }\n\n\t      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n\t        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n\t        continue;\n\t      }\n\n\t      push({ type: 'qmark', value, output: QMARK });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Exclamation\n\t     */\n\n\t    if (value === '!') {\n\t      if (opts.noextglob !== true && peek() === '(') {\n\t        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n\t          extglobOpen('negate', value);\n\t          continue;\n\t        }\n\t      }\n\n\t      if (opts.nonegate !== true && state.index === 0) {\n\t        negate();\n\t        continue;\n\t      }\n\t    }\n\n\t    /**\n\t     * Plus\n\t     */\n\n\t    if (value === '+') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        extglobOpen('plus', value);\n\t        continue;\n\t      }\n\n\t      if ((prev && prev.value === '(') || opts.regex === false) {\n\t        push({ type: 'plus', value, output: PLUS_LITERAL });\n\t        continue;\n\t      }\n\n\t      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n\t        push({ type: 'plus', value });\n\t        continue;\n\t      }\n\n\t      push({ type: 'plus', value: PLUS_LITERAL });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value === '@') {\n\t      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n\t        push({ type: 'at', extglob: true, value, output: '' });\n\t        continue;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Plain text\n\t     */\n\n\t    if (value !== '*') {\n\t      if (value === '$' || value === '^') {\n\t        value = `\\\\${value}`;\n\t      }\n\n\t      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\t      if (match) {\n\t        value += match[0];\n\t        state.index += match[0].length;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Stars\n\t     */\n\n\t    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n\t      prev.type = 'star';\n\t      prev.star = true;\n\t      prev.value += value;\n\t      prev.output = star;\n\t      state.backtrack = true;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    let rest = remaining();\n\t    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n\t      extglobOpen('star', value);\n\t      continue;\n\t    }\n\n\t    if (prev.type === 'star') {\n\t      if (opts.noglobstar === true) {\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      const prior = prev.prev;\n\t      const before = prior.prev;\n\t      const isStart = prior.type === 'slash' || prior.type === 'bos';\n\t      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n\t      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n\t      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\t      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n\t        push({ type: 'star', value, output: '' });\n\t        continue;\n\t      }\n\n\t      // strip consecutive `/**/`\n\t      while (rest.slice(0, 3) === '/**') {\n\t        const after = input[state.index + 4];\n\t        if (after && after !== '/') {\n\t          break;\n\t        }\n\t        rest = rest.slice(3);\n\t        consume('/**', 3);\n\t      }\n\n\t      if (prior.type === 'bos' && eos()) {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = globstar(opts);\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n\t        prev.value += value;\n\t        state.globstar = true;\n\t        state.output += prior.output + prev.output;\n\t        consume(value);\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n\t        const end = rest[1] !== void 0 ? '|$' : '';\n\n\t        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n\t        prior.output = `(?:${prior.output}`;\n\n\t        prev.type = 'globstar';\n\t        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n\t        prev.value += value;\n\n\t        state.output += prior.output + prev.output;\n\t        state.globstar = true;\n\n\t        consume(value + advance());\n\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      if (prior.type === 'bos' && rest[0] === '/') {\n\t        prev.type = 'globstar';\n\t        prev.value += value;\n\t        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n\t        state.output = prev.output;\n\t        state.globstar = true;\n\t        consume(value + advance());\n\t        push({ type: 'slash', value: '/', output: '' });\n\t        continue;\n\t      }\n\n\t      // remove single star from output\n\t      state.output = state.output.slice(0, -prev.output.length);\n\n\t      // reset previous token to globstar\n\t      prev.type = 'globstar';\n\t      prev.output = globstar(opts);\n\t      prev.value += value;\n\n\t      // reset output with globstar\n\t      state.output += prev.output;\n\t      state.globstar = true;\n\t      consume(value);\n\t      continue;\n\t    }\n\n\t    const token = { type: 'star', value, output: star };\n\n\t    if (opts.bash === true) {\n\t      token.output = '.*?';\n\t      if (prev.type === 'bos' || prev.type === 'slash') {\n\t        token.output = nodot + token.output;\n\t      }\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n\t      token.output = value;\n\t      push(token);\n\t      continue;\n\t    }\n\n\t    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n\t      if (prev.type === 'dot') {\n\t        state.output += NO_DOT_SLASH;\n\t        prev.output += NO_DOT_SLASH;\n\n\t      } else if (opts.dot === true) {\n\t        state.output += NO_DOTS_SLASH;\n\t        prev.output += NO_DOTS_SLASH;\n\n\t      } else {\n\t        state.output += nodot;\n\t        prev.output += nodot;\n\t      }\n\n\t      if (peek() !== '*') {\n\t        state.output += ONE_CHAR;\n\t        prev.output += ONE_CHAR;\n\t      }\n\t    }\n\n\t    push(token);\n\t  }\n\n\t  while (state.brackets > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n\t    state.output = utils.escapeLast(state.output, '[');\n\t    decrement('brackets');\n\t  }\n\n\t  while (state.parens > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n\t    state.output = utils.escapeLast(state.output, '(');\n\t    decrement('parens');\n\t  }\n\n\t  while (state.braces > 0) {\n\t    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n\t    state.output = utils.escapeLast(state.output, '{');\n\t    decrement('braces');\n\t  }\n\n\t  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n\t    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n\t  }\n\n\t  // rebuild the output if we had to backtrack at any point\n\t  if (state.backtrack === true) {\n\t    state.output = '';\n\n\t    for (const token of state.tokens) {\n\t      state.output += token.output != null ? token.output : token.value;\n\n\t      if (token.suffix) {\n\t        state.output += token.suffix;\n\t      }\n\t    }\n\t  }\n\n\t  return state;\n\t};\n\n\t/**\n\t * Fast paths for creating regular expressions for common glob patterns.\n\t * This can significantly speed up processing and has very little downside\n\t * impact when none of the fast paths match.\n\t */\n\n\tparse.fastpaths = (input, options) => {\n\t  const opts = { ...options };\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\t  const len = input.length;\n\t  if (len > max) {\n\t    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n\t  }\n\n\t  input = REPLACEMENTS[input] || input;\n\t  const win32 = utils.isWindows(options);\n\n\t  // create constants based on platform, for windows or posix\n\t  const {\n\t    DOT_LITERAL,\n\t    SLASH_LITERAL,\n\t    ONE_CHAR,\n\t    DOTS_SLASH,\n\t    NO_DOT,\n\t    NO_DOTS,\n\t    NO_DOTS_SLASH,\n\t    STAR,\n\t    START_ANCHOR\n\t  } = constants.globChars(win32);\n\n\t  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n\t  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n\t  const capture = opts.capture ? '' : '?:';\n\t  const state = { negated: false, prefix: '' };\n\t  let star = opts.bash === true ? '.*?' : STAR;\n\n\t  if (opts.capture) {\n\t    star = `(${star})`;\n\t  }\n\n\t  const globstar = opts => {\n\t    if (opts.noglobstar === true) return star;\n\t    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n\t  };\n\n\t  const create = str => {\n\t    switch (str) {\n\t      case '*':\n\t        return `${nodot}${ONE_CHAR}${star}`;\n\n\t      case '.*':\n\t        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*.*':\n\t        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '*/*':\n\t        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n\t      case '**':\n\t        return nodot + globstar(opts);\n\n\t      case '**/*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n\t      case '**/*.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      case '**/.*':\n\t        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n\t      default: {\n\t        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n\t        if (!match) return;\n\n\t        const source = create(match[1]);\n\t        if (!source) return;\n\n\t        return source + DOT_LITERAL + match[2];\n\t      }\n\t    }\n\t  };\n\n\t  const output = utils.removePrefix(input, state);\n\t  let source = create(output);\n\n\t  if (source && opts.strictSlashes !== true) {\n\t    source += `${SLASH_LITERAL}?`;\n\t  }\n\n\t  return source;\n\t};\n\n\tparse_1$1 = parse;\n\treturn parse_1$1;\n}\n\nvar picomatch_1;\nvar hasRequiredPicomatch$1;\n\nfunction requirePicomatch$1 () {\n\tif (hasRequiredPicomatch$1) return picomatch_1;\n\thasRequiredPicomatch$1 = 1;\n\n\tconst path = require$$0$1;\n\tconst scan = /*@__PURE__*/ requireScan();\n\tconst parse = /*@__PURE__*/ requireParse$1();\n\tconst utils = /*@__PURE__*/ requireUtils$1();\n\tconst constants = /*@__PURE__*/ requireConstants$2();\n\tconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n\n\t/**\n\t * Creates a matcher function from one or more glob patterns. The\n\t * returned function takes a string to match as its first argument,\n\t * and returns true if the string is a match. The returned matcher\n\t * function also takes a boolean as the second argument that, when true,\n\t * returns an object with additional information.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch(glob[, options]);\n\t *\n\t * const isMatch = picomatch('*.!(*a)');\n\t * console.log(isMatch('a.a')); //=> false\n\t * console.log(isMatch('a.b')); //=> true\n\t * ```\n\t * @name picomatch\n\t * @param {String|Array} `globs` One or more glob patterns.\n\t * @param {Object=} `options`\n\t * @return {Function=} Returns a matcher function.\n\t * @api public\n\t */\n\n\tconst picomatch = (glob, options, returnState = false) => {\n\t  if (Array.isArray(glob)) {\n\t    const fns = glob.map(input => picomatch(input, options, returnState));\n\t    const arrayMatcher = str => {\n\t      for (const isMatch of fns) {\n\t        const state = isMatch(str);\n\t        if (state) return state;\n\t      }\n\t      return false;\n\t    };\n\t    return arrayMatcher;\n\t  }\n\n\t  const isState = isObject(glob) && glob.tokens && glob.input;\n\n\t  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n\t    throw new TypeError('Expected pattern to be a non-empty string');\n\t  }\n\n\t  const opts = options || {};\n\t  const posix = utils.isWindows(options);\n\t  const regex = isState\n\t    ? picomatch.compileRe(glob, options)\n\t    : picomatch.makeRe(glob, options, false, true);\n\n\t  const state = regex.state;\n\t  delete regex.state;\n\n\t  let isIgnored = () => false;\n\t  if (opts.ignore) {\n\t    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n\t    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n\t  }\n\n\t  const matcher = (input, returnObject = false) => {\n\t    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n\t    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n\t    if (typeof opts.onResult === 'function') {\n\t      opts.onResult(result);\n\t    }\n\n\t    if (isMatch === false) {\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (isIgnored(input)) {\n\t      if (typeof opts.onIgnore === 'function') {\n\t        opts.onIgnore(result);\n\t      }\n\t      result.isMatch = false;\n\t      return returnObject ? result : false;\n\t    }\n\n\t    if (typeof opts.onMatch === 'function') {\n\t      opts.onMatch(result);\n\t    }\n\t    return returnObject ? result : true;\n\t  };\n\n\t  if (returnState) {\n\t    matcher.state = state;\n\t  }\n\n\t  return matcher;\n\t};\n\n\t/**\n\t * Test `input` with the given `regex`. This is used by the main\n\t * `picomatch()` function to test the input string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.test(input, regex[, options]);\n\t *\n\t * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n\t * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp} `regex`\n\t * @return {Object} Returns an object with matching info.\n\t * @api public\n\t */\n\n\tpicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected input to be a string');\n\t  }\n\n\t  if (input === '') {\n\t    return { isMatch: false, output: '' };\n\t  }\n\n\t  const opts = options || {};\n\t  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n\t  let match = input === glob;\n\t  let output = (match && format) ? format(input) : input;\n\n\t  if (match === false) {\n\t    output = format ? format(input) : input;\n\t    match = output === glob;\n\t  }\n\n\t  if (match === false || opts.capture === true) {\n\t    if (opts.matchBase === true || opts.basename === true) {\n\t      match = picomatch.matchBase(input, regex, options, posix);\n\t    } else {\n\t      match = regex.exec(output);\n\t    }\n\t  }\n\n\t  return { isMatch: Boolean(match), match, output };\n\t};\n\n\t/**\n\t * Match the basename of a filepath.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.matchBase(input, glob[, options]);\n\t * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n\t * ```\n\t * @param {String} `input` String to test.\n\t * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n\t * @return {Boolean}\n\t * @api public\n\t */\n\n\tpicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n\t  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n\t  return regex.test(path.basename(input));\n\t};\n\n\t/**\n\t * Returns true if **any** of the given glob `patterns` match the specified `string`.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.isMatch(string, patterns[, options]);\n\t *\n\t * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n\t * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n\t * ```\n\t * @param {String|Array} str The string to test.\n\t * @param {String|Array} patterns One or more glob patterns to use for matching.\n\t * @param {Object} [options] See available [options](#options).\n\t * @return {Boolean} Returns true if any patterns match `str`\n\t * @api public\n\t */\n\n\tpicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n\t/**\n\t * Parse a glob pattern to create the source string for a regular\n\t * expression.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const result = picomatch.parse(pattern[, options]);\n\t * ```\n\t * @param {String} `pattern`\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n\t * @api public\n\t */\n\n\tpicomatch.parse = (pattern, options) => {\n\t  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n\t  return parse(pattern, { ...options, fastpaths: false });\n\t};\n\n\t/**\n\t * Scan a glob pattern to separate the pattern into segments.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.scan(input[, options]);\n\t *\n\t * const result = picomatch.scan('!./foo/*.js');\n\t * console.log(result);\n\t * { prefix: '!./',\n\t *   input: '!./foo/*.js',\n\t *   start: 3,\n\t *   base: 'foo',\n\t *   glob: '*.js',\n\t *   isBrace: false,\n\t *   isBracket: false,\n\t *   isGlob: true,\n\t *   isExtglob: false,\n\t *   isGlobstar: false,\n\t *   negated: true }\n\t * ```\n\t * @param {String} `input` Glob pattern to scan.\n\t * @param {Object} `options`\n\t * @return {Object} Returns an object with\n\t * @api public\n\t */\n\n\tpicomatch.scan = (input, options) => scan(input, options);\n\n\t/**\n\t * Compile a regular expression from the `state` object returned by the\n\t * [parse()](#parse) method.\n\t *\n\t * @param {Object} `state`\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.\n\t * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n\t  if (returnOutput === true) {\n\t    return state.output;\n\t  }\n\n\t  const opts = options || {};\n\t  const prepend = opts.contains ? '' : '^';\n\t  const append = opts.contains ? '' : '$';\n\n\t  let source = `${prepend}(?:${state.output})${append}`;\n\t  if (state && state.negated === true) {\n\t    source = `^(?!${source}).*$`;\n\t  }\n\n\t  const regex = picomatch.toRegex(source, options);\n\t  if (returnState === true) {\n\t    regex.state = state;\n\t  }\n\n\t  return regex;\n\t};\n\n\t/**\n\t * Create a regular expression from a parsed glob pattern.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * const state = picomatch.parse('*.js');\n\t * // picomatch.compileRe(state[, options]);\n\t *\n\t * console.log(picomatch.compileRe(state));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `state` The object returned from the `.parse` method.\n\t * @param {Object} `options`\n\t * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.\n\t * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.\n\t * @return {RegExp} Returns a regex created from the given pattern.\n\t * @api public\n\t */\n\n\tpicomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n\t  if (!input || typeof input !== 'string') {\n\t    throw new TypeError('Expected a non-empty string');\n\t  }\n\n\t  let parsed = { negated: false, fastpaths: true };\n\n\t  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n\t    parsed.output = parse.fastpaths(input, options);\n\t  }\n\n\t  if (!parsed.output) {\n\t    parsed = parse(input, options);\n\t  }\n\n\t  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n\t};\n\n\t/**\n\t * Create a regular expression from the given regex source string.\n\t *\n\t * ```js\n\t * const picomatch = require('picomatch');\n\t * // picomatch.toRegex(source[, options]);\n\t *\n\t * const { output } = picomatch.parse('*.js');\n\t * console.log(picomatch.toRegex(output));\n\t * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n\t * ```\n\t * @param {String} `source` Regular expression source string.\n\t * @param {Object} `options`\n\t * @return {RegExp}\n\t * @api public\n\t */\n\n\tpicomatch.toRegex = (source, options) => {\n\t  try {\n\t    const opts = options || {};\n\t    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n\t  } catch (err) {\n\t    if (options && options.debug === true) throw err;\n\t    return /$^/;\n\t  }\n\t};\n\n\t/**\n\t * Picomatch constants.\n\t * @return {Object}\n\t */\n\n\tpicomatch.constants = constants;\n\n\t/**\n\t * Expose \"picomatch\"\n\t */\n\n\tpicomatch_1 = picomatch;\n\treturn picomatch_1;\n}\n\nvar picomatch;\nvar hasRequiredPicomatch;\n\nfunction requirePicomatch () {\n\tif (hasRequiredPicomatch) return picomatch;\n\thasRequiredPicomatch = 1;\n\n\tpicomatch = /*@__PURE__*/ requirePicomatch$1();\n\treturn picomatch;\n}\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath;\nvar hasRequiredNormalizePath;\n\nfunction requireNormalizePath () {\n\tif (hasRequiredNormalizePath) return normalizePath;\n\thasRequiredNormalizePath = 1;\n\tnormalizePath = function(path, stripTrailing) {\n\t  if (typeof path !== 'string') {\n\t    throw new TypeError('expected path to be a string');\n\t  }\n\n\t  if (path === '\\\\' || path === '/') return '/';\n\n\t  var len = path.length;\n\t  if (len <= 1) return path;\n\n\t  // ensure that win32 namespaces has two leading slashes, so that the path is\n\t  // handled properly by the win32 version of path.parse() after being normalized\n\t  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\t  var prefix = '';\n\t  if (len > 4 && path[3] === '\\\\') {\n\t    var ch = path[2];\n\t    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n\t      path = path.slice(2);\n\t      prefix = '//';\n\t    }\n\t  }\n\n\t  var segs = path.split(/[/\\\\]+/);\n\t  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n\t    segs.pop();\n\t  }\n\t  return prefix + segs.join('/');\n\t};\n\treturn normalizePath;\n}\n\nvar anymatch_1 = anymatch.exports;\n\nvar hasRequiredAnymatch;\n\nfunction requireAnymatch () {\n\tif (hasRequiredAnymatch) return anymatch.exports;\n\thasRequiredAnymatch = 1;\n\n\tObject.defineProperty(anymatch_1, \"__esModule\", { value: true });\n\n\tconst picomatch = /*@__PURE__*/ requirePicomatch();\n\tconst normalizePath = /*@__PURE__*/ requireNormalizePath();\n\n\t/**\n\t * @typedef {(testString: string) => boolean} AnymatchFn\n\t * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n\t * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n\t */\n\tconst BANG = '!';\n\tconst DEFAULT_OPTIONS = {returnIndex: false};\n\tconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n\t/**\n\t * @param {AnymatchPattern} matcher\n\t * @param {object} options\n\t * @returns {AnymatchFn}\n\t */\n\tconst createPattern = (matcher, options) => {\n\t  if (typeof matcher === 'function') {\n\t    return matcher;\n\t  }\n\t  if (typeof matcher === 'string') {\n\t    const glob = picomatch(matcher, options);\n\t    return (string) => matcher === string || glob(string);\n\t  }\n\t  if (matcher instanceof RegExp) {\n\t    return (string) => matcher.test(string);\n\t  }\n\t  return (string) => false;\n\t};\n\n\t/**\n\t * @param {Array<Function>} patterns\n\t * @param {Array<Function>} negPatterns\n\t * @param {String|Array} args\n\t * @param {Boolean} returnIndex\n\t * @returns {boolean|number}\n\t */\n\tconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n\t  const isList = Array.isArray(args);\n\t  const _path = isList ? args[0] : args;\n\t  if (!isList && typeof _path !== 'string') {\n\t    throw new TypeError('anymatch: second argument must be a string: got ' +\n\t      Object.prototype.toString.call(_path))\n\t  }\n\t  const path = normalizePath(_path, false);\n\n\t  for (let index = 0; index < negPatterns.length; index++) {\n\t    const nglob = negPatterns[index];\n\t    if (nglob(path)) {\n\t      return returnIndex ? -1 : false;\n\t    }\n\t  }\n\n\t  const applied = isList && [path].concat(args.slice(1));\n\t  for (let index = 0; index < patterns.length; index++) {\n\t    const pattern = patterns[index];\n\t    if (isList ? pattern(...applied) : pattern(path)) {\n\t      return returnIndex ? index : true;\n\t    }\n\t  }\n\n\t  return returnIndex ? -1 : false;\n\t};\n\n\t/**\n\t * @param {AnymatchMatcher} matchers\n\t * @param {Array|string} testString\n\t * @param {object} options\n\t * @returns {boolean|number|Function}\n\t */\n\tconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n\t  if (matchers == null) {\n\t    throw new TypeError('anymatch: specify first argument');\n\t  }\n\t  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n\t  const returnIndex = opts.returnIndex || false;\n\n\t  // Early cache for matchers.\n\t  const mtchers = arrify(matchers);\n\t  const negatedGlobs = mtchers\n\t    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n\t    .map(item => item.slice(1))\n\t    .map(item => picomatch(item, opts));\n\t  const patterns = mtchers\n\t    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG))\n\t    .map(matcher => createPattern(matcher, opts));\n\n\t  if (testString == null) {\n\t    return (testString, ri = false) => {\n\t      const returnIndex = typeof ri === 'boolean' ? ri : false;\n\t      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n\t    }\n\t  }\n\n\t  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n\t};\n\n\tanymatch$1.default = anymatch$1;\n\tanymatch.exports = anymatch$1;\n\treturn anymatch.exports;\n}\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob;\nvar hasRequiredIsExtglob;\n\nfunction requireIsExtglob () {\n\tif (hasRequiredIsExtglob) return isExtglob;\n\thasRequiredIsExtglob = 1;\n\tisExtglob = function isExtglob(str) {\n\t  if (typeof str !== 'string' || str === '') {\n\t    return false;\n\t  }\n\n\t  var match;\n\t  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n\t    if (match[2]) return true;\n\t    str = str.slice(match.index + match[0].length);\n\t  }\n\n\t  return false;\n\t};\n\treturn isExtglob;\n}\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isGlob;\nvar hasRequiredIsGlob;\n\nfunction requireIsGlob () {\n\tif (hasRequiredIsGlob) return isGlob;\n\thasRequiredIsGlob = 1;\n\tvar isExtglob = /*@__PURE__*/ requireIsExtglob();\n\tvar chars = { '{': '}', '(': ')', '[': ']'};\n\tvar strictCheck = function(str) {\n\t  if (str[0] === '!') {\n\t    return true;\n\t  }\n\t  var index = 0;\n\t  var pipeIndex = -2;\n\t  var closeSquareIndex = -2;\n\t  var closeCurlyIndex = -2;\n\t  var closeParenIndex = -2;\n\t  var backSlashIndex = -2;\n\t  while (index < str.length) {\n\t    if (str[index] === '*') {\n\t      return true;\n\t    }\n\n\t    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n\t      return true;\n\t    }\n\n\t    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n\t      if (closeSquareIndex < index) {\n\t        closeSquareIndex = str.indexOf(']', index);\n\t      }\n\t      if (closeSquareIndex > index) {\n\t        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n\t          return true;\n\t        }\n\t        backSlashIndex = str.indexOf('\\\\', index);\n\t        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\n\t    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n\t      closeCurlyIndex = str.indexOf('}', index);\n\t      if (closeCurlyIndex > index) {\n\t        backSlashIndex = str.indexOf('\\\\', index);\n\t        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\n\t    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n\t      closeParenIndex = str.indexOf(')', index);\n\t      if (closeParenIndex > index) {\n\t        backSlashIndex = str.indexOf('\\\\', index);\n\t        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n\t          return true;\n\t        }\n\t      }\n\t    }\n\n\t    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n\t      if (pipeIndex < index) {\n\t        pipeIndex = str.indexOf('|', index);\n\t      }\n\t      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n\t        closeParenIndex = str.indexOf(')', pipeIndex);\n\t        if (closeParenIndex > pipeIndex) {\n\t          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n\t          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n\t            return true;\n\t          }\n\t        }\n\t      }\n\t    }\n\n\t    if (str[index] === '\\\\') {\n\t      var open = str[index + 1];\n\t      index += 2;\n\t      var close = chars[open];\n\n\t      if (close) {\n\t        var n = str.indexOf(close, index);\n\t        if (n !== -1) {\n\t          index = n + 1;\n\t        }\n\t      }\n\n\t      if (str[index] === '!') {\n\t        return true;\n\t      }\n\t    } else {\n\t      index++;\n\t    }\n\t  }\n\t  return false;\n\t};\n\n\tvar relaxedCheck = function(str) {\n\t  if (str[0] === '!') {\n\t    return true;\n\t  }\n\t  var index = 0;\n\t  while (index < str.length) {\n\t    if (/[*?{}()[\\]]/.test(str[index])) {\n\t      return true;\n\t    }\n\n\t    if (str[index] === '\\\\') {\n\t      var open = str[index + 1];\n\t      index += 2;\n\t      var close = chars[open];\n\n\t      if (close) {\n\t        var n = str.indexOf(close, index);\n\t        if (n !== -1) {\n\t          index = n + 1;\n\t        }\n\t      }\n\n\t      if (str[index] === '!') {\n\t        return true;\n\t      }\n\t    } else {\n\t      index++;\n\t    }\n\t  }\n\t  return false;\n\t};\n\n\tisGlob = function isGlob(str, options) {\n\t  if (typeof str !== 'string' || str === '') {\n\t    return false;\n\t  }\n\n\t  if (isExtglob(str)) {\n\t    return true;\n\t  }\n\n\t  var check = strictCheck;\n\n\t  // optionally relax check\n\t  if (options && options.strict === false) {\n\t    check = relaxedCheck;\n\t  }\n\n\t  return check(str);\n\t};\n\treturn isGlob;\n}\n\nvar globParent;\nvar hasRequiredGlobParent;\n\nfunction requireGlobParent () {\n\tif (hasRequiredGlobParent) return globParent;\n\thasRequiredGlobParent = 1;\n\n\tvar isGlob = /*@__PURE__*/ requireIsGlob();\n\tvar pathPosixDirname = require$$0$1.posix.dirname;\n\tvar isWin32 = require$$2$1.platform() === 'win32';\n\n\tvar slash = '/';\n\tvar backslash = /\\\\/g;\n\tvar enclosure = /[\\{\\[].*[\\}\\]]$/;\n\tvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\n\tvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n\t/**\n\t * @param {string} str\n\t * @param {Object} opts\n\t * @param {boolean} [opts.flipBackslashes=true]\n\t * @returns {string}\n\t */\n\tglobParent = function globParent(str, opts) {\n\t  var options = Object.assign({ flipBackslashes: true }, opts);\n\n\t  // flip windows path separators\n\t  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n\t    str = str.replace(backslash, slash);\n\t  }\n\n\t  // special case for strings ending in enclosure containing path separator\n\t  if (enclosure.test(str)) {\n\t    str += slash;\n\t  }\n\n\t  // preserves full path in case of trailing path separator\n\t  str += 'a';\n\n\t  // remove path parts that are globby\n\t  do {\n\t    str = pathPosixDirname(str);\n\t  } while (isGlob(str) || globby.test(str));\n\n\t  // remove escape chars and return result\n\t  return str.replace(escaped, '$1');\n\t};\n\treturn globParent;\n}\n\nvar utils = {};\n\nvar hasRequiredUtils;\n\nfunction requireUtils () {\n\tif (hasRequiredUtils) return utils;\n\thasRequiredUtils = 1;\n\t(function (exports) {\n\n\t\texports.isInteger = num => {\n\t\t  if (typeof num === 'number') {\n\t\t    return Number.isInteger(num);\n\t\t  }\n\t\t  if (typeof num === 'string' && num.trim() !== '') {\n\t\t    return Number.isInteger(Number(num));\n\t\t  }\n\t\t  return false;\n\t\t};\n\n\t\t/**\n\t\t * Find a node of the given type\n\t\t */\n\n\t\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t\t/**\n\t\t * Find a node of the given type\n\t\t */\n\n\t\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t\t  if (limit === false) return false;\n\t\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t\t};\n\n\t\t/**\n\t\t * Escape the given node with '\\\\' before node.value\n\t\t */\n\n\t\texports.escapeNode = (block, n = 0, type) => {\n\t\t  const node = block.nodes[n];\n\t\t  if (!node) return;\n\n\t\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t\t    if (node.escaped !== true) {\n\t\t      node.value = '\\\\' + node.value;\n\t\t      node.escaped = true;\n\t\t    }\n\t\t  }\n\t\t};\n\n\t\t/**\n\t\t * Returns true if the given brace node should be enclosed in literal braces\n\t\t */\n\n\t\texports.encloseBrace = node => {\n\t\t  if (node.type !== 'brace') return false;\n\t\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t\t    node.invalid = true;\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t};\n\n\t\t/**\n\t\t * Returns true if a brace node is invalid.\n\t\t */\n\n\t\texports.isInvalidBrace = block => {\n\t\t  if (block.type !== 'brace') return false;\n\t\t  if (block.invalid === true || block.dollar) return true;\n\t\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t\t    block.invalid = true;\n\t\t    return true;\n\t\t  }\n\t\t  if (block.open !== true || block.close !== true) {\n\t\t    block.invalid = true;\n\t\t    return true;\n\t\t  }\n\t\t  return false;\n\t\t};\n\n\t\t/**\n\t\t * Returns true if a node is an open or close node\n\t\t */\n\n\t\texports.isOpenOrClose = node => {\n\t\t  if (node.type === 'open' || node.type === 'close') {\n\t\t    return true;\n\t\t  }\n\t\t  return node.open === true || node.close === true;\n\t\t};\n\n\t\t/**\n\t\t * Reduce an array of text nodes.\n\t\t */\n\n\t\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t\t  if (node.type === 'text') acc.push(node.value);\n\t\t  if (node.type === 'range') node.type = 'text';\n\t\t  return acc;\n\t\t}, []);\n\n\t\t/**\n\t\t * Flatten an array\n\t\t */\n\n\t\texports.flatten = (...args) => {\n\t\t  const result = [];\n\n\t\t  const flat = arr => {\n\t\t    for (let i = 0; i < arr.length; i++) {\n\t\t      const ele = arr[i];\n\n\t\t      if (Array.isArray(ele)) {\n\t\t        flat(ele);\n\t\t        continue;\n\t\t      }\n\n\t\t      if (ele !== undefined) {\n\t\t        result.push(ele);\n\t\t      }\n\t\t    }\n\t\t    return result;\n\t\t  };\n\n\t\t  flat(args);\n\t\t  return result;\n\t\t}; \n\t} (utils));\n\treturn utils;\n}\n\nvar stringify;\nvar hasRequiredStringify;\n\nfunction requireStringify () {\n\tif (hasRequiredStringify) return stringify;\n\thasRequiredStringify = 1;\n\n\tconst utils = /*@__PURE__*/ requireUtils();\n\n\tstringify = (ast, options = {}) => {\n\t  const stringify = (node, parent = {}) => {\n\t    const invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n\t    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n\t    let output = '';\n\n\t    if (node.value) {\n\t      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n\t        return '\\\\' + node.value;\n\t      }\n\t      return node.value;\n\t    }\n\n\t    if (node.value) {\n\t      return node.value;\n\t    }\n\n\t    if (node.nodes) {\n\t      for (const child of node.nodes) {\n\t        output += stringify(child);\n\t      }\n\t    }\n\t    return output;\n\t  };\n\n\t  return stringify(ast);\n\t};\n\treturn stringify;\n}\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber;\nvar hasRequiredIsNumber;\n\nfunction requireIsNumber () {\n\tif (hasRequiredIsNumber) return isNumber;\n\thasRequiredIsNumber = 1;\n\n\tisNumber = function(num) {\n\t  if (typeof num === 'number') {\n\t    return num - num === 0;\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n\t  }\n\t  return false;\n\t};\n\treturn isNumber;\n}\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar toRegexRange_1;\nvar hasRequiredToRegexRange;\n\nfunction requireToRegexRange () {\n\tif (hasRequiredToRegexRange) return toRegexRange_1;\n\thasRequiredToRegexRange = 1;\n\n\tconst isNumber = /*@__PURE__*/ requireIsNumber();\n\n\tconst toRegexRange = (min, max, options) => {\n\t  if (isNumber(min) === false) {\n\t    throw new TypeError('toRegexRange: expected the first argument to be a number');\n\t  }\n\n\t  if (max === void 0 || min === max) {\n\t    return String(min);\n\t  }\n\n\t  if (isNumber(max) === false) {\n\t    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n\t  }\n\n\t  let opts = { relaxZeros: true, ...options };\n\t  if (typeof opts.strictZeros === 'boolean') {\n\t    opts.relaxZeros = opts.strictZeros === false;\n\t  }\n\n\t  let relax = String(opts.relaxZeros);\n\t  let shorthand = String(opts.shorthand);\n\t  let capture = String(opts.capture);\n\t  let wrap = String(opts.wrap);\n\t  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n\t  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n\t    return toRegexRange.cache[cacheKey].result;\n\t  }\n\n\t  let a = Math.min(min, max);\n\t  let b = Math.max(min, max);\n\n\t  if (Math.abs(a - b) === 1) {\n\t    let result = min + '|' + max;\n\t    if (opts.capture) {\n\t      return `(${result})`;\n\t    }\n\t    if (opts.wrap === false) {\n\t      return result;\n\t    }\n\t    return `(?:${result})`;\n\t  }\n\n\t  let isPadded = hasPadding(min) || hasPadding(max);\n\t  let state = { min, max, a, b };\n\t  let positives = [];\n\t  let negatives = [];\n\n\t  if (isPadded) {\n\t    state.isPadded = isPadded;\n\t    state.maxLen = String(state.max).length;\n\t  }\n\n\t  if (a < 0) {\n\t    let newMin = b < 0 ? Math.abs(b) : 1;\n\t    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n\t    a = state.a = 0;\n\t  }\n\n\t  if (b >= 0) {\n\t    positives = splitToPatterns(a, b, state, opts);\n\t  }\n\n\t  state.negatives = negatives;\n\t  state.positives = positives;\n\t  state.result = collatePatterns(negatives, positives);\n\n\t  if (opts.capture === true) {\n\t    state.result = `(${state.result})`;\n\t  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n\t    state.result = `(?:${state.result})`;\n\t  }\n\n\t  toRegexRange.cache[cacheKey] = state;\n\t  return state.result;\n\t};\n\n\tfunction collatePatterns(neg, pos, options) {\n\t  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n\t  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n\t  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n\t  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n\t  return subpatterns.join('|');\n\t}\n\n\tfunction splitToRanges(min, max) {\n\t  let nines = 1;\n\t  let zeros = 1;\n\n\t  let stop = countNines(min, nines);\n\t  let stops = new Set([max]);\n\n\t  while (min <= stop && stop <= max) {\n\t    stops.add(stop);\n\t    nines += 1;\n\t    stop = countNines(min, nines);\n\t  }\n\n\t  stop = countZeros(max + 1, zeros) - 1;\n\n\t  while (min < stop && stop <= max) {\n\t    stops.add(stop);\n\t    zeros += 1;\n\t    stop = countZeros(max + 1, zeros) - 1;\n\t  }\n\n\t  stops = [...stops];\n\t  stops.sort(compare);\n\t  return stops;\n\t}\n\n\t/**\n\t * Convert a range to a regex pattern\n\t * @param {Number} `start`\n\t * @param {Number} `stop`\n\t * @return {String}\n\t */\n\n\tfunction rangeToPattern(start, stop, options) {\n\t  if (start === stop) {\n\t    return { pattern: start, count: [], digits: 0 };\n\t  }\n\n\t  let zipped = zip(start, stop);\n\t  let digits = zipped.length;\n\t  let pattern = '';\n\t  let count = 0;\n\n\t  for (let i = 0; i < digits; i++) {\n\t    let [startDigit, stopDigit] = zipped[i];\n\n\t    if (startDigit === stopDigit) {\n\t      pattern += startDigit;\n\n\t    } else if (startDigit !== '0' || stopDigit !== '9') {\n\t      pattern += toCharacterClass(startDigit, stopDigit);\n\n\t    } else {\n\t      count++;\n\t    }\n\t  }\n\n\t  if (count) {\n\t    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n\t  }\n\n\t  return { pattern, count: [count], digits };\n\t}\n\n\tfunction splitToPatterns(min, max, tok, options) {\n\t  let ranges = splitToRanges(min, max);\n\t  let tokens = [];\n\t  let start = min;\n\t  let prev;\n\n\t  for (let i = 0; i < ranges.length; i++) {\n\t    let max = ranges[i];\n\t    let obj = rangeToPattern(String(start), String(max), options);\n\t    let zeros = '';\n\n\t    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n\t      if (prev.count.length > 1) {\n\t        prev.count.pop();\n\t      }\n\n\t      prev.count.push(obj.count[0]);\n\t      prev.string = prev.pattern + toQuantifier(prev.count);\n\t      start = max + 1;\n\t      continue;\n\t    }\n\n\t    if (tok.isPadded) {\n\t      zeros = padZeros(max, tok, options);\n\t    }\n\n\t    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n\t    tokens.push(obj);\n\t    start = max + 1;\n\t    prev = obj;\n\t  }\n\n\t  return tokens;\n\t}\n\n\tfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n\t  let result = [];\n\n\t  for (let ele of arr) {\n\t    let { string } = ele;\n\n\t    // only push if _both_ are negative...\n\t    if (!intersection && !contains(comparison, 'string', string)) {\n\t      result.push(prefix + string);\n\t    }\n\n\t    // or _both_ are positive\n\t    if (intersection && contains(comparison, 'string', string)) {\n\t      result.push(prefix + string);\n\t    }\n\t  }\n\t  return result;\n\t}\n\n\t/**\n\t * Zip strings\n\t */\n\n\tfunction zip(a, b) {\n\t  let arr = [];\n\t  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\t  return arr;\n\t}\n\n\tfunction compare(a, b) {\n\t  return a > b ? 1 : b > a ? -1 : 0;\n\t}\n\n\tfunction contains(arr, key, val) {\n\t  return arr.some(ele => ele[key] === val);\n\t}\n\n\tfunction countNines(min, len) {\n\t  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n\t}\n\n\tfunction countZeros(integer, zeros) {\n\t  return integer - (integer % Math.pow(10, zeros));\n\t}\n\n\tfunction toQuantifier(digits) {\n\t  let [start = 0, stop = ''] = digits;\n\t  if (stop || start > 1) {\n\t    return `{${start + (stop ? ',' + stop : '')}}`;\n\t  }\n\t  return '';\n\t}\n\n\tfunction toCharacterClass(a, b, options) {\n\t  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n\t}\n\n\tfunction hasPadding(str) {\n\t  return /^-?(0+)\\d/.test(str);\n\t}\n\n\tfunction padZeros(value, tok, options) {\n\t  if (!tok.isPadded) {\n\t    return value;\n\t  }\n\n\t  let diff = Math.abs(tok.maxLen - String(value).length);\n\t  let relax = options.relaxZeros !== false;\n\n\t  switch (diff) {\n\t    case 0:\n\t      return '';\n\t    case 1:\n\t      return relax ? '0?' : '0';\n\t    case 2:\n\t      return relax ? '0{0,2}' : '00';\n\t    default: {\n\t      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Cache\n\t */\n\n\ttoRegexRange.cache = {};\n\ttoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n\t/**\n\t * Expose `toRegexRange`\n\t */\n\n\ttoRegexRange_1 = toRegexRange;\n\treturn toRegexRange_1;\n}\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar fillRange;\nvar hasRequiredFillRange;\n\nfunction requireFillRange () {\n\tif (hasRequiredFillRange) return fillRange;\n\thasRequiredFillRange = 1;\n\n\tconst util = require$$2;\n\tconst toRegexRange = /*@__PURE__*/ requireToRegexRange();\n\n\tconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\n\tconst transform = toNumber => {\n\t  return value => toNumber === true ? Number(value) : String(value);\n\t};\n\n\tconst isValidValue = value => {\n\t  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n\t};\n\n\tconst isNumber = num => Number.isInteger(+num);\n\n\tconst zeros = input => {\n\t  let value = `${input}`;\n\t  let index = -1;\n\t  if (value[0] === '-') value = value.slice(1);\n\t  if (value === '0') return false;\n\t  while (value[++index] === '0');\n\t  return index > 0;\n\t};\n\n\tconst stringify = (start, end, options) => {\n\t  if (typeof start === 'string' || typeof end === 'string') {\n\t    return true;\n\t  }\n\t  return options.stringify === true;\n\t};\n\n\tconst pad = (input, maxLength, toNumber) => {\n\t  if (maxLength > 0) {\n\t    let dash = input[0] === '-' ? '-' : '';\n\t    if (dash) input = input.slice(1);\n\t    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n\t  }\n\t  if (toNumber === false) {\n\t    return String(input);\n\t  }\n\t  return input;\n\t};\n\n\tconst toMaxLen = (input, maxLength) => {\n\t  let negative = input[0] === '-' ? '-' : '';\n\t  if (negative) {\n\t    input = input.slice(1);\n\t    maxLength--;\n\t  }\n\t  while (input.length < maxLength) input = '0' + input;\n\t  return negative ? ('-' + input) : input;\n\t};\n\n\tconst toSequence = (parts, options, maxLen) => {\n\t  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\t  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n\t  let prefix = options.capture ? '' : '?:';\n\t  let positives = '';\n\t  let negatives = '';\n\t  let result;\n\n\t  if (parts.positives.length) {\n\t    positives = parts.positives.map(v => toMaxLen(String(v), maxLen)).join('|');\n\t  }\n\n\t  if (parts.negatives.length) {\n\t    negatives = `-(${prefix}${parts.negatives.map(v => toMaxLen(String(v), maxLen)).join('|')})`;\n\t  }\n\n\t  if (positives && negatives) {\n\t    result = `${positives}|${negatives}`;\n\t  } else {\n\t    result = positives || negatives;\n\t  }\n\n\t  if (options.wrap) {\n\t    return `(${prefix}${result})`;\n\t  }\n\n\t  return result;\n\t};\n\n\tconst toRange = (a, b, isNumbers, options) => {\n\t  if (isNumbers) {\n\t    return toRegexRange(a, b, { wrap: false, ...options });\n\t  }\n\n\t  let start = String.fromCharCode(a);\n\t  if (a === b) return start;\n\n\t  let stop = String.fromCharCode(b);\n\t  return `[${start}-${stop}]`;\n\t};\n\n\tconst toRegex = (start, end, options) => {\n\t  if (Array.isArray(start)) {\n\t    let wrap = options.wrap === true;\n\t    let prefix = options.capture ? '' : '?:';\n\t    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n\t  }\n\t  return toRegexRange(start, end, options);\n\t};\n\n\tconst rangeError = (...args) => {\n\t  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n\t};\n\n\tconst invalidRange = (start, end, options) => {\n\t  if (options.strictRanges === true) throw rangeError([start, end]);\n\t  return [];\n\t};\n\n\tconst invalidStep = (step, options) => {\n\t  if (options.strictRanges === true) {\n\t    throw new TypeError(`Expected step \"${step}\" to be a number`);\n\t  }\n\t  return [];\n\t};\n\n\tconst fillNumbers = (start, end, step = 1, options = {}) => {\n\t  let a = Number(start);\n\t  let b = Number(end);\n\n\t  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n\t    if (options.strictRanges === true) throw rangeError([start, end]);\n\t    return [];\n\t  }\n\n\t  // fix negative zero\n\t  if (a === 0) a = 0;\n\t  if (b === 0) b = 0;\n\n\t  let descending = a > b;\n\t  let startString = String(start);\n\t  let endString = String(end);\n\t  let stepString = String(step);\n\t  step = Math.max(Math.abs(step), 1);\n\n\t  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n\t  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n\t  let toNumber = padded === false && stringify(start, end, options) === false;\n\t  let format = options.transform || transform(toNumber);\n\n\t  if (options.toRegex && step === 1) {\n\t    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n\t  }\n\n\t  let parts = { negatives: [], positives: [] };\n\t  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\t  let range = [];\n\t  let index = 0;\n\n\t  while (descending ? a >= b : a <= b) {\n\t    if (options.toRegex === true && step > 1) {\n\t      push(a);\n\t    } else {\n\t      range.push(pad(format(a, index), maxLen, toNumber));\n\t    }\n\t    a = descending ? a - step : a + step;\n\t    index++;\n\t  }\n\n\t  if (options.toRegex === true) {\n\t    return step > 1\n\t      ? toSequence(parts, options, maxLen)\n\t      : toRegex(range, null, { wrap: false, ...options });\n\t  }\n\n\t  return range;\n\t};\n\n\tconst fillLetters = (start, end, step = 1, options = {}) => {\n\t  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n\t    return invalidRange(start, end, options);\n\t  }\n\n\t  let format = options.transform || (val => String.fromCharCode(val));\n\t  let a = `${start}`.charCodeAt(0);\n\t  let b = `${end}`.charCodeAt(0);\n\n\t  let descending = a > b;\n\t  let min = Math.min(a, b);\n\t  let max = Math.max(a, b);\n\n\t  if (options.toRegex && step === 1) {\n\t    return toRange(min, max, false, options);\n\t  }\n\n\t  let range = [];\n\t  let index = 0;\n\n\t  while (descending ? a >= b : a <= b) {\n\t    range.push(format(a, index));\n\t    a = descending ? a - step : a + step;\n\t    index++;\n\t  }\n\n\t  if (options.toRegex === true) {\n\t    return toRegex(range, null, { wrap: false, options });\n\t  }\n\n\t  return range;\n\t};\n\n\tconst fill = (start, end, step, options = {}) => {\n\t  if (end == null && isValidValue(start)) {\n\t    return [start];\n\t  }\n\n\t  if (!isValidValue(start) || !isValidValue(end)) {\n\t    return invalidRange(start, end, options);\n\t  }\n\n\t  if (typeof step === 'function') {\n\t    return fill(start, end, 1, { transform: step });\n\t  }\n\n\t  if (isObject(step)) {\n\t    return fill(start, end, 0, step);\n\t  }\n\n\t  let opts = { ...options };\n\t  if (opts.capture === true) opts.wrap = true;\n\t  step = step || opts.step || 1;\n\n\t  if (!isNumber(step)) {\n\t    if (step != null && !isObject(step)) return invalidStep(step, opts);\n\t    return fill(start, end, 1, step);\n\t  }\n\n\t  if (isNumber(start) && isNumber(end)) {\n\t    return fillNumbers(start, end, step, opts);\n\t  }\n\n\t  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n\t};\n\n\tfillRange = fill;\n\treturn fillRange;\n}\n\nvar compile_1;\nvar hasRequiredCompile;\n\nfunction requireCompile () {\n\tif (hasRequiredCompile) return compile_1;\n\thasRequiredCompile = 1;\n\n\tconst fill = /*@__PURE__*/ requireFillRange();\n\tconst utils = /*@__PURE__*/ requireUtils();\n\n\tconst compile = (ast, options = {}) => {\n\t  const walk = (node, parent = {}) => {\n\t    const invalidBlock = utils.isInvalidBrace(parent);\n\t    const invalidNode = node.invalid === true && options.escapeInvalid === true;\n\t    const invalid = invalidBlock === true || invalidNode === true;\n\t    const prefix = options.escapeInvalid === true ? '\\\\' : '';\n\t    let output = '';\n\n\t    if (node.isOpen === true) {\n\t      return prefix + node.value;\n\t    }\n\n\t    if (node.isClose === true) {\n\t      console.log('node.isClose', prefix, node.value);\n\t      return prefix + node.value;\n\t    }\n\n\t    if (node.type === 'open') {\n\t      return invalid ? prefix + node.value : '(';\n\t    }\n\n\t    if (node.type === 'close') {\n\t      return invalid ? prefix + node.value : ')';\n\t    }\n\n\t    if (node.type === 'comma') {\n\t      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n\t    }\n\n\t    if (node.value) {\n\t      return node.value;\n\t    }\n\n\t    if (node.nodes && node.ranges > 0) {\n\t      const args = utils.reduce(node.nodes);\n\t      const range = fill(...args, { ...options, wrap: false, toRegex: true, strictZeros: true });\n\n\t      if (range.length !== 0) {\n\t        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n\t      }\n\t    }\n\n\t    if (node.nodes) {\n\t      for (const child of node.nodes) {\n\t        output += walk(child, node);\n\t      }\n\t    }\n\n\t    return output;\n\t  };\n\n\t  return walk(ast);\n\t};\n\n\tcompile_1 = compile;\n\treturn compile_1;\n}\n\nvar expand_1;\nvar hasRequiredExpand;\n\nfunction requireExpand () {\n\tif (hasRequiredExpand) return expand_1;\n\thasRequiredExpand = 1;\n\n\tconst fill = /*@__PURE__*/ requireFillRange();\n\tconst stringify = /*@__PURE__*/ requireStringify();\n\tconst utils = /*@__PURE__*/ requireUtils();\n\n\tconst append = (queue = '', stash = '', enclose = false) => {\n\t  const result = [];\n\n\t  queue = [].concat(queue);\n\t  stash = [].concat(stash);\n\n\t  if (!stash.length) return queue;\n\t  if (!queue.length) {\n\t    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n\t  }\n\n\t  for (const item of queue) {\n\t    if (Array.isArray(item)) {\n\t      for (const value of item) {\n\t        result.push(append(value, stash, enclose));\n\t      }\n\t    } else {\n\t      for (let ele of stash) {\n\t        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n\t        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n\t      }\n\t    }\n\t  }\n\t  return utils.flatten(result);\n\t};\n\n\tconst expand = (ast, options = {}) => {\n\t  const rangeLimit = options.rangeLimit === undefined ? 1000 : options.rangeLimit;\n\n\t  const walk = (node, parent = {}) => {\n\t    node.queue = [];\n\n\t    let p = parent;\n\t    let q = parent.queue;\n\n\t    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n\t      p = p.parent;\n\t      q = p.queue;\n\t    }\n\n\t    if (node.invalid || node.dollar) {\n\t      q.push(append(q.pop(), stringify(node, options)));\n\t      return;\n\t    }\n\n\t    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n\t      q.push(append(q.pop(), ['{}']));\n\t      return;\n\t    }\n\n\t    if (node.nodes && node.ranges > 0) {\n\t      const args = utils.reduce(node.nodes);\n\n\t      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n\t        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n\t      }\n\n\t      let range = fill(...args, options);\n\t      if (range.length === 0) {\n\t        range = stringify(node, options);\n\t      }\n\n\t      q.push(append(q.pop(), range));\n\t      node.nodes = [];\n\t      return;\n\t    }\n\n\t    const enclose = utils.encloseBrace(node);\n\t    let queue = node.queue;\n\t    let block = node;\n\n\t    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n\t      block = block.parent;\n\t      queue = block.queue;\n\t    }\n\n\t    for (let i = 0; i < node.nodes.length; i++) {\n\t      const child = node.nodes[i];\n\n\t      if (child.type === 'comma' && node.type === 'brace') {\n\t        if (i === 1) queue.push('');\n\t        queue.push('');\n\t        continue;\n\t      }\n\n\t      if (child.type === 'close') {\n\t        q.push(append(q.pop(), queue, enclose));\n\t        continue;\n\t      }\n\n\t      if (child.value && child.type !== 'open') {\n\t        queue.push(append(queue.pop(), child.value));\n\t        continue;\n\t      }\n\n\t      if (child.nodes) {\n\t        walk(child, node);\n\t      }\n\t    }\n\n\t    return queue;\n\t  };\n\n\t  return utils.flatten(walk(ast));\n\t};\n\n\texpand_1 = expand;\n\treturn expand_1;\n}\n\nvar constants$1;\nvar hasRequiredConstants$1;\n\nfunction requireConstants$1 () {\n\tif (hasRequiredConstants$1) return constants$1;\n\thasRequiredConstants$1 = 1;\n\n\tconstants$1 = {\n\t  MAX_LENGTH: 10000,\n\n\t  // Digits\n\t  CHAR_0: '0', /* 0 */\n\t  CHAR_9: '9', /* 9 */\n\n\t  // Alphabet chars.\n\t  CHAR_UPPERCASE_A: 'A', /* A */\n\t  CHAR_LOWERCASE_A: 'a', /* a */\n\t  CHAR_UPPERCASE_Z: 'Z', /* Z */\n\t  CHAR_LOWERCASE_Z: 'z', /* z */\n\n\t  CHAR_LEFT_PARENTHESES: '(', /* ( */\n\t  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n\t  CHAR_ASTERISK: '*', /* * */\n\n\t  // Non-alphabetic chars.\n\t  CHAR_AMPERSAND: '&', /* & */\n\t  CHAR_AT: '@', /* @ */\n\t  CHAR_BACKSLASH: '\\\\', /* \\ */\n\t  CHAR_BACKTICK: '`', /* ` */\n\t  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n\t  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n\t  CHAR_COLON: ':', /* : */\n\t  CHAR_COMMA: ',', /* , */\n\t  CHAR_DOLLAR: '$', /* . */\n\t  CHAR_DOT: '.', /* . */\n\t  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n\t  CHAR_EQUAL: '=', /* = */\n\t  CHAR_EXCLAMATION_MARK: '!', /* ! */\n\t  CHAR_FORM_FEED: '\\f', /* \\f */\n\t  CHAR_FORWARD_SLASH: '/', /* / */\n\t  CHAR_HASH: '#', /* # */\n\t  CHAR_HYPHEN_MINUS: '-', /* - */\n\t  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n\t  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n\t  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n\t  CHAR_LINE_FEED: '\\n', /* \\n */\n\t  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n\t  CHAR_PERCENT: '%', /* % */\n\t  CHAR_PLUS: '+', /* + */\n\t  CHAR_QUESTION_MARK: '?', /* ? */\n\t  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n\t  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n\t  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n\t  CHAR_SEMICOLON: ';', /* ; */\n\t  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n\t  CHAR_SPACE: ' ', /*   */\n\t  CHAR_TAB: '\\t', /* \\t */\n\t  CHAR_UNDERSCORE: '_', /* _ */\n\t  CHAR_VERTICAL_LINE: '|', /* | */\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n\t};\n\treturn constants$1;\n}\n\nvar parse_1;\nvar hasRequiredParse;\n\nfunction requireParse () {\n\tif (hasRequiredParse) return parse_1;\n\thasRequiredParse = 1;\n\n\tconst stringify = /*@__PURE__*/ requireStringify();\n\n\t/**\n\t * Constants\n\t */\n\n\tconst {\n\t  MAX_LENGTH,\n\t  CHAR_BACKSLASH, /* \\ */\n\t  CHAR_BACKTICK, /* ` */\n\t  CHAR_COMMA, /* , */\n\t  CHAR_DOT, /* . */\n\t  CHAR_LEFT_PARENTHESES, /* ( */\n\t  CHAR_RIGHT_PARENTHESES, /* ) */\n\t  CHAR_LEFT_CURLY_BRACE, /* { */\n\t  CHAR_RIGHT_CURLY_BRACE, /* } */\n\t  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n\t  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n\t  CHAR_DOUBLE_QUOTE, /* \" */\n\t  CHAR_SINGLE_QUOTE, /* ' */\n\t  CHAR_NO_BREAK_SPACE,\n\t  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n\t} = /*@__PURE__*/ requireConstants$1();\n\n\t/**\n\t * parse\n\t */\n\n\tconst parse = (input, options = {}) => {\n\t  if (typeof input !== 'string') {\n\t    throw new TypeError('Expected a string');\n\t  }\n\n\t  const opts = options || {};\n\t  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\t  if (input.length > max) {\n\t    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n\t  }\n\n\t  const ast = { type: 'root', input, nodes: [] };\n\t  const stack = [ast];\n\t  let block = ast;\n\t  let prev = ast;\n\t  let brackets = 0;\n\t  const length = input.length;\n\t  let index = 0;\n\t  let depth = 0;\n\t  let value;\n\n\t  /**\n\t   * Helpers\n\t   */\n\n\t  const advance = () => input[index++];\n\t  const push = node => {\n\t    if (node.type === 'text' && prev.type === 'dot') {\n\t      prev.type = 'text';\n\t    }\n\n\t    if (prev && prev.type === 'text' && node.type === 'text') {\n\t      prev.value += node.value;\n\t      return;\n\t    }\n\n\t    block.nodes.push(node);\n\t    node.parent = block;\n\t    node.prev = prev;\n\t    prev = node;\n\t    return node;\n\t  };\n\n\t  push({ type: 'bos' });\n\n\t  while (index < length) {\n\t    block = stack[stack.length - 1];\n\t    value = advance();\n\n\t    /**\n\t     * Invalid chars\n\t     */\n\n\t    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Escaped chars\n\t     */\n\n\t    if (value === CHAR_BACKSLASH) {\n\t      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Right square bracket (literal): ']'\n\t     */\n\n\t    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n\t      push({ type: 'text', value: '\\\\' + value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Left square bracket: '['\n\t     */\n\n\t    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n\t      brackets++;\n\n\t      let next;\n\n\t      while (index < length && (next = advance())) {\n\t        value += next;\n\n\t        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n\t          brackets++;\n\t          continue;\n\t        }\n\n\t        if (next === CHAR_BACKSLASH) {\n\t          value += advance();\n\t          continue;\n\t        }\n\n\t        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n\t          brackets--;\n\n\t          if (brackets === 0) {\n\t            break;\n\t          }\n\t        }\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Parentheses\n\t     */\n\n\t    if (value === CHAR_LEFT_PARENTHESES) {\n\t      block = push({ type: 'paren', nodes: [] });\n\t      stack.push(block);\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    if (value === CHAR_RIGHT_PARENTHESES) {\n\t      if (block.type !== 'paren') {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\t      block = stack.pop();\n\t      push({ type: 'text', value });\n\t      block = stack[stack.length - 1];\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Quotes: '|\"|`\n\t     */\n\n\t    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n\t      const open = value;\n\t      let next;\n\n\t      if (options.keepQuotes !== true) {\n\t        value = '';\n\t      }\n\n\t      while (index < length && (next = advance())) {\n\t        if (next === CHAR_BACKSLASH) {\n\t          value += next + advance();\n\t          continue;\n\t        }\n\n\t        if (next === open) {\n\t          if (options.keepQuotes === true) value += next;\n\t          break;\n\t        }\n\n\t        value += next;\n\t      }\n\n\t      push({ type: 'text', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Left curly brace: '{'\n\t     */\n\n\t    if (value === CHAR_LEFT_CURLY_BRACE) {\n\t      depth++;\n\n\t      const dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n\t      const brace = {\n\t        type: 'brace',\n\t        open: true,\n\t        close: false,\n\t        dollar,\n\t        depth,\n\t        commas: 0,\n\t        ranges: 0,\n\t        nodes: []\n\t      };\n\n\t      block = push(brace);\n\t      stack.push(block);\n\t      push({ type: 'open', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Right curly brace: '}'\n\t     */\n\n\t    if (value === CHAR_RIGHT_CURLY_BRACE) {\n\t      if (block.type !== 'brace') {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\n\t      const type = 'close';\n\t      block = stack.pop();\n\t      block.close = true;\n\n\t      push({ type, value });\n\t      depth--;\n\n\t      block = stack[stack.length - 1];\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Comma: ','\n\t     */\n\n\t    if (value === CHAR_COMMA && depth > 0) {\n\t      if (block.ranges > 0) {\n\t        block.ranges = 0;\n\t        const open = block.nodes.shift();\n\t        block.nodes = [open, { type: 'text', value: stringify(block) }];\n\t      }\n\n\t      push({ type: 'comma', value });\n\t      block.commas++;\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Dot: '.'\n\t     */\n\n\t    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n\t      const siblings = block.nodes;\n\n\t      if (depth === 0 || siblings.length === 0) {\n\t        push({ type: 'text', value });\n\t        continue;\n\t      }\n\n\t      if (prev.type === 'dot') {\n\t        block.range = [];\n\t        prev.value += value;\n\t        prev.type = 'range';\n\n\t        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n\t          block.invalid = true;\n\t          block.ranges = 0;\n\t          prev.type = 'text';\n\t          continue;\n\t        }\n\n\t        block.ranges++;\n\t        block.args = [];\n\t        continue;\n\t      }\n\n\t      if (prev.type === 'range') {\n\t        siblings.pop();\n\n\t        const before = siblings[siblings.length - 1];\n\t        before.value += prev.value + value;\n\t        prev = before;\n\t        block.ranges--;\n\t        continue;\n\t      }\n\n\t      push({ type: 'dot', value });\n\t      continue;\n\t    }\n\n\t    /**\n\t     * Text\n\t     */\n\n\t    push({ type: 'text', value });\n\t  }\n\n\t  // Mark imbalanced braces and brackets as invalid\n\t  do {\n\t    block = stack.pop();\n\n\t    if (block.type !== 'root') {\n\t      block.nodes.forEach(node => {\n\t        if (!node.nodes) {\n\t          if (node.type === 'open') node.isOpen = true;\n\t          if (node.type === 'close') node.isClose = true;\n\t          if (!node.nodes) node.type = 'text';\n\t          node.invalid = true;\n\t        }\n\t      });\n\n\t      // get the location of the block on parent.nodes (block's siblings)\n\t      const parent = stack[stack.length - 1];\n\t      const index = parent.nodes.indexOf(block);\n\t      // replace the (invalid) block with it's nodes\n\t      parent.nodes.splice(index, 1, ...block.nodes);\n\t    }\n\t  } while (stack.length > 0);\n\n\t  push({ type: 'eos' });\n\t  return ast;\n\t};\n\n\tparse_1 = parse;\n\treturn parse_1;\n}\n\nvar braces_1;\nvar hasRequiredBraces;\n\nfunction requireBraces () {\n\tif (hasRequiredBraces) return braces_1;\n\thasRequiredBraces = 1;\n\n\tconst stringify = /*@__PURE__*/ requireStringify();\n\tconst compile = /*@__PURE__*/ requireCompile();\n\tconst expand = /*@__PURE__*/ requireExpand();\n\tconst parse = /*@__PURE__*/ requireParse();\n\n\t/**\n\t * Expand the given pattern or create a regex-compatible string.\n\t *\n\t * ```js\n\t * const braces = require('braces');\n\t * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n\t * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n\t * ```\n\t * @param {String} `str`\n\t * @param {Object} `options`\n\t * @return {String}\n\t * @api public\n\t */\n\n\tconst braces = (input, options = {}) => {\n\t  let output = [];\n\n\t  if (Array.isArray(input)) {\n\t    for (const pattern of input) {\n\t      const result = braces.create(pattern, options);\n\t      if (Array.isArray(result)) {\n\t        output.push(...result);\n\t      } else {\n\t        output.push(result);\n\t      }\n\t    }\n\t  } else {\n\t    output = [].concat(braces.create(input, options));\n\t  }\n\n\t  if (options && options.expand === true && options.nodupes === true) {\n\t    output = [...new Set(output)];\n\t  }\n\t  return output;\n\t};\n\n\t/**\n\t * Parse the given `str` with the given `options`.\n\t *\n\t * ```js\n\t * // braces.parse(pattern, [, options]);\n\t * const ast = braces.parse('a/{b,c}/d');\n\t * console.log(ast);\n\t * ```\n\t * @param {String} pattern Brace pattern to parse\n\t * @param {Object} options\n\t * @return {Object} Returns an AST\n\t * @api public\n\t */\n\n\tbraces.parse = (input, options = {}) => parse(input, options);\n\n\t/**\n\t * Creates a braces string from an AST, or an AST node.\n\t *\n\t * ```js\n\t * const braces = require('braces');\n\t * let ast = braces.parse('foo/{a,b}/bar');\n\t * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n\t * ```\n\t * @param {String} `input` Brace pattern or AST.\n\t * @param {Object} `options`\n\t * @return {Array} Returns an array of expanded values.\n\t * @api public\n\t */\n\n\tbraces.stringify = (input, options = {}) => {\n\t  if (typeof input === 'string') {\n\t    return stringify(braces.parse(input, options), options);\n\t  }\n\t  return stringify(input, options);\n\t};\n\n\t/**\n\t * Compiles a brace pattern into a regex-compatible, optimized string.\n\t * This method is called by the main [braces](#braces) function by default.\n\t *\n\t * ```js\n\t * const braces = require('braces');\n\t * console.log(braces.compile('a/{b,c}/d'));\n\t * //=> ['a/(b|c)/d']\n\t * ```\n\t * @param {String} `input` Brace pattern or AST.\n\t * @param {Object} `options`\n\t * @return {Array} Returns an array of expanded values.\n\t * @api public\n\t */\n\n\tbraces.compile = (input, options = {}) => {\n\t  if (typeof input === 'string') {\n\t    input = braces.parse(input, options);\n\t  }\n\t  return compile(input, options);\n\t};\n\n\t/**\n\t * Expands a brace pattern into an array. This method is called by the\n\t * main [braces](#braces) function when `options.expand` is true. Before\n\t * using this method it's recommended that you read the [performance notes](#performance))\n\t * and advantages of using [.compile](#compile) instead.\n\t *\n\t * ```js\n\t * const braces = require('braces');\n\t * console.log(braces.expand('a/{b,c}/d'));\n\t * //=> ['a/b/d', 'a/c/d'];\n\t * ```\n\t * @param {String} `pattern` Brace pattern\n\t * @param {Object} `options`\n\t * @return {Array} Returns an array of expanded values.\n\t * @api public\n\t */\n\n\tbraces.expand = (input, options = {}) => {\n\t  if (typeof input === 'string') {\n\t    input = braces.parse(input, options);\n\t  }\n\n\t  let result = expand(input, options);\n\n\t  // filter out empty strings if specified\n\t  if (options.noempty === true) {\n\t    result = result.filter(Boolean);\n\t  }\n\n\t  // filter out duplicates if specified\n\t  if (options.nodupes === true) {\n\t    result = [...new Set(result)];\n\t  }\n\n\t  return result;\n\t};\n\n\t/**\n\t * Processes a brace pattern and returns either an expanded array\n\t * (if `options.expand` is true), a highly optimized regex-compatible string.\n\t * This method is called by the main [braces](#braces) function.\n\t *\n\t * ```js\n\t * const braces = require('braces');\n\t * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n\t * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n\t * ```\n\t * @param {String} `pattern` Brace pattern\n\t * @param {Object} `options`\n\t * @return {Array} Returns an array of expanded values.\n\t * @api public\n\t */\n\n\tbraces.create = (input, options = {}) => {\n\t  if (input === '' || input.length < 3) {\n\t    return [input];\n\t  }\n\n\t  return options.expand !== true\n\t    ? braces.compile(input, options)\n\t    : braces.expand(input, options);\n\t};\n\n\t/**\n\t * Expose \"braces\"\n\t */\n\n\tbraces_1 = braces;\n\treturn braces_1;\n}\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"afdesign\",\n\t\"afphoto\",\n\t\"afpub\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\nvar binaryExtensions;\nvar hasRequiredBinaryExtensions;\n\nfunction requireBinaryExtensions () {\n\tif (hasRequiredBinaryExtensions) return binaryExtensions;\n\thasRequiredBinaryExtensions = 1;\n\tbinaryExtensions = require$$0;\n\treturn binaryExtensions;\n}\n\nvar isBinaryPath;\nvar hasRequiredIsBinaryPath;\n\nfunction requireIsBinaryPath () {\n\tif (hasRequiredIsBinaryPath) return isBinaryPath;\n\thasRequiredIsBinaryPath = 1;\n\tconst path = require$$0$1;\n\tconst binaryExtensions = /*@__PURE__*/ requireBinaryExtensions();\n\n\tconst extensions = new Set(binaryExtensions);\n\n\tisBinaryPath = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\treturn isBinaryPath;\n}\n\nvar constants = {};\n\nvar hasRequiredConstants;\n\nfunction requireConstants () {\n\tif (hasRequiredConstants) return constants;\n\thasRequiredConstants = 1;\n\t(function (exports) {\n\n\t\tconst {sep} = require$$0$1;\n\t\tconst {platform} = process;\n\t\tconst os = require$$2$1;\n\n\t\texports.EV_ALL = 'all';\n\t\texports.EV_READY = 'ready';\n\t\texports.EV_ADD = 'add';\n\t\texports.EV_CHANGE = 'change';\n\t\texports.EV_ADD_DIR = 'addDir';\n\t\texports.EV_UNLINK = 'unlink';\n\t\texports.EV_UNLINK_DIR = 'unlinkDir';\n\t\texports.EV_RAW = 'raw';\n\t\texports.EV_ERROR = 'error';\n\n\t\texports.STR_DATA = 'data';\n\t\texports.STR_END = 'end';\n\t\texports.STR_CLOSE = 'close';\n\n\t\texports.FSEVENT_CREATED = 'created';\n\t\texports.FSEVENT_MODIFIED = 'modified';\n\t\texports.FSEVENT_DELETED = 'deleted';\n\t\texports.FSEVENT_MOVED = 'moved';\n\t\texports.FSEVENT_CLONED = 'cloned';\n\t\texports.FSEVENT_UNKNOWN = 'unknown';\n\t\texports.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;\n\t\texports.FSEVENT_TYPE_FILE = 'file';\n\t\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\t\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\t\texports.KEY_LISTENERS = 'listeners';\n\t\texports.KEY_ERR = 'errHandlers';\n\t\texports.KEY_RAW = 'rawEmitters';\n\t\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\t\texports.DOT_SLASH = `.${sep}`;\n\n\t\texports.BACK_SLASH_RE = /\\\\/g;\n\t\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\t\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\t\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\t\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\t\texports.SLASH = '/';\n\t\texports.SLASH_SLASH = '//';\n\t\texports.BRACE_START = '{';\n\t\texports.BANG = '!';\n\t\texports.ONE_DOT = '.';\n\t\texports.TWO_DOTS = '..';\n\t\texports.STAR = '*';\n\t\texports.GLOBSTAR = '**';\n\t\texports.ROOT_GLOBSTAR = '/**/*';\n\t\texports.SLASH_GLOBSTAR = '/**';\n\t\texports.DIR_SUFFIX = 'Dir';\n\t\texports.ANYMATCH_OPTS = {dot: true};\n\t\texports.STRING_TYPE = 'string';\n\t\texports.FUNCTION_TYPE = 'function';\n\t\texports.EMPTY_STR = '';\n\t\texports.EMPTY_FN = () => {};\n\t\texports.IDENTITY_FN = val => val;\n\n\t\texports.isWindows = platform === 'win32';\n\t\texports.isMacos = platform === 'darwin';\n\t\texports.isLinux = platform === 'linux';\n\t\texports.isIBMi = os.type() === 'OS400'; \n\t} (constants));\n\treturn constants;\n}\n\nvar nodefsHandler;\nvar hasRequiredNodefsHandler;\n\nfunction requireNodefsHandler () {\n\tif (hasRequiredNodefsHandler) return nodefsHandler;\n\thasRequiredNodefsHandler = 1;\n\n\tconst fs = require$$0$2;\n\tconst sysPath = require$$0$1;\n\tconst { promisify } = require$$2;\n\tconst isBinaryPath = /*@__PURE__*/ requireIsBinaryPath();\n\tconst {\n\t  isWindows,\n\t  isLinux,\n\t  EMPTY_FN,\n\t  EMPTY_STR,\n\t  KEY_LISTENERS,\n\t  KEY_ERR,\n\t  KEY_RAW,\n\t  HANDLER_KEYS,\n\t  EV_CHANGE,\n\t  EV_ADD,\n\t  EV_ADD_DIR,\n\t  EV_ERROR,\n\t  STR_DATA,\n\t  STR_END,\n\t  BRACE_START,\n\t  STAR\n\t} = /*@__PURE__*/ requireConstants();\n\n\tconst THROTTLE_MODE_WATCH = 'watch';\n\n\tconst open = promisify(fs.open);\n\tconst stat = promisify(fs.stat);\n\tconst lstat = promisify(fs.lstat);\n\tconst close = promisify(fs.close);\n\tconst fsrealpath = promisify(fs.realpath);\n\n\tconst statMethods = { lstat, stat };\n\n\t// TODO: emit errors properly. Example: EMFILE on Macos.\n\tconst foreach = (val, fn) => {\n\t  if (val instanceof Set) {\n\t    val.forEach(fn);\n\t  } else {\n\t    fn(val);\n\t  }\n\t};\n\n\tconst addAndConvert = (main, prop, item) => {\n\t  let container = main[prop];\n\t  if (!(container instanceof Set)) {\n\t    main[prop] = container = new Set([container]);\n\t  }\n\t  container.add(item);\n\t};\n\n\tconst clearItem = cont => key => {\n\t  const set = cont[key];\n\t  if (set instanceof Set) {\n\t    set.clear();\n\t  } else {\n\t    delete cont[key];\n\t  }\n\t};\n\n\tconst delFromSet = (main, prop, item) => {\n\t  const container = main[prop];\n\t  if (container instanceof Set) {\n\t    container.delete(item);\n\t  } else if (container === item) {\n\t    delete main[prop];\n\t  }\n\t};\n\n\tconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n\t/**\n\t * @typedef {String} Path\n\t */\n\n\t// fs_watch helpers\n\n\t// object to hold per-process fs_watch instances\n\t// (may be shared across chokidar FSWatcher instances)\n\n\t/**\n\t * @typedef {Object} FsWatchContainer\n\t * @property {Set} listeners\n\t * @property {Set} errHandlers\n\t * @property {Set} rawEmitters\n\t * @property {fs.FSWatcher=} watcher\n\t * @property {Boolean=} watcherUnusable\n\t */\n\n\t/**\n\t * @type {Map<String,FsWatchContainer>}\n\t */\n\tconst FsWatchInstances = new Map();\n\n\t/**\n\t * Instantiates the fs_watch interface\n\t * @param {String} path to be watched\n\t * @param {Object} options to be passed to fs_watch\n\t * @param {Function} listener main event handler\n\t * @param {Function} errHandler emits info about errors\n\t * @param {Function} emitRaw emits raw event data\n\t * @returns {fs.FSWatcher} new fsevents instance\n\t */\n\tfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n\t  const handleEvent = (rawEvent, evPath) => {\n\t    listener(path);\n\t    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n\t    // emit based on events occurring for files from a directory's watcher in\n\t    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\t    if (evPath && path !== evPath) {\n\t      fsWatchBroadcast(\n\t        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)\n\t      );\n\t    }\n\t  };\n\t  try {\n\t    return fs.watch(path, options, handleEvent);\n\t  } catch (error) {\n\t    errHandler(error);\n\t  }\n\t}\n\n\t/**\n\t * Helper for passing fs_watch event data to a collection of listeners\n\t * @param {Path} fullPath absolute path bound to fs_watch instance\n\t * @param {String} type listener type\n\t * @param {*=} val1 arguments to be passed to listeners\n\t * @param {*=} val2\n\t * @param {*=} val3\n\t */\n\tconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n\t  const cont = FsWatchInstances.get(fullPath);\n\t  if (!cont) return;\n\t  foreach(cont[type], (listener) => {\n\t    listener(val1, val2, val3);\n\t  });\n\t};\n\n\t/**\n\t * Instantiates the fs_watch interface or binds listeners\n\t * to an existing one covering the same file system entry\n\t * @param {String} path\n\t * @param {String} fullPath absolute path\n\t * @param {Object} options to be passed to fs_watch\n\t * @param {Object} handlers container for event listener functions\n\t */\n\tconst setFsWatchListener = (path, fullPath, options, handlers) => {\n\t  const {listener, errHandler, rawEmitter} = handlers;\n\t  let cont = FsWatchInstances.get(fullPath);\n\n\t  /** @type {fs.FSWatcher=} */\n\t  let watcher;\n\t  if (!options.persistent) {\n\t    watcher = createFsWatchInstance(\n\t      path, options, listener, errHandler, rawEmitter\n\t    );\n\t    return watcher.close.bind(watcher);\n\t  }\n\t  if (cont) {\n\t    addAndConvert(cont, KEY_LISTENERS, listener);\n\t    addAndConvert(cont, KEY_ERR, errHandler);\n\t    addAndConvert(cont, KEY_RAW, rawEmitter);\n\t  } else {\n\t    watcher = createFsWatchInstance(\n\t      path,\n\t      options,\n\t      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n\t      errHandler, // no need to use broadcast here\n\t      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n\t    );\n\t    if (!watcher) return;\n\t    watcher.on(EV_ERROR, async (error) => {\n\t      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n\t      cont.watcherUnusable = true; // documented since Node 10.4.1\n\t      // Workaround for https://github.com/joyent/node/issues/4337\n\t      if (isWindows && error.code === 'EPERM') {\n\t        try {\n\t          const fd = await open(path, 'r');\n\t          await close(fd);\n\t          broadcastErr(error);\n\t        } catch (err) {}\n\t      } else {\n\t        broadcastErr(error);\n\t      }\n\t    });\n\t    cont = {\n\t      listeners: listener,\n\t      errHandlers: errHandler,\n\t      rawEmitters: rawEmitter,\n\t      watcher\n\t    };\n\t    FsWatchInstances.set(fullPath, cont);\n\t  }\n\t  // const index = cont.listeners.indexOf(listener);\n\n\t  // removes this instance's listeners and closes the underlying fs_watch\n\t  // instance if there are no more listeners left\n\t  return () => {\n\t    delFromSet(cont, KEY_LISTENERS, listener);\n\t    delFromSet(cont, KEY_ERR, errHandler);\n\t    delFromSet(cont, KEY_RAW, rawEmitter);\n\t    if (isEmptySet(cont.listeners)) {\n\t      // Check to protect against issue gh-730.\n\t      // if (cont.watcherUnusable) {\n\t      cont.watcher.close();\n\t      // }\n\t      FsWatchInstances.delete(fullPath);\n\t      HANDLER_KEYS.forEach(clearItem(cont));\n\t      cont.watcher = undefined;\n\t      Object.freeze(cont);\n\t    }\n\t  };\n\t};\n\n\t// fs_watchFile helpers\n\n\t// object to hold per-process fs_watchFile instances\n\t// (may be shared across chokidar FSWatcher instances)\n\tconst FsWatchFileInstances = new Map();\n\n\t/**\n\t * Instantiates the fs_watchFile interface or binds listeners\n\t * to an existing one covering the same file system entry\n\t * @param {String} path to be watched\n\t * @param {String} fullPath absolute path\n\t * @param {Object} options options to be passed to fs_watchFile\n\t * @param {Object} handlers container for event listener functions\n\t * @returns {Function} closer\n\t */\n\tconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n\t  const {listener, rawEmitter} = handlers;\n\t  let cont = FsWatchFileInstances.get(fullPath);\n\n\t  const copts = cont && cont.options;\n\t  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n\t    fs.unwatchFile(fullPath);\n\t    cont = undefined;\n\t  }\n\n\t  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\t  if (cont) {\n\t    addAndConvert(cont, KEY_LISTENERS, listener);\n\t    addAndConvert(cont, KEY_RAW, rawEmitter);\n\t  } else {\n\t    // TODO\n\t    // listeners.add(listener);\n\t    // rawEmitters.add(rawEmitter);\n\t    cont = {\n\t      listeners: listener,\n\t      rawEmitters: rawEmitter,\n\t      options,\n\t      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n\t        foreach(cont.rawEmitters, (rawEmitter) => {\n\t          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n\t        });\n\t        const currmtime = curr.mtimeMs;\n\t        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n\t          foreach(cont.listeners, (listener) => listener(path, curr));\n\t        }\n\t      })\n\t    };\n\t    FsWatchFileInstances.set(fullPath, cont);\n\t  }\n\t  // const index = cont.listeners.indexOf(listener);\n\n\t  // Removes this instance's listeners and closes the underlying fs_watchFile\n\t  // instance if there are no more listeners left.\n\t  return () => {\n\t    delFromSet(cont, KEY_LISTENERS, listener);\n\t    delFromSet(cont, KEY_RAW, rawEmitter);\n\t    if (isEmptySet(cont.listeners)) {\n\t      FsWatchFileInstances.delete(fullPath);\n\t      fs.unwatchFile(fullPath);\n\t      cont.options = cont.watcher = undefined;\n\t      Object.freeze(cont);\n\t    }\n\t  };\n\t};\n\n\t/**\n\t * @mixin\n\t */\n\tclass NodeFsHandler {\n\n\t/**\n\t * @param {import(\"../index\").FSWatcher} fsW\n\t */\n\tconstructor(fsW) {\n\t  this.fsw = fsW;\n\t  this._boundHandleError = (error) => fsW._handleError(error);\n\t}\n\n\t/**\n\t * Watch file for changes with fs_watchFile or fs_watch.\n\t * @param {String} path to file or dir\n\t * @param {Function} listener on fs change\n\t * @returns {Function} closer for the watcher instance\n\t */\n\t_watchWithNodeFs(path, listener) {\n\t  const opts = this.fsw.options;\n\t  const directory = sysPath.dirname(path);\n\t  const basename = sysPath.basename(path);\n\t  const parent = this.fsw._getWatchedDir(directory);\n\t  parent.add(basename);\n\t  const absolutePath = sysPath.resolve(path);\n\t  const options = {persistent: opts.persistent};\n\t  if (!listener) listener = EMPTY_FN;\n\n\t  let closer;\n\t  if (opts.usePolling) {\n\t    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n\t      opts.binaryInterval : opts.interval;\n\t    closer = setFsWatchFileListener(path, absolutePath, options, {\n\t      listener,\n\t      rawEmitter: this.fsw._emitRaw\n\t    });\n\t  } else {\n\t    closer = setFsWatchListener(path, absolutePath, options, {\n\t      listener,\n\t      errHandler: this._boundHandleError,\n\t      rawEmitter: this.fsw._emitRaw\n\t    });\n\t  }\n\t  return closer;\n\t}\n\n\t/**\n\t * Watch a file and emit add event if warranted.\n\t * @param {Path} file Path\n\t * @param {fs.Stats} stats result of fs_stat\n\t * @param {Boolean} initialAdd was the file added at watch instantiation?\n\t * @returns {Function} closer for the watcher instance\n\t */\n\t_handleFile(file, stats, initialAdd) {\n\t  if (this.fsw.closed) {\n\t    return;\n\t  }\n\t  const dirname = sysPath.dirname(file);\n\t  const basename = sysPath.basename(file);\n\t  const parent = this.fsw._getWatchedDir(dirname);\n\t  // stats is always present\n\t  let prevStats = stats;\n\n\t  // if the file is already being watched, do nothing\n\t  if (parent.has(basename)) return;\n\n\t  const listener = async (path, newStats) => {\n\t    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\t    if (!newStats || newStats.mtimeMs === 0) {\n\t      try {\n\t        const newStats = await stat(file);\n\t        if (this.fsw.closed) return;\n\t        // Check that change event was not fired because of changed only accessTime.\n\t        const at = newStats.atimeMs;\n\t        const mt = newStats.mtimeMs;\n\t        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n\t          this.fsw._emit(EV_CHANGE, file, newStats);\n\t        }\n\t        if (isLinux && prevStats.ino !== newStats.ino) {\n\t          this.fsw._closeFile(path);\n\t          prevStats = newStats;\n\t          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n\t        } else {\n\t          prevStats = newStats;\n\t        }\n\t      } catch (error) {\n\t        // Fix issues where mtime is null but file is still present\n\t        this.fsw._remove(dirname, basename);\n\t      }\n\t      // add is about to be emitted if file not already tracked in parent\n\t    } else if (parent.has(basename)) {\n\t      // Check that change event was not fired because of changed only accessTime.\n\t      const at = newStats.atimeMs;\n\t      const mt = newStats.mtimeMs;\n\t      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n\t        this.fsw._emit(EV_CHANGE, file, newStats);\n\t      }\n\t      prevStats = newStats;\n\t    }\n\t  };\n\t  // kick off the watcher\n\t  const closer = this._watchWithNodeFs(file, listener);\n\n\t  // emit an add event if we're supposed to\n\t  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n\t    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n\t    this.fsw._emit(EV_ADD, file, stats);\n\t  }\n\n\t  return closer;\n\t}\n\n\t/**\n\t * Handle symlinks encountered while reading a dir.\n\t * @param {Object} entry returned by readdirp\n\t * @param {String} directory path of dir being read\n\t * @param {String} path of this item\n\t * @param {String} item basename of this item\n\t * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n\t */\n\tasync _handleSymlink(entry, directory, path, item) {\n\t  if (this.fsw.closed) {\n\t    return;\n\t  }\n\t  const full = entry.fullPath;\n\t  const dir = this.fsw._getWatchedDir(directory);\n\n\t  if (!this.fsw.options.followSymlinks) {\n\t    // watch symlink directly (don't follow) and detect changes\n\t    this.fsw._incrReadyCount();\n\n\t    let linkPath;\n\t    try {\n\t      linkPath = await fsrealpath(path);\n\t    } catch (e) {\n\t      this.fsw._emitReady();\n\t      return true;\n\t    }\n\n\t    if (this.fsw.closed) return;\n\t    if (dir.has(item)) {\n\t      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n\t        this.fsw._symlinkPaths.set(full, linkPath);\n\t        this.fsw._emit(EV_CHANGE, path, entry.stats);\n\t      }\n\t    } else {\n\t      dir.add(item);\n\t      this.fsw._symlinkPaths.set(full, linkPath);\n\t      this.fsw._emit(EV_ADD, path, entry.stats);\n\t    }\n\t    this.fsw._emitReady();\n\t    return true;\n\t  }\n\n\t  // don't follow the same symlink more than once\n\t  if (this.fsw._symlinkPaths.has(full)) {\n\t    return true;\n\t  }\n\n\t  this.fsw._symlinkPaths.set(full, true);\n\t}\n\n\t_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n\t  // Normalize the directory name on Windows\n\t  directory = sysPath.join(directory, EMPTY_STR);\n\n\t  if (!wh.hasGlob) {\n\t    throttler = this.fsw._throttle('readdir', directory, 1000);\n\t    if (!throttler) return;\n\t  }\n\n\t  const previous = this.fsw._getWatchedDir(wh.path);\n\t  const current = new Set();\n\n\t  let stream = this.fsw._readdirp(directory, {\n\t    fileFilter: entry => wh.filterPath(entry),\n\t    directoryFilter: entry => wh.filterDir(entry),\n\t    depth: 0\n\t  }).on(STR_DATA, async (entry) => {\n\t    if (this.fsw.closed) {\n\t      stream = undefined;\n\t      return;\n\t    }\n\t    const item = entry.path;\n\t    let path = sysPath.join(directory, item);\n\t    current.add(item);\n\n\t    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n\t      return;\n\t    }\n\n\t    if (this.fsw.closed) {\n\t      stream = undefined;\n\t      return;\n\t    }\n\t    // Files that present in current directory snapshot\n\t    // but absent in previous are added to watch list and\n\t    // emit `add` event.\n\t    if (item === target || !target && !previous.has(item)) {\n\t      this.fsw._incrReadyCount();\n\n\t      // ensure relativeness of path is preserved in case of watcher reuse\n\t      path = sysPath.join(dir, sysPath.relative(dir, path));\n\n\t      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n\t    }\n\t  }).on(EV_ERROR, this._boundHandleError);\n\n\t  return new Promise(resolve =>\n\t    stream.once(STR_END, () => {\n\t      if (this.fsw.closed) {\n\t        stream = undefined;\n\t        return;\n\t      }\n\t      const wasThrottled = throttler ? throttler.clear() : false;\n\n\t      resolve();\n\n\t      // Files that absent in current directory snapshot\n\t      // but present in previous emit `remove` event\n\t      // and are removed from @watched[directory].\n\t      previous.getChildren().filter((item) => {\n\t        return item !== directory &&\n\t          !current.has(item) &&\n\t          // in case of intersecting globs;\n\t          // a path may have been filtered out of this readdir, but\n\t          // shouldn't be removed because it matches a different glob\n\t          (!wh.hasGlob || wh.filterPath({\n\t            fullPath: sysPath.resolve(directory, item)\n\t          }));\n\t      }).forEach((item) => {\n\t        this.fsw._remove(directory, item);\n\t      });\n\n\t      stream = undefined;\n\n\t      // one more time for any missed in case changes came in extremely quickly\n\t      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n\t    })\n\t  );\n\t}\n\n\t/**\n\t * Read directory to add / remove files from `@watched` list and re-read it on change.\n\t * @param {String} dir fs path\n\t * @param {fs.Stats} stats\n\t * @param {Boolean} initialAdd\n\t * @param {Number} depth relative to user-supplied path\n\t * @param {String} target child path targeted for watch\n\t * @param {Object} wh Common watch helpers for this path\n\t * @param {String} realpath\n\t * @returns {Promise<Function>} closer for the watcher instance.\n\t */\n\tasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n\t  const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));\n\t  const tracked = parentDir.has(sysPath.basename(dir));\n\t  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n\t    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n\t  }\n\n\t  // ensure dir is tracked (harmless if redundant)\n\t  parentDir.add(sysPath.basename(dir));\n\t  this.fsw._getWatchedDir(dir);\n\t  let throttler;\n\t  let closer;\n\n\t  const oDepth = this.fsw.options.depth;\n\t  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n\t    if (!target) {\n\t      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n\t      if (this.fsw.closed) return;\n\t    }\n\n\t    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n\t      // if current directory is removed, do nothing\n\t      if (stats && stats.mtimeMs === 0) return;\n\n\t      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n\t    });\n\t  }\n\t  return closer;\n\t}\n\n\t/**\n\t * Handle added file, directory, or glob pattern.\n\t * Delegates call to _handleFile / _handleDir after checks.\n\t * @param {String} path to file or ir\n\t * @param {Boolean} initialAdd was the file added at watch instantiation?\n\t * @param {Object} priorWh depth relative to user-supplied path\n\t * @param {Number} depth Child path actually targeted for watch\n\t * @param {String=} target Child path actually targeted for watch\n\t * @returns {Promise}\n\t */\n\tasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n\t  const ready = this.fsw._emitReady;\n\t  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n\t    ready();\n\t    return false;\n\t  }\n\n\t  const wh = this.fsw._getWatchHelpers(path, depth);\n\t  if (!wh.hasGlob && priorWh) {\n\t    wh.hasGlob = priorWh.hasGlob;\n\t    wh.globFilter = priorWh.globFilter;\n\t    wh.filterPath = entry => priorWh.filterPath(entry);\n\t    wh.filterDir = entry => priorWh.filterDir(entry);\n\t  }\n\n\t  // evaluate what is at the path we're being asked to watch\n\t  try {\n\t    const stats = await statMethods[wh.statMethod](wh.watchPath);\n\t    if (this.fsw.closed) return;\n\t    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n\t      ready();\n\t      return false;\n\t    }\n\n\t    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START);\n\t    let closer;\n\t    if (stats.isDirectory()) {\n\t      const absPath = sysPath.resolve(path);\n\t      const targetPath = follow ? await fsrealpath(path) : path;\n\t      if (this.fsw.closed) return;\n\t      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n\t      if (this.fsw.closed) return;\n\t      // preserve this symlink's target path\n\t      if (absPath !== targetPath && targetPath !== undefined) {\n\t        this.fsw._symlinkPaths.set(absPath, targetPath);\n\t      }\n\t    } else if (stats.isSymbolicLink()) {\n\t      const targetPath = follow ? await fsrealpath(path) : path;\n\t      if (this.fsw.closed) return;\n\t      const parent = sysPath.dirname(wh.watchPath);\n\t      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\t      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n\t      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n\t      if (this.fsw.closed) return;\n\n\t      // preserve this symlink's target path\n\t      if (targetPath !== undefined) {\n\t        this.fsw._symlinkPaths.set(sysPath.resolve(path), targetPath);\n\t      }\n\t    } else {\n\t      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n\t    }\n\t    ready();\n\n\t    this.fsw._addPathCloser(path, closer);\n\t    return false;\n\n\t  } catch (error) {\n\t    if (this.fsw._handleError(error)) {\n\t      ready();\n\t      return path;\n\t    }\n\t  }\n\t}\n\n\t}\n\n\tnodefsHandler = NodeFsHandler;\n\treturn nodefsHandler;\n}\n\nvar fseventsHandler = {exports: {}};\n\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\n\nvar hasRequiredFseventsHandler;\n\nfunction requireFseventsHandler () {\n\tif (hasRequiredFseventsHandler) return fseventsHandler.exports;\n\thasRequiredFseventsHandler = 1;\n\n\tconst fs = require$$0$2;\n\tconst sysPath = require$$0$1;\n\tconst { promisify } = require$$2;\n\n\tlet fsevents;\n\ttry {\n\t  fsevents = require$$3.getFsEvents();\n\t} catch (error) {\n\t  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n\t}\n\n\tif (fsevents) {\n\t  // TODO: real check\n\t  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\t  if (mtch && mtch[1] && mtch[2]) {\n\t    const maj = Number.parseInt(mtch[1], 10);\n\t    const min = Number.parseInt(mtch[2], 10);\n\t    if (maj === 8 && min < 16) {\n\t      fsevents = undefined;\n\t    }\n\t  }\n\t}\n\n\tconst {\n\t  EV_ADD,\n\t  EV_CHANGE,\n\t  EV_ADD_DIR,\n\t  EV_UNLINK,\n\t  EV_ERROR,\n\t  STR_DATA,\n\t  STR_END,\n\t  FSEVENT_CREATED,\n\t  FSEVENT_MODIFIED,\n\t  FSEVENT_DELETED,\n\t  FSEVENT_MOVED,\n\t  // FSEVENT_CLONED,\n\t  FSEVENT_UNKNOWN,\n\t  FSEVENT_FLAG_MUST_SCAN_SUBDIRS,\n\t  FSEVENT_TYPE_FILE,\n\t  FSEVENT_TYPE_DIRECTORY,\n\t  FSEVENT_TYPE_SYMLINK,\n\n\t  ROOT_GLOBSTAR,\n\t  DIR_SUFFIX,\n\t  DOT_SLASH,\n\t  FUNCTION_TYPE,\n\t  EMPTY_FN,\n\t  IDENTITY_FN\n\t} = /*@__PURE__*/ requireConstants();\n\n\tconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\n\tconst stat = promisify(fs.stat);\n\tconst lstat = promisify(fs.lstat);\n\tconst realpath = promisify(fs.realpath);\n\n\tconst statMethods = { stat, lstat };\n\n\t/**\n\t * @typedef {String} Path\n\t */\n\n\t/**\n\t * @typedef {Object} FsEventsWatchContainer\n\t * @property {Set<Function>} listeners\n\t * @property {Function} rawEmitter\n\t * @property {{stop: Function}} watcher\n\t */\n\n\t// fsevents instance helper functions\n\t/**\n\t * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n\t * @type {Map<Path,FsEventsWatchContainer>}\n\t */\n\tconst FSEventsWatchers = new Map();\n\n\t// Threshold of duplicate path prefixes at which to start\n\t// consolidating going forward\n\tconst consolidateThreshhold = 10;\n\n\tconst wrongEventFlags = new Set([\n\t  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n\t]);\n\n\t/**\n\t * Instantiates the fsevents interface\n\t * @param {Path} path path to be watched\n\t * @param {Function} callback called when fsevents is bound and ready\n\t * @returns {{stop: Function}} new fsevents instance\n\t */\n\tconst createFSEventsInstance = (path, callback) => {\n\t  const stop = fsevents.watch(path, callback);\n\t  return {stop};\n\t};\n\n\t/**\n\t * Instantiates the fsevents interface or binds listeners to an existing one covering\n\t * the same file tree.\n\t * @param {Path} path           - to be watched\n\t * @param {Path} realPath       - real path for symlinks\n\t * @param {Function} listener   - called when fsevents emits events\n\t * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n\t * @returns {Function} closer\n\t */\n\tfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n\t  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n\n\t  const parentPath = sysPath.dirname(watchPath);\n\t  let cont = FSEventsWatchers.get(watchPath);\n\n\t  // If we've accumulated a substantial number of paths that\n\t  // could have been consolidated by watching one directory\n\t  // above the current one, create a watcher on the parent\n\t  // path instead, so that we do consolidate going forward.\n\t  if (couldConsolidate(parentPath)) {\n\t    watchPath = parentPath;\n\t  }\n\n\t  const resolvedPath = sysPath.resolve(path);\n\t  const hasSymlink = resolvedPath !== realPath;\n\n\t  const filteredListener = (fullPath, flags, info) => {\n\t    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n\t    if (\n\t      fullPath === resolvedPath ||\n\t      !fullPath.indexOf(resolvedPath + sysPath.sep)\n\t    ) listener(fullPath, flags, info);\n\t  };\n\n\t  // check if there is already a watcher on a parent path\n\t  // modifies `watchPath` to the parent path when it finds a match\n\t  let watchedParent = false;\n\t  for (const watchedPath of FSEventsWatchers.keys()) {\n\t    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n\t      watchPath = watchedPath;\n\t      cont = FSEventsWatchers.get(watchPath);\n\t      watchedParent = true;\n\t      break;\n\t    }\n\t  }\n\n\t  if (cont || watchedParent) {\n\t    cont.listeners.add(filteredListener);\n\t  } else {\n\t    cont = {\n\t      listeners: new Set([filteredListener]),\n\t      rawEmitter,\n\t      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n\t        if (!cont.listeners.size) return;\n\t        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;\n\t        const info = fsevents.getInfo(fullPath, flags);\n\t        cont.listeners.forEach(list => {\n\t          list(fullPath, flags, info);\n\t        });\n\n\t        cont.rawEmitter(info.event, fullPath, info);\n\t      })\n\t    };\n\t    FSEventsWatchers.set(watchPath, cont);\n\t  }\n\n\t  // removes this instance's listeners and closes the underlying fsevents\n\t  // instance if there are no more listeners left\n\t  return () => {\n\t    const lst = cont.listeners;\n\n\t    lst.delete(filteredListener);\n\t    if (!lst.size) {\n\t      FSEventsWatchers.delete(watchPath);\n\t      if (cont.watcher) return cont.watcher.stop().then(() => {\n\t        cont.rawEmitter = cont.watcher = undefined;\n\t        Object.freeze(cont);\n\t      });\n\t    }\n\t  };\n\t}\n\n\t// Decide whether or not we should start a new higher-level\n\t// parent watcher\n\tconst couldConsolidate = (path) => {\n\t  let count = 0;\n\t  for (const watchPath of FSEventsWatchers.keys()) {\n\t    if (watchPath.indexOf(path) === 0) {\n\t      count++;\n\t      if (count >= consolidateThreshhold) {\n\t        return true;\n\t      }\n\t    }\n\t  }\n\n\t  return false;\n\t};\n\n\t// returns boolean indicating whether fsevents can be used\n\tconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n\t// determines subdirectory traversal levels from root to path\n\tconst calcDepth = (path, root) => {\n\t  let i = 0;\n\t  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\t  return i;\n\t};\n\n\t// returns boolean indicating whether the fsevents' event info has the same type\n\t// as the one returned by fs.stat\n\tconst sameTypes = (info, stats) => (\n\t  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n\t  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n\t  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n\t);\n\n\t/**\n\t * @mixin\n\t */\n\tclass FsEventsHandler {\n\n\t/**\n\t * @param {import('../index').FSWatcher} fsw\n\t */\n\tconstructor(fsw) {\n\t  this.fsw = fsw;\n\t}\n\tcheckIgnored(path, stats) {\n\t  const ipaths = this.fsw._ignoredPaths;\n\t  if (this.fsw._isIgnored(path, stats)) {\n\t    ipaths.add(path);\n\t    if (stats && stats.isDirectory()) {\n\t      ipaths.add(path + ROOT_GLOBSTAR);\n\t    }\n\t    return true;\n\t  }\n\n\t  ipaths.delete(path);\n\t  ipaths.delete(path + ROOT_GLOBSTAR);\n\t}\n\n\taddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n\t  const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n\t  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t}\n\n\tasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n\t  try {\n\t    const stats = await stat(path);\n\t    if (this.fsw.closed) return;\n\t    if (sameTypes(info, stats)) {\n\t      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t    } else {\n\t      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t    }\n\t  } catch (error) {\n\t    if (error.code === 'EACCES') {\n\t      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t    } else {\n\t      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t    }\n\t  }\n\t}\n\n\thandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n\t  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n\t  if (event === EV_UNLINK) {\n\t    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n\t    // suppress unlink events on never before seen files\n\t    if (isDirectory || watchedDir.has(item)) {\n\t      this.fsw._remove(parent, item, isDirectory);\n\t    }\n\t  } else {\n\t    if (event === EV_ADD) {\n\t      // track new directories\n\t      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n\t      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n\t        // push symlinks back to the top of the stack to get handled\n\t        const curDepth = opts.depth === undefined ?\n\t          undefined : calcDepth(fullPath, realPath) + 1;\n\t        return this._addToFsEvents(path, false, true, curDepth);\n\t      }\n\n\t      // track new paths\n\t      // (other than symlinks being followed, which will be tracked soon)\n\t      this.fsw._getWatchedDir(parent).add(item);\n\t    }\n\t    /**\n\t     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n\t     */\n\t    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\t    this.fsw._emit(eventName, path);\n\t    if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n\t  }\n\t}\n\n\t/**\n\t * Handle symlinks encountered during directory scan\n\t * @param {String} watchPath  - file/dir path to be watched with fsevents\n\t * @param {String} realPath   - real path (in case of symlinks)\n\t * @param {Function} transform  - path transformer\n\t * @param {Function} globFilter - path filter in case a glob pattern was provided\n\t * @returns {Function} closer for the watcher instance\n\t*/\n\t_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n\t  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n\t  const opts = this.fsw.options;\n\t  const watchCallback = async (fullPath, flags, info) => {\n\t    if (this.fsw.closed) return;\n\t    if (\n\t      opts.depth !== undefined &&\n\t      calcDepth(fullPath, realPath) > opts.depth\n\t    ) return;\n\t    const path = transform(sysPath.join(\n\t      watchPath, sysPath.relative(watchPath, fullPath)\n\t    ));\n\t    if (globFilter && !globFilter(path)) return;\n\t    // ensure directories are tracked\n\t    const parent = sysPath.dirname(path);\n\t    const item = sysPath.basename(path);\n\t    const watchedDir = this.fsw._getWatchedDir(\n\t      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n\t    );\n\n\t    // correct for wrong events emitted\n\t    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n\t      if (typeof opts.ignored === FUNCTION_TYPE) {\n\t        let stats;\n\t        try {\n\t          stats = await stat(path);\n\t        } catch (error) {}\n\t        if (this.fsw.closed) return;\n\t        if (this.checkIgnored(path, stats)) return;\n\t        if (sameTypes(info, stats)) {\n\t          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t        } else {\n\t          this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t        }\n\t      } else {\n\t        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t      }\n\t    } else {\n\t      switch (info.event) {\n\t      case FSEVENT_CREATED:\n\t      case FSEVENT_MODIFIED:\n\t        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t      case FSEVENT_DELETED:\n\t      case FSEVENT_MOVED:\n\t        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\t      }\n\t    }\n\t  };\n\n\t  const closer = setFSEventsListener(\n\t    watchPath,\n\t    realPath,\n\t    watchCallback,\n\t    this.fsw._emitRaw\n\t  );\n\n\t  this.fsw._emitReady();\n\t  return closer;\n\t}\n\n\t/**\n\t * Handle symlinks encountered during directory scan\n\t * @param {String} linkPath path to symlink\n\t * @param {String} fullPath absolute path to the symlink\n\t * @param {Function} transform pre-existing path transformer\n\t * @param {Number} curDepth level of subdirectories traversed to where symlink is\n\t * @returns {Promise<void>}\n\t */\n\tasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n\t  // don't follow the same symlink more than once\n\t  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n\t  this.fsw._symlinkPaths.set(fullPath, true);\n\t  this.fsw._incrReadyCount();\n\n\t  try {\n\t    const linkTarget = await realpath(linkPath);\n\t    if (this.fsw.closed) return;\n\t    if (this.fsw._isIgnored(linkTarget)) {\n\t      return this.fsw._emitReady();\n\t    }\n\n\t    this.fsw._incrReadyCount();\n\n\t    // add the linkTarget for watching with a wrapper for transform\n\t    // that causes emitted paths to incorporate the link's path\n\t    this._addToFsEvents(linkTarget || linkPath, (path) => {\n\t      let aliasedPath = linkPath;\n\t      if (linkTarget && linkTarget !== DOT_SLASH) {\n\t        aliasedPath = path.replace(linkTarget, linkPath);\n\t      } else if (path !== DOT_SLASH) {\n\t        aliasedPath = sysPath.join(linkPath, path);\n\t      }\n\t      return transform(aliasedPath);\n\t    }, false, curDepth);\n\t  } catch(error) {\n\t    if (this.fsw._handleError(error)) {\n\t      return this.fsw._emitReady();\n\t    }\n\t  }\n\t}\n\n\t/**\n\t *\n\t * @param {Path} newPath\n\t * @param {fs.Stats} stats\n\t */\n\temitAdd(newPath, stats, processPath, opts, forceAdd) {\n\t  const pp = processPath(newPath);\n\t  const isDir = stats.isDirectory();\n\t  const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\t  const base = sysPath.basename(pp);\n\n\t  // ensure empty dirs get tracked\n\t  if (isDir) this.fsw._getWatchedDir(pp);\n\t  if (dirObj.has(base)) return;\n\t  dirObj.add(base);\n\n\t  if (!opts.ignoreInitial || forceAdd === true) {\n\t    this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n\t  }\n\t}\n\n\tinitWatch(realPath, path, wh, processPath) {\n\t  if (this.fsw.closed) return;\n\t  const closer = this._watchWithFsEvents(\n\t    wh.watchPath,\n\t    sysPath.resolve(realPath || wh.watchPath),\n\t    processPath,\n\t    wh.globFilter\n\t  );\n\t  this.fsw._addPathCloser(path, closer);\n\t}\n\n\t/**\n\t * Handle added path with fsevents\n\t * @param {String} path file/dir path or glob pattern\n\t * @param {Function|Boolean=} transform converts working path to what the user expects\n\t * @param {Boolean=} forceAdd ensure add is emitted\n\t * @param {Number=} priorDepth Level of subdirectories already traversed.\n\t * @returns {Promise<void>}\n\t */\n\tasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n\t  if (this.fsw.closed) {\n\t    return;\n\t  }\n\t  const opts = this.fsw.options;\n\t  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n\t  const wh = this.fsw._getWatchHelpers(path);\n\n\t  // evaluate what is at the path we're being asked to watch\n\t  try {\n\t    const stats = await statMethods[wh.statMethod](wh.watchPath);\n\t    if (this.fsw.closed) return;\n\t    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n\t      throw null;\n\t    }\n\t    if (stats.isDirectory()) {\n\t      // emit addDir unless this is a glob parent\n\t      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n\t      // don't recurse further if it would exceed depth setting\n\t      if (priorDepth && priorDepth > opts.depth) return;\n\n\t      // scan the contents of the dir\n\t      this.fsw._readdirp(wh.watchPath, {\n\t        fileFilter: entry => wh.filterPath(entry),\n\t        directoryFilter: entry => wh.filterDir(entry),\n\t        ...Depth(opts.depth - (priorDepth || 0))\n\t      }).on(STR_DATA, (entry) => {\n\t        // need to check filterPath on dirs b/c filterDir is less restrictive\n\t        if (this.fsw.closed) {\n\t          return;\n\t        }\n\t        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n\t        const joinedPath = sysPath.join(wh.watchPath, entry.path);\n\t        const {fullPath} = entry;\n\n\t        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n\t          // preserve the current depth here since it can't be derived from\n\t          // real paths past the symlink\n\t          const curDepth = opts.depth === undefined ?\n\t            undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n\t          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n\t        } else {\n\t          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n\t        }\n\t      }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n\t        this.fsw._emitReady();\n\t      });\n\t    } else {\n\t      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\t      this.fsw._emitReady();\n\t    }\n\t  } catch (error) {\n\t    if (!error || this.fsw._handleError(error)) {\n\t      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n\t      this.fsw._emitReady();\n\t      this.fsw._emitReady();\n\t    }\n\t  }\n\n\t  if (opts.persistent && forceAdd !== true) {\n\t    if (typeof transform === FUNCTION_TYPE) {\n\t      // realpath has already been resolved\n\t      this.initWatch(undefined, path, wh, processPath);\n\t    } else {\n\t      let realPath;\n\t      try {\n\t        realPath = await realpath(wh.watchPath);\n\t      } catch (e) {}\n\t      this.initWatch(realPath, path, wh, processPath);\n\t    }\n\t  }\n\t}\n\n\t}\n\n\tfseventsHandler.exports = FsEventsHandler;\n\tfseventsHandler.exports.canUse = canUse;\n\treturn fseventsHandler.exports;\n}\n\nvar hasRequiredChokidar;\n\nfunction requireChokidar () {\n\tif (hasRequiredChokidar) return chokidar$1;\n\thasRequiredChokidar = 1;\n\n\tconst { EventEmitter } = require$$0$3;\n\tconst fs = require$$0$2;\n\tconst sysPath = require$$0$1;\n\tconst { promisify } = require$$2;\n\tconst readdirp = /*@__PURE__*/ requireReaddirp();\n\tconst anymatch = /*@__PURE__*/ requireAnymatch().default;\n\tconst globParent = /*@__PURE__*/ requireGlobParent();\n\tconst isGlob = /*@__PURE__*/ requireIsGlob();\n\tconst braces = /*@__PURE__*/ requireBraces();\n\tconst normalizePath = /*@__PURE__*/ requireNormalizePath();\n\n\tconst NodeFsHandler = /*@__PURE__*/ requireNodefsHandler();\n\tconst FsEventsHandler = /*@__PURE__*/ requireFseventsHandler();\n\tconst {\n\t  EV_ALL,\n\t  EV_READY,\n\t  EV_ADD,\n\t  EV_CHANGE,\n\t  EV_UNLINK,\n\t  EV_ADD_DIR,\n\t  EV_UNLINK_DIR,\n\t  EV_RAW,\n\t  EV_ERROR,\n\n\t  STR_CLOSE,\n\t  STR_END,\n\n\t  BACK_SLASH_RE,\n\t  DOUBLE_SLASH_RE,\n\t  SLASH_OR_BACK_SLASH_RE,\n\t  DOT_RE,\n\t  REPLACER_RE,\n\n\t  SLASH,\n\t  SLASH_SLASH,\n\t  BRACE_START,\n\t  BANG,\n\t  ONE_DOT,\n\t  TWO_DOTS,\n\t  GLOBSTAR,\n\t  SLASH_GLOBSTAR,\n\t  ANYMATCH_OPTS,\n\t  STRING_TYPE,\n\t  FUNCTION_TYPE,\n\t  EMPTY_STR,\n\t  EMPTY_FN,\n\n\t  isWindows,\n\t  isMacos,\n\t  isIBMi\n\t} = /*@__PURE__*/ requireConstants();\n\n\tconst stat = promisify(fs.stat);\n\tconst readdir = promisify(fs.readdir);\n\n\t/**\n\t * @typedef {String} Path\n\t * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n\t * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n\t */\n\n\t/**\n\t *\n\t * @typedef {Object} WatchHelpers\n\t * @property {Boolean} followSymlinks\n\t * @property {'stat'|'lstat'} statMethod\n\t * @property {Path} path\n\t * @property {Path} watchPath\n\t * @property {Function} entryPath\n\t * @property {Boolean} hasGlob\n\t * @property {Object} globFilter\n\t * @property {Function} filterPath\n\t * @property {Function} filterDir\n\t */\n\n\tconst arrify = (value = []) => Array.isArray(value) ? value : [value];\n\tconst flatten = (list, result = []) => {\n\t  list.forEach(item => {\n\t    if (Array.isArray(item)) {\n\t      flatten(item, result);\n\t    } else {\n\t      result.push(item);\n\t    }\n\t  });\n\t  return result;\n\t};\n\n\tconst unifyPaths = (paths_) => {\n\t  /**\n\t   * @type {Array<String>}\n\t   */\n\t  const paths = flatten(arrify(paths_));\n\t  if (!paths.every(p => typeof p === STRING_TYPE)) {\n\t    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n\t  }\n\t  return paths.map(normalizePathToUnix);\n\t};\n\n\t// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n\t//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\tconst toUnix = (string) => {\n\t  let str = string.replace(BACK_SLASH_RE, SLASH);\n\t  let prepend = false;\n\t  if (str.startsWith(SLASH_SLASH)) {\n\t    prepend = true;\n\t  }\n\t  while (str.match(DOUBLE_SLASH_RE)) {\n\t    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n\t  }\n\t  if (prepend) {\n\t    str = SLASH + str;\n\t  }\n\t  return str;\n\t};\n\n\t// Our version of upath.normalize\n\t// TODO: this is not equal to path-normalize module - investigate why\n\tconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\n\tconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n\t  if (typeof path !== STRING_TYPE) return path;\n\t  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n\t};\n\n\tconst getAbsolutePath = (path, cwd) => {\n\t  if (sysPath.isAbsolute(path)) {\n\t    return path;\n\t  }\n\t  if (path.startsWith(BANG)) {\n\t    return BANG + sysPath.join(cwd, path.slice(1));\n\t  }\n\t  return sysPath.join(cwd, path);\n\t};\n\n\tconst undef = (opts, key) => opts[key] === undefined;\n\n\t/**\n\t * Directory entry.\n\t * @property {Path} path\n\t * @property {Set<Path>} items\n\t */\n\tclass DirEntry {\n\t  /**\n\t   * @param {Path} dir\n\t   * @param {Function} removeWatcher\n\t   */\n\t  constructor(dir, removeWatcher) {\n\t    this.path = dir;\n\t    this._removeWatcher = removeWatcher;\n\t    /** @type {Set<Path>} */\n\t    this.items = new Set();\n\t  }\n\n\t  add(item) {\n\t    const {items} = this;\n\t    if (!items) return;\n\t    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n\t  }\n\n\t  async remove(item) {\n\t    const {items} = this;\n\t    if (!items) return;\n\t    items.delete(item);\n\t    if (items.size > 0) return;\n\n\t    const dir = this.path;\n\t    try {\n\t      await readdir(dir);\n\t    } catch (err) {\n\t      if (this._removeWatcher) {\n\t        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n\t      }\n\t    }\n\t  }\n\n\t  has(item) {\n\t    const {items} = this;\n\t    if (!items) return;\n\t    return items.has(item);\n\t  }\n\n\t  /**\n\t   * @returns {Array<String>}\n\t   */\n\t  getChildren() {\n\t    const {items} = this;\n\t    if (!items) return;\n\t    return [...items.values()];\n\t  }\n\n\t  dispose() {\n\t    this.items.clear();\n\t    delete this.path;\n\t    delete this._removeWatcher;\n\t    delete this.items;\n\t    Object.freeze(this);\n\t  }\n\t}\n\n\tconst STAT_METHOD_F = 'stat';\n\tconst STAT_METHOD_L = 'lstat';\n\tclass WatchHelper {\n\t  constructor(path, watchPath, follow, fsw) {\n\t    this.fsw = fsw;\n\t    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n\t    this.watchPath = watchPath;\n\t    this.fullWatchPath = sysPath.resolve(watchPath);\n\t    this.hasGlob = watchPath !== path;\n\t    /** @type {object|boolean} */\n\t    if (path === EMPTY_STR) this.hasGlob = false;\n\t    this.globSymlink = this.hasGlob && follow ? undefined : false;\n\t    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n\t    this.dirParts = this.getDirParts(path);\n\t    this.dirParts.forEach((parts) => {\n\t      if (parts.length > 1) parts.pop();\n\t    });\n\t    this.followSymlinks = follow;\n\t    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n\t  }\n\n\t  checkGlobSymlink(entry) {\n\t    // only need to resolve once\n\t    // first entry should always have entry.parentDir === EMPTY_STR\n\t    if (this.globSymlink === undefined) {\n\t      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n\t        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n\t    }\n\n\t    if (this.globSymlink) {\n\t      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n\t    }\n\n\t    return entry.fullPath;\n\t  }\n\n\t  entryPath(entry) {\n\t    return sysPath.join(this.watchPath,\n\t      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n\t    );\n\t  }\n\n\t  filterPath(entry) {\n\t    const {stats} = entry;\n\t    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n\t    const resolvedPath = this.entryPath(entry);\n\t    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n\t      this.globFilter(resolvedPath) : true;\n\t    return matchesGlob &&\n\t      this.fsw._isntIgnored(resolvedPath, stats) &&\n\t      this.fsw._hasReadPermissions(stats);\n\t  }\n\n\t  getDirParts(path) {\n\t    if (!this.hasGlob) return [];\n\t    const parts = [];\n\t    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n\t    expandedPath.forEach((path) => {\n\t      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n\t    });\n\t    return parts;\n\t  }\n\n\t  filterDir(entry) {\n\t    if (this.hasGlob) {\n\t      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n\t      let globstar = false;\n\t      this.unmatchedGlob = !this.dirParts.some((parts) => {\n\t        return parts.every((part, i) => {\n\t          if (part === GLOBSTAR) globstar = true;\n\t          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n\t        });\n\t      });\n\t    }\n\t    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n\t  }\n\t}\n\n\t/**\n\t * Watches files & directories for changes. Emitted events:\n\t * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n\t *\n\t *     new FSWatcher()\n\t *       .add(directories)\n\t *       .on('add', path => log('File', path, 'was added'))\n\t */\n\tclass FSWatcher extends EventEmitter {\n\t// Not indenting methods for history sake; for now.\n\tconstructor(_opts) {\n\t  super();\n\n\t  const opts = {};\n\t  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n\t  /** @type {Map<String, DirEntry>} */\n\t  this._watched = new Map();\n\t  /** @type {Map<String, Array>} */\n\t  this._closers = new Map();\n\t  /** @type {Set<String>} */\n\t  this._ignoredPaths = new Set();\n\n\t  /** @type {Map<ThrottleType, Map>} */\n\t  this._throttled = new Map();\n\n\t  /** @type {Map<Path, String|Boolean>} */\n\t  this._symlinkPaths = new Map();\n\n\t  this._streams = new Set();\n\t  this.closed = false;\n\n\t  // Set up default options.\n\t  if (undef(opts, 'persistent')) opts.persistent = true;\n\t  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n\t  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n\t  if (undef(opts, 'interval')) opts.interval = 100;\n\t  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n\t  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n\t  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n\t  // Enable fsevents on OS X when polling isn't explicitly enabled.\n\t  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n\t  // If we can't use fsevents, ensure the options reflect it's disabled.\n\t  const canUseFsEvents = FsEventsHandler.canUse();\n\t  if (!canUseFsEvents) opts.useFsEvents = false;\n\n\t  // Use polling on Mac if not using fsevents.\n\t  // Other platforms use non-polling fs_watch.\n\t  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n\t    opts.usePolling = isMacos;\n\t  }\n\n\t  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\t  if(isIBMi) {\n\t    opts.usePolling = true;\n\t  }\n\n\t  // Global override (useful for end-developers that need to force polling for all\n\t  // instances of chokidar, regardless of usage/dependency depth)\n\t  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\t  if (envPoll !== undefined) {\n\t    const envLower = envPoll.toLowerCase();\n\n\t    if (envLower === 'false' || envLower === '0') {\n\t      opts.usePolling = false;\n\t    } else if (envLower === 'true' || envLower === '1') {\n\t      opts.usePolling = true;\n\t    } else {\n\t      opts.usePolling = !!envLower;\n\t    }\n\t  }\n\t  const envInterval = process.env.CHOKIDAR_INTERVAL;\n\t  if (envInterval) {\n\t    opts.interval = Number.parseInt(envInterval, 10);\n\t  }\n\n\t  // Editor atomic write normalization enabled by default with fs.watch\n\t  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n\t  if (opts.atomic) this._pendingUnlinks = new Map();\n\n\t  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n\t  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n\t  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n\t  const awf = opts.awaitWriteFinish;\n\t  if (awf) {\n\t    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n\t    if (!awf.pollInterval) awf.pollInterval = 100;\n\t    this._pendingWrites = new Map();\n\t  }\n\t  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n\t  let readyCalls = 0;\n\t  this._emitReady = () => {\n\t    readyCalls++;\n\t    if (readyCalls >= this._readyCount) {\n\t      this._emitReady = EMPTY_FN;\n\t      this._readyEmitted = true;\n\t      // use process.nextTick to allow time for listener to be bound\n\t      process.nextTick(() => this.emit(EV_READY));\n\t    }\n\t  };\n\t  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n\t  this._readyEmitted = false;\n\t  this.options = opts;\n\n\t  // Initialize with proper watcher.\n\t  if (opts.useFsEvents) {\n\t    this._fsEventsHandler = new FsEventsHandler(this);\n\t  } else {\n\t    this._nodeFsHandler = new NodeFsHandler(this);\n\t  }\n\n\t  // You’re frozen when your heart’s not open.\n\t  Object.freeze(opts);\n\t}\n\n\t// Public methods\n\n\t/**\n\t * Adds paths to be watched on an existing FSWatcher instance\n\t * @param {Path|Array<Path>} paths_\n\t * @param {String=} _origAdd private; for handling non-existent paths to be watched\n\t * @param {Boolean=} _internal private; indicates a non-user add\n\t * @returns {FSWatcher} for chaining\n\t */\n\tadd(paths_, _origAdd, _internal) {\n\t  const {cwd, disableGlobbing} = this.options;\n\t  this.closed = false;\n\t  let paths = unifyPaths(paths_);\n\t  if (cwd) {\n\t    paths = paths.map((path) => {\n\t      const absPath = getAbsolutePath(path, cwd);\n\n\t      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\t      if (disableGlobbing || !isGlob(path)) {\n\t        return absPath;\n\t      }\n\t      return normalizePath(absPath);\n\t    });\n\t  }\n\n\t  // set aside negated glob strings\n\t  paths = paths.filter((path) => {\n\t    if (path.startsWith(BANG)) {\n\t      this._ignoredPaths.add(path.slice(1));\n\t      return false;\n\t    }\n\n\t    // if a path is being added that was previously ignored, stop ignoring it\n\t    this._ignoredPaths.delete(path);\n\t    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n\t    // reset the cached userIgnored anymatch fn\n\t    // to make ignoredPaths changes effective\n\t    this._userIgnored = undefined;\n\n\t    return true;\n\t  });\n\n\t  if (this.options.useFsEvents && this._fsEventsHandler) {\n\t    if (!this._readyCount) this._readyCount = paths.length;\n\t    if (this.options.persistent) this._readyCount += paths.length;\n\t    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n\t  } else {\n\t    if (!this._readyCount) this._readyCount = 0;\n\t    this._readyCount += paths.length;\n\t    Promise.all(\n\t      paths.map(async path => {\n\t        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n\t        if (res) this._emitReady();\n\t        return res;\n\t      })\n\t    ).then(results => {\n\t      if (this.closed) return;\n\t      results.filter(item => item).forEach(item => {\n\t        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n\t      });\n\t    });\n\t  }\n\n\t  return this;\n\t}\n\n\t/**\n\t * Close watchers or start ignoring events from specified paths.\n\t * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n\t * @returns {FSWatcher} for chaining\n\t*/\n\tunwatch(paths_) {\n\t  if (this.closed) return this;\n\t  const paths = unifyPaths(paths_);\n\t  const {cwd} = this.options;\n\n\t  paths.forEach((path) => {\n\t    // convert to absolute path unless relative path already matches\n\t    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n\t      if (cwd) path = sysPath.join(cwd, path);\n\t      path = sysPath.resolve(path);\n\t    }\n\n\t    this._closePath(path);\n\n\t    this._ignoredPaths.add(path);\n\t    if (this._watched.has(path)) {\n\t      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n\t    }\n\n\t    // reset the cached userIgnored anymatch fn\n\t    // to make ignoredPaths changes effective\n\t    this._userIgnored = undefined;\n\t  });\n\n\t  return this;\n\t}\n\n\t/**\n\t * Close watchers and remove all listeners from watched paths.\n\t * @returns {Promise<void>}.\n\t*/\n\tclose() {\n\t  if (this.closed) return this._closePromise;\n\t  this.closed = true;\n\n\t  // Memory management.\n\t  this.removeAllListeners();\n\t  const closers = [];\n\t  this._closers.forEach(closerList => closerList.forEach(closer => {\n\t    const promise = closer();\n\t    if (promise instanceof Promise) closers.push(promise);\n\t  }));\n\t  this._streams.forEach(stream => stream.destroy());\n\t  this._userIgnored = undefined;\n\t  this._readyCount = 0;\n\t  this._readyEmitted = false;\n\t  this._watched.forEach(dirent => dirent.dispose());\n\t  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n\t    this[`_${key}`].clear();\n\t  });\n\n\t  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n\t  return this._closePromise;\n\t}\n\n\t/**\n\t * Expose list of watched paths\n\t * @returns {Object} for chaining\n\t*/\n\tgetWatched() {\n\t  const watchList = {};\n\t  this._watched.forEach((entry, dir) => {\n\t    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n\t    watchList[key || ONE_DOT] = entry.getChildren().sort();\n\t  });\n\t  return watchList;\n\t}\n\n\temitWithAll(event, args) {\n\t  this.emit(...args);\n\t  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n\t}\n\n\t// Common helpers\n\t// --------------\n\n\t/**\n\t * Normalize and emit events.\n\t * Calling _emit DOES NOT MEAN emit() would be called!\n\t * @param {EventName} event Type of event\n\t * @param {Path} path File or directory path\n\t * @param {*=} val1 arguments to be passed with event\n\t * @param {*=} val2\n\t * @param {*=} val3\n\t * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n\t */\n\tasync _emit(event, path, val1, val2, val3) {\n\t  if (this.closed) return;\n\n\t  const opts = this.options;\n\t  if (isWindows) path = sysPath.normalize(path);\n\t  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n\t  /** @type Array<any> */\n\t  const args = [event, path];\n\t  if (val3 !== undefined) args.push(val1, val2, val3);\n\t  else if (val2 !== undefined) args.push(val1, val2);\n\t  else if (val1 !== undefined) args.push(val1);\n\n\t  const awf = opts.awaitWriteFinish;\n\t  let pw;\n\t  if (awf && (pw = this._pendingWrites.get(path))) {\n\t    pw.lastChange = new Date();\n\t    return this;\n\t  }\n\n\t  if (opts.atomic) {\n\t    if (event === EV_UNLINK) {\n\t      this._pendingUnlinks.set(path, args);\n\t      setTimeout(() => {\n\t        this._pendingUnlinks.forEach((entry, path) => {\n\t          this.emit(...entry);\n\t          this.emit(EV_ALL, ...entry);\n\t          this._pendingUnlinks.delete(path);\n\t        });\n\t      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n\t      return this;\n\t    }\n\t    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n\t      event = args[0] = EV_CHANGE;\n\t      this._pendingUnlinks.delete(path);\n\t    }\n\t  }\n\n\t  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n\t    const awfEmit = (err, stats) => {\n\t      if (err) {\n\t        event = args[0] = EV_ERROR;\n\t        args[1] = err;\n\t        this.emitWithAll(event, args);\n\t      } else if (stats) {\n\t        // if stats doesn't exist the file must have been deleted\n\t        if (args.length > 2) {\n\t          args[2] = stats;\n\t        } else {\n\t          args.push(stats);\n\t        }\n\t        this.emitWithAll(event, args);\n\t      }\n\t    };\n\n\t    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\t    return this;\n\t  }\n\n\t  if (event === EV_CHANGE) {\n\t    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n\t    if (isThrottled) return this;\n\t  }\n\n\t  if (opts.alwaysStat && val1 === undefined &&\n\t    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n\t  ) {\n\t    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n\t    let stats;\n\t    try {\n\t      stats = await stat(fullPath);\n\t    } catch (err) {}\n\t    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\t    if (!stats || this.closed) return;\n\t    args.push(stats);\n\t  }\n\t  this.emitWithAll(event, args);\n\n\t  return this;\n\t}\n\n\t/**\n\t * Common handler for errors\n\t * @param {Error} error\n\t * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n\t */\n\t_handleError(error) {\n\t  const code = error && error.code;\n\t  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n\t    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n\t  ) {\n\t    this.emit(EV_ERROR, error);\n\t  }\n\t  return error || this.closed;\n\t}\n\n\t/**\n\t * Helper utility for throttling\n\t * @param {ThrottleType} actionType type being throttled\n\t * @param {Path} path being acted upon\n\t * @param {Number} timeout duration of time to suppress duplicate actions\n\t * @returns {Object|false} tracking object or false if action should be suppressed\n\t */\n\t_throttle(actionType, path, timeout) {\n\t  if (!this._throttled.has(actionType)) {\n\t    this._throttled.set(actionType, new Map());\n\t  }\n\n\t  /** @type {Map<Path, Object>} */\n\t  const action = this._throttled.get(actionType);\n\t  /** @type {Object} */\n\t  const actionPath = action.get(path);\n\n\t  if (actionPath) {\n\t    actionPath.count++;\n\t    return false;\n\t  }\n\n\t  let timeoutObject;\n\t  const clear = () => {\n\t    const item = action.get(path);\n\t    const count = item ? item.count : 0;\n\t    action.delete(path);\n\t    clearTimeout(timeoutObject);\n\t    if (item) clearTimeout(item.timeoutObject);\n\t    return count;\n\t  };\n\t  timeoutObject = setTimeout(clear, timeout);\n\t  const thr = {timeoutObject, clear, count: 0};\n\t  action.set(path, thr);\n\t  return thr;\n\t}\n\n\t_incrReadyCount() {\n\t  return this._readyCount++;\n\t}\n\n\t/**\n\t * Awaits write operation to finish.\n\t * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n\t * @param {Path} path being acted upon\n\t * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n\t * @param {EventName} event\n\t * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n\t */\n\t_awaitWriteFinish(path, threshold, event, awfEmit) {\n\t  let timeoutHandler;\n\n\t  let fullPath = path;\n\t  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n\t    fullPath = sysPath.join(this.options.cwd, path);\n\t  }\n\n\t  const now = new Date();\n\n\t  const awaitWriteFinish = (prevStat) => {\n\t    fs.stat(fullPath, (err, curStat) => {\n\t      if (err || !this._pendingWrites.has(path)) {\n\t        if (err && err.code !== 'ENOENT') awfEmit(err);\n\t        return;\n\t      }\n\n\t      const now = Number(new Date());\n\n\t      if (prevStat && curStat.size !== prevStat.size) {\n\t        this._pendingWrites.get(path).lastChange = now;\n\t      }\n\t      const pw = this._pendingWrites.get(path);\n\t      const df = now - pw.lastChange;\n\n\t      if (df >= threshold) {\n\t        this._pendingWrites.delete(path);\n\t        awfEmit(undefined, curStat);\n\t      } else {\n\t        timeoutHandler = setTimeout(\n\t          awaitWriteFinish,\n\t          this.options.awaitWriteFinish.pollInterval,\n\t          curStat\n\t        );\n\t      }\n\t    });\n\t  };\n\n\t  if (!this._pendingWrites.has(path)) {\n\t    this._pendingWrites.set(path, {\n\t      lastChange: now,\n\t      cancelWait: () => {\n\t        this._pendingWrites.delete(path);\n\t        clearTimeout(timeoutHandler);\n\t        return event;\n\t      }\n\t    });\n\t    timeoutHandler = setTimeout(\n\t      awaitWriteFinish,\n\t      this.options.awaitWriteFinish.pollInterval\n\t    );\n\t  }\n\t}\n\n\t_getGlobIgnored() {\n\t  return [...this._ignoredPaths.values()];\n\t}\n\n\t/**\n\t * Determines whether user has asked to ignore this path.\n\t * @param {Path} path filepath or dir\n\t * @param {fs.Stats=} stats result of fs.stat\n\t * @returns {Boolean}\n\t */\n\t_isIgnored(path, stats) {\n\t  if (this.options.atomic && DOT_RE.test(path)) return true;\n\t  if (!this._userIgnored) {\n\t    const {cwd} = this.options;\n\t    const ign = this.options.ignored;\n\n\t    const ignored = ign && ign.map(normalizeIgnored(cwd));\n\t    const paths = arrify(ignored)\n\t      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n\t      .map((path) => path + SLASH_GLOBSTAR);\n\t    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\t    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n\t  }\n\n\t  return this._userIgnored([path, stats]);\n\t}\n\n\t_isntIgnored(path, stat) {\n\t  return !this._isIgnored(path, stat);\n\t}\n\n\t/**\n\t * Provides a set of common helpers and properties relating to symlink and glob handling.\n\t * @param {Path} path file, directory, or glob pattern being watched\n\t * @param {Number=} depth at any depth > 0, this isn't a glob\n\t * @returns {WatchHelper} object containing helpers for this path\n\t */\n\t_getWatchHelpers(path, depth) {\n\t  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n\t  const follow = this.options.followSymlinks;\n\n\t  return new WatchHelper(path, watchPath, follow, this);\n\t}\n\n\t// Directory helpers\n\t// -----------------\n\n\t/**\n\t * Provides directory tracking objects\n\t * @param {String} directory path of the directory\n\t * @returns {DirEntry} the directory's tracking object\n\t */\n\t_getWatchedDir(directory) {\n\t  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n\t  const dir = sysPath.resolve(directory);\n\t  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n\t  return this._watched.get(dir);\n\t}\n\n\t// File helpers\n\t// ------------\n\n\t/**\n\t * Check for read permissions.\n\t * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n\t * @param {fs.Stats} stats - object, result of fs_stat\n\t * @returns {Boolean} indicates whether the file can be read\n\t*/\n\t_hasReadPermissions(stats) {\n\t  if (this.options.ignorePermissionErrors) return true;\n\n\t  // stats.mode may be bigint\n\t  const md = stats && Number.parseInt(stats.mode, 10);\n\t  const st = md & 0o777;\n\t  const it = Number.parseInt(st.toString(8)[0], 10);\n\t  return Boolean(4 & it);\n\t}\n\n\t/**\n\t * Handles emitting unlink events for\n\t * files and directories, and via recursion, for\n\t * files and directories within directories that are unlinked\n\t * @param {String} directory within which the following item is located\n\t * @param {String} item      base path of item/directory\n\t * @returns {void}\n\t*/\n\t_remove(directory, item, isDirectory) {\n\t  // if what is being deleted is a directory, get that directory's paths\n\t  // for recursive deleting and cleaning of watched object\n\t  // if it is not a directory, nestedDirectoryChildren will be empty array\n\t  const path = sysPath.join(directory, item);\n\t  const fullPath = sysPath.resolve(path);\n\t  isDirectory = isDirectory != null\n\t    ? isDirectory\n\t    : this._watched.has(path) || this._watched.has(fullPath);\n\n\t  // prevent duplicate handling in case of arriving here nearly simultaneously\n\t  // via multiple paths (such as _handleFile and _handleDir)\n\t  if (!this._throttle('remove', path, 100)) return;\n\n\t  // if the only watched file is removed, watch for its return\n\t  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n\t    this.add(directory, item, true);\n\t  }\n\n\t  // This will create a new entry in the watched object in either case\n\t  // so we got to do the directory check beforehand\n\t  const wp = this._getWatchedDir(path);\n\t  const nestedDirectoryChildren = wp.getChildren();\n\n\t  // Recursively remove children directories / files.\n\t  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n\t  // Check if item was on the watched list and remove it\n\t  const parent = this._getWatchedDir(directory);\n\t  const wasTracked = parent.has(item);\n\t  parent.remove(item);\n\n\t  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n\t  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n\t  // but never removed from the map in case the path was deleted.\n\t  // This leads to an incorrect state if the path was recreated:\n\t  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\t  if (this._symlinkPaths.has(fullPath)) {\n\t    this._symlinkPaths.delete(fullPath);\n\t  }\n\n\t  // If we wait for this file to be fully written, cancel the wait.\n\t  let relPath = path;\n\t  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\t  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n\t    const event = this._pendingWrites.get(relPath).cancelWait();\n\t    if (event === EV_ADD) return;\n\t  }\n\n\t  // The Entry will either be a directory that just got removed\n\t  // or a bogus entry to a file, in either case we have to remove it\n\t  this._watched.delete(path);\n\t  this._watched.delete(fullPath);\n\t  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n\t  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n\t  // Avoid conflicts if we later create another file with the same name\n\t  if (!this.options.useFsEvents) {\n\t    this._closePath(path);\n\t  }\n\t}\n\n\t/**\n\t * Closes all watchers for a path\n\t * @param {Path} path\n\t */\n\t_closePath(path) {\n\t  this._closeFile(path);\n\t  const dir = sysPath.dirname(path);\n\t  this._getWatchedDir(dir).remove(sysPath.basename(path));\n\t}\n\n\t/**\n\t * Closes only file-specific watchers\n\t * @param {Path} path\n\t */\n\t_closeFile(path) {\n\t  const closers = this._closers.get(path);\n\t  if (!closers) return;\n\t  closers.forEach(closer => closer());\n\t  this._closers.delete(path);\n\t}\n\n\t/**\n\t *\n\t * @param {Path} path\n\t * @param {Function} closer\n\t */\n\t_addPathCloser(path, closer) {\n\t  if (!closer) return;\n\t  let list = this._closers.get(path);\n\t  if (!list) {\n\t    list = [];\n\t    this._closers.set(path, list);\n\t  }\n\t  list.push(closer);\n\t}\n\n\t_readdirp(root, opts) {\n\t  if (this.closed) return;\n\t  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n\t  let stream = readdirp(root, options);\n\t  this._streams.add(stream);\n\t  stream.once(STR_CLOSE, () => {\n\t    stream = undefined;\n\t  });\n\t  stream.once(STR_END, () => {\n\t    if (stream) {\n\t      this._streams.delete(stream);\n\t      stream = undefined;\n\t    }\n\t  });\n\t  return stream;\n\t}\n\n\t}\n\n\t// Export FSWatcher class\n\tchokidar$1.FSWatcher = FSWatcher;\n\n\t/**\n\t * Instantiates watcher with paths to be tracked.\n\t * @param {String|Array<String>} paths file/directory paths and/or globs\n\t * @param {Object=} options chokidar opts\n\t * @returns an instance of FSWatcher for chaining.\n\t */\n\tconst watch = (paths, options) => {\n\t  const watcher = new FSWatcher(options);\n\t  watcher.add(paths);\n\t  return watcher;\n\t};\n\n\tchokidar$1.watch = watch;\n\treturn chokidar$1;\n}\n\nvar chokidarExports = /*@__PURE__*/ requireChokidar();\nconst chokidar = /*@__PURE__*/getDefaultExportFromCjs(chokidarExports);\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        if (isTransformDependency) {\n            const watcher = this.transformWatchers.get(id) ?? this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isFreeBSD = platform() === 'freebsd';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux || isFreeBSD) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null, //delete file from map\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(optionsList, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.closed = false;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = optionsList.map(options => new Task(this, options));\n        for (const { watch } of optionsList) {\n            if (watch && typeof watch.buildDelay === 'number') {\n                this.buildDelay = Math.max(this.buildDelay, watch.buildDelay);\n            }\n        }\n        process$1.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.closed)\n            return;\n        this.closed = true;\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emit('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const previousEvent = this.invalidatedIds.get(file.id);\n            const event = previousEvent ? eventsRewrites[previousEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emit('change', id, { event })));\n                this.invalidatedIds.clear();\n                await this.emitter.emit('restart');\n                this.emitter.removeListenersForCurrentRun();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                await this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                await this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        await this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        await this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, options) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.options = options;\n        this.skipWrite = Boolean(options.watch && options.watch.skipWrite);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return path.resolve(output.file || output.dir);\n            return undefined;\n        });\n        this.watchOptions = this.options.watch || {};\n        this.filter = createFilter(this.watchOptions.include, this.watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...this.watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n        this.watchOptions.onInvalidate?.(id);\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        await this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            if (!this.skipWrite) {\n                await Promise.all(this.outputs.map(output => result.write(output)));\n                if (this.closed) {\n                    return;\n                }\n                this.updateWatchedFiles(result);\n            }\n            await this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            await this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.includes(id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n"],"mappings":"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N,IAAI,EACJ,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,UAAU,EACV,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,WAAW,EACX,WAAW,EACX,WAAW,EACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,SAAS,EACT,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,IAAI,EACJ,KAAK,EACL,SAAS,EACT,IAAI,EACJ,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,SAAS,EACT,OAAO,EACP,GAAG,EACH,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,KAAK,EACL,KAAK,EACL,WAAW,EACX,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,KAAK,EACL,QAAQ,EACR,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,KAAK,EACL,IAAI,EACJ,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,MAAM,EACN,KAAK,EACL,MAAM,EACN,MAAM,EACN,IAAI,EACJ,OAAO,EACP,KAAK,EACL,KAAK,EACL,KAAK,EACL,IAAI,EACJ,GAAG,EACH,KAAK,EACL,MAAM,CACN;AAED,IAAIC,gBAAgB;AACpB,IAAIC,2BAA2B;A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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}