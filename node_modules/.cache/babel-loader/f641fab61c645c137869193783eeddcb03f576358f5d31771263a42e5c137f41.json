{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport path, { posix } from \"path\";\nimport { fdir } from \"fdir\";\nimport picomatch from \"picomatch\";\n\n//#region src/utils.ts\nconst ONLY_PARENT_DIRECTORIES = /^(\\/?\\.\\.)+$/;\nfunction getPartialMatcher(patterns, options) {\n  const patternsCount = patterns.length;\n  const patternsParts = Array(patternsCount);\n  const regexes = Array(patternsCount);\n  for (let i = 0; i < patternsCount; i++) {\n    const parts = splitPattern(patterns[i]);\n    patternsParts[i] = parts;\n    const partsCount = parts.length;\n    const partRegexes = Array(partsCount);\n    for (let j = 0; j < partsCount; j++) partRegexes[j] = picomatch.makeRe(parts[j], options);\n    regexes[i] = partRegexes;\n  }\n  return input => {\n    const inputParts = input.split(\"/\");\n    if (inputParts[0] === \"..\" && ONLY_PARENT_DIRECTORIES.test(input)) return true;\n    for (let i = 0; i < patterns.length; i++) {\n      const patternParts = patternsParts[i];\n      const regex = regexes[i];\n      const inputPatternCount = inputParts.length;\n      const minParts = Math.min(inputPatternCount, patternParts.length);\n      let j = 0;\n      while (j < minParts) {\n        const part = patternParts[j];\n        if (part.includes(\"/\")) return true;\n        const match = regex[j].test(inputParts[j]);\n        if (!match) break;\n        if (part === \"**\") return true;\n        j++;\n      }\n      if (j === inputPatternCount) return true;\n    }\n    return false;\n  };\n}\nconst splitPatternOptions = {\n  parts: true\n};\nfunction splitPattern(path$1) {\n  var _result$parts;\n  const result = picomatch.scan(path$1, splitPatternOptions);\n  return ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$1];\n}\nconst isWin = process.platform === \"win32\";\nconst ESCAPED_WIN32_BACKSLASHES = /\\\\(?![()[\\]{}!+@])/g;\nfunction convertPosixPathToPattern(path$1) {\n  return escapePosixPath(path$1);\n}\nfunction convertWin32PathToPattern(path$1) {\n  return escapeWin32Path(path$1).replace(ESCAPED_WIN32_BACKSLASHES, \"/\");\n}\nconst convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;\nconst POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))/g;\nconst WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())/g;\nconst escapePosixPath = path$1 => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nconst escapeWin32Path = path$1 => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nconst escapePath = isWin ? escapeWin32Path : escapePosixPath;\nfunction isDynamicPattern(pattern, options) {\n  if ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;\n  const scan = picomatch.scan(pattern);\n  return scan.isGlob || scan.negated;\n}\nfunction log(...tasks) {\n  console.log(`[tinyglobby ${new Date().toLocaleTimeString(\"es\")}]`, ...tasks);\n}\n\n//#endregion\n//#region src/index.ts\nconst PARENT_DIRECTORY = /^(\\/?\\.\\.)+/;\nconst ESCAPING_BACKSLASHES = /\\\\(?=[()[\\]{}!*+?@|])/g;\nconst BACKSLASHES = /\\\\/g;\nfunction normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {\n  let result = pattern;\n  if (pattern.endsWith(\"/\")) result = pattern.slice(0, -1);\n  if (!result.endsWith(\"*\") && expandDirectories) result += \"/**\";\n  const escapedCwd = escapePath(cwd);\n  if (path.isAbsolute(result.replace(ESCAPING_BACKSLASHES, \"\"))) result = posix.relative(escapedCwd, result);else result = posix.normalize(result);\n  const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);\n  const parts = splitPattern(result);\n  if (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {\n    const n = (parentDirectoryMatch[0].length + 1) / 3;\n    let i = 0;\n    const cwdParts = escapedCwd.split(\"/\");\n    while (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {\n      result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || \".\";\n      i++;\n    }\n    const potentialRoot = posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));\n    if (!potentialRoot.startsWith(\".\") && props.root.length > potentialRoot.length) {\n      props.root = potentialRoot;\n      props.depthOffset = -n + i;\n    }\n  }\n  if (!isIgnore && props.depthOffset >= 0) {\n    var _props$commonPath;\n    (_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);\n    const newCommonPath = [];\n    const length = Math.min(props.commonPath.length, parts.length);\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === \"**\" && !parts[i + 1]) {\n        newCommonPath.pop();\n        break;\n      }\n      if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;\n      newCommonPath.push(part);\n    }\n    props.depthOffset = newCommonPath.length;\n    props.commonPath = newCommonPath;\n    props.root = newCommonPath.length > 0 ? path.posix.join(cwd, ...newCommonPath) : cwd;\n  }\n  return result;\n}\nfunction processPatterns({\n  patterns,\n  ignore = [],\n  expandDirectories = true\n}, cwd, props) {\n  if (typeof patterns === \"string\") patterns = [patterns];else if (!patterns) patterns = [\"**/*\"];\n  if (typeof ignore === \"string\") ignore = [ignore];\n  const matchPatterns = [];\n  const ignorePatterns = [];\n  for (const pattern of ignore) {\n    if (!pattern) continue;\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));\n  }\n  for (const pattern of patterns) {\n    if (!pattern) continue;\n    if (pattern[0] !== \"!\" || pattern[1] === \"(\") matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));else if (pattern[1] !== \"!\" || pattern[2] === \"(\") ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));\n  }\n  return {\n    match: matchPatterns,\n    ignore: ignorePatterns\n  };\n}\nfunction getRelativePath(path$1, cwd, root) {\n  return posix.relative(cwd, `${root}/${path$1}`) || \".\";\n}\nfunction processPath(path$1, cwd, root, isDirectory, absolute) {\n  const relativePath = absolute ? path$1.slice(root === \"/\" ? 1 : root.length + 1) || \".\" : path$1;\n  if (root === cwd) return isDirectory && relativePath !== \".\" ? relativePath.slice(0, -1) : relativePath;\n  return getRelativePath(relativePath, cwd, root);\n}\nfunction formatPaths(paths, cwd, root) {\n  for (let i = paths.length - 1; i >= 0; i--) {\n    const path$1 = paths[i];\n    paths[i] = getRelativePath(path$1, cwd, root) + (!path$1 || path$1.endsWith(\"/\") ? \"/\" : \"\");\n  }\n  return paths;\n}\nfunction crawl(options, cwd, sync) {\n  if (process.env.TINYGLOBBY_DEBUG) options.debug = true;\n  if (options.debug) log(\"globbing with options:\", options, \"cwd:\", cwd);\n  if (Array.isArray(options.patterns) && options.patterns.length === 0) return sync ? [] : Promise.resolve([]);\n  const props = {\n    root: cwd,\n    commonPath: null,\n    depthOffset: 0\n  };\n  const processed = processPatterns(options, cwd, props);\n  const nocase = options.caseSensitiveMatch === false;\n  if (options.debug) log(\"internal processing patterns:\", processed);\n  const matcher = picomatch(processed.match, {\n    dot: options.dot,\n    nocase,\n    ignore: processed.ignore\n  });\n  const ignore = picomatch(processed.ignore, {\n    dot: options.dot,\n    nocase\n  });\n  const partialMatcher = getPartialMatcher(processed.match, {\n    dot: options.dot,\n    nocase\n  });\n  const fdirOptions = {\n    filters: [options.debug ? (p, isDirectory) => {\n      const path$1 = processPath(p, cwd, props.root, isDirectory, options.absolute);\n      const matches = matcher(path$1);\n      if (matches) log(`matched ${path$1}`);\n      return matches;\n    } : (p, isDirectory) => matcher(processPath(p, cwd, props.root, isDirectory, options.absolute))],\n    exclude: options.debug ? (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      const skipped = relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n      if (skipped) log(`skipped ${p}`);else log(`crawling ${p}`);\n      return skipped;\n    } : (_, p) => {\n      const relativePath = processPath(p, cwd, props.root, true, true);\n      return relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n    },\n    pathSeparator: \"/\",\n    relativePaths: true,\n    resolveSymlinks: true\n  };\n  if (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);\n  if (options.absolute) {\n    fdirOptions.relativePaths = false;\n    fdirOptions.resolvePaths = true;\n    fdirOptions.includeBasePath = true;\n  }\n  if (options.followSymbolicLinks === false) {\n    fdirOptions.resolveSymlinks = false;\n    fdirOptions.excludeSymlinks = true;\n  }\n  if (options.onlyDirectories) {\n    fdirOptions.excludeFiles = true;\n    fdirOptions.includeDirs = true;\n  } else if (options.onlyFiles === false) fdirOptions.includeDirs = true;\n  props.root = props.root.replace(BACKSLASHES, \"\");\n  const root = props.root;\n  if (options.debug) log(\"internal properties:\", props);\n  const api = new fdir(fdirOptions).crawl(root);\n  if (cwd === root || options.absolute) return sync ? api.sync() : api.withPromise();\n  return sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then(paths => formatPaths(paths, cwd, root));\n}\nasync function glob(patternsOrOptions, options) {\n  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? {\n    ...options,\n    patterns: patternsOrOptions\n  } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, false);\n}\nfunction globSync(patternsOrOptions, options) {\n  if (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n  const opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? {\n    ...options,\n    patterns: patternsOrOptions\n  } : patternsOrOptions;\n  const cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n  return crawl(opts, cwd, true);\n}\n\n//#endregion\nexport { convertPathToPattern, escapePath, glob, globSync, isDynamicPattern };","map":{"version":3,"names":["path","posix","fdir","picomatch","ONLY_PARENT_DIRECTORIES","getPartialMatcher","patterns","options","patternsCount","length","patternsParts","Array","regexes","i","parts","splitPattern","partsCount","partRegexes","j","makeRe","input","inputParts","split","test","patternParts","regex","inputPatternCount","minParts","Math","min","part","includes","match","splitPatternOptions","path$1","_result$parts","result","scan","isWin","process","platform","ESCAPED_WIN32_BACKSLASHES","convertPosixPathToPattern","escapePosixPath","convertWin32PathToPattern","escapeWin32Path","replace","convertPathToPattern","POSIX_UNESCAPED_GLOB_SYMBOLS","WIN32_UNESCAPED_GLOB_SYMBOLS","escapePath","isDynamicPattern","pattern","caseSensitiveMatch","isGlob","negated","log","tasks","console","Date","toLocaleTimeString","PARENT_DIRECTORY","ESCAPING_BACKSLASHES","BACKSLASHES","normalizePattern","expandDirectories","cwd","props","isIgnore","endsWith","slice","escapedCwd","isAbsolute","relative","normalize","parentDirectoryMatch","exec","n","cwdParts","potentialRoot","join","startsWith","root","depthOffset","_props$commonPath","commonPath","newCommonPath","pop","push","processPatterns","ignore","matchPatterns","ignorePatterns","getRelativePath","processPath","isDirectory","absolute","relativePath","formatPaths","paths","crawl","sync","env","TINYGLOBBY_DEBUG","debug","isArray","Promise","resolve","processed","nocase","matcher","dot","partialMatcher","fdirOptions","filters","p","matches","exclude","_","skipped","pathSeparator","relativePaths","resolveSymlinks","deep","maxDepth","round","resolvePaths","includeBasePath","followSymbolicLinks","excludeSymlinks","onlyDirectories","excludeFiles","includeDirs","onlyFiles","api","withPromise","then","glob","patternsOrOptions","Error","opts","globSync"],"sources":["/Users/linhankuan/fvl2025/node_modules/tinyglobby/dist/index.mjs"],"sourcesContent":["import path, { posix } from \"path\";\nimport { fdir } from \"fdir\";\nimport picomatch from \"picomatch\";\n\n//#region src/utils.ts\nconst ONLY_PARENT_DIRECTORIES = /^(\\/?\\.\\.)+$/;\nfunction getPartialMatcher(patterns, options) {\n\tconst patternsCount = patterns.length;\n\tconst patternsParts = Array(patternsCount);\n\tconst regexes = Array(patternsCount);\n\tfor (let i = 0; i < patternsCount; i++) {\n\t\tconst parts = splitPattern(patterns[i]);\n\t\tpatternsParts[i] = parts;\n\t\tconst partsCount = parts.length;\n\t\tconst partRegexes = Array(partsCount);\n\t\tfor (let j = 0; j < partsCount; j++) partRegexes[j] = picomatch.makeRe(parts[j], options);\n\t\tregexes[i] = partRegexes;\n\t}\n\treturn (input) => {\n\t\tconst inputParts = input.split(\"/\");\n\t\tif (inputParts[0] === \"..\" && ONLY_PARENT_DIRECTORIES.test(input)) return true;\n\t\tfor (let i = 0; i < patterns.length; i++) {\n\t\t\tconst patternParts = patternsParts[i];\n\t\t\tconst regex = regexes[i];\n\t\t\tconst inputPatternCount = inputParts.length;\n\t\t\tconst minParts = Math.min(inputPatternCount, patternParts.length);\n\t\t\tlet j = 0;\n\t\t\twhile (j < minParts) {\n\t\t\t\tconst part = patternParts[j];\n\t\t\t\tif (part.includes(\"/\")) return true;\n\t\t\t\tconst match = regex[j].test(inputParts[j]);\n\t\t\t\tif (!match) break;\n\t\t\t\tif (part === \"**\") return true;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tif (j === inputPatternCount) return true;\n\t\t}\n\t\treturn false;\n\t};\n}\nconst splitPatternOptions = { parts: true };\nfunction splitPattern(path$1) {\n\tvar _result$parts;\n\tconst result = picomatch.scan(path$1, splitPatternOptions);\n\treturn ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$1];\n}\nconst isWin = process.platform === \"win32\";\nconst ESCAPED_WIN32_BACKSLASHES = /\\\\(?![()[\\]{}!+@])/g;\nfunction convertPosixPathToPattern(path$1) {\n\treturn escapePosixPath(path$1);\n}\nfunction convertWin32PathToPattern(path$1) {\n\treturn escapeWin32Path(path$1).replace(ESCAPED_WIN32_BACKSLASHES, \"/\");\n}\nconst convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;\nconst POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}*?|]|^!|[!+@](?=\\()|\\\\(?![()[\\]{}!*+?@|]))/g;\nconst WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\\\)([()[\\]{}]|^!|[!+@](?=\\())/g;\nconst escapePosixPath = (path$1) => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nconst escapeWin32Path = (path$1) => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, \"\\\\$&\");\nconst escapePath = isWin ? escapeWin32Path : escapePosixPath;\nfunction isDynamicPattern(pattern, options) {\n\tif ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;\n\tconst scan = picomatch.scan(pattern);\n\treturn scan.isGlob || scan.negated;\n}\nfunction log(...tasks) {\n\tconsole.log(`[tinyglobby ${new Date().toLocaleTimeString(\"es\")}]`, ...tasks);\n}\n\n//#endregion\n//#region src/index.ts\nconst PARENT_DIRECTORY = /^(\\/?\\.\\.)+/;\nconst ESCAPING_BACKSLASHES = /\\\\(?=[()[\\]{}!*+?@|])/g;\nconst BACKSLASHES = /\\\\/g;\nfunction normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {\n\tlet result = pattern;\n\tif (pattern.endsWith(\"/\")) result = pattern.slice(0, -1);\n\tif (!result.endsWith(\"*\") && expandDirectories) result += \"/**\";\n\tconst escapedCwd = escapePath(cwd);\n\tif (path.isAbsolute(result.replace(ESCAPING_BACKSLASHES, \"\"))) result = posix.relative(escapedCwd, result);\n\telse result = posix.normalize(result);\n\tconst parentDirectoryMatch = PARENT_DIRECTORY.exec(result);\n\tconst parts = splitPattern(result);\n\tif (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {\n\t\tconst n = (parentDirectoryMatch[0].length + 1) / 3;\n\t\tlet i = 0;\n\t\tconst cwdParts = escapedCwd.split(\"/\");\n\t\twhile (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {\n\t\t\tresult = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || \".\";\n\t\t\ti++;\n\t\t}\n\t\tconst potentialRoot = posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));\n\t\tif (!potentialRoot.startsWith(\".\") && props.root.length > potentialRoot.length) {\n\t\t\tprops.root = potentialRoot;\n\t\t\tprops.depthOffset = -n + i;\n\t\t}\n\t}\n\tif (!isIgnore && props.depthOffset >= 0) {\n\t\tvar _props$commonPath;\n\t\t(_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);\n\t\tconst newCommonPath = [];\n\t\tconst length = Math.min(props.commonPath.length, parts.length);\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst part = parts[i];\n\t\t\tif (part === \"**\" && !parts[i + 1]) {\n\t\t\t\tnewCommonPath.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;\n\t\t\tnewCommonPath.push(part);\n\t\t}\n\t\tprops.depthOffset = newCommonPath.length;\n\t\tprops.commonPath = newCommonPath;\n\t\tprops.root = newCommonPath.length > 0 ? path.posix.join(cwd, ...newCommonPath) : cwd;\n\t}\n\treturn result;\n}\nfunction processPatterns({ patterns, ignore = [], expandDirectories = true }, cwd, props) {\n\tif (typeof patterns === \"string\") patterns = [patterns];\n\telse if (!patterns) patterns = [\"**/*\"];\n\tif (typeof ignore === \"string\") ignore = [ignore];\n\tconst matchPatterns = [];\n\tconst ignorePatterns = [];\n\tfor (const pattern of ignore) {\n\t\tif (!pattern) continue;\n\t\tif (pattern[0] !== \"!\" || pattern[1] === \"(\") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));\n\t}\n\tfor (const pattern of patterns) {\n\t\tif (!pattern) continue;\n\t\tif (pattern[0] !== \"!\" || pattern[1] === \"(\") matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));\n\t\telse if (pattern[1] !== \"!\" || pattern[2] === \"(\") ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));\n\t}\n\treturn {\n\t\tmatch: matchPatterns,\n\t\tignore: ignorePatterns\n\t};\n}\nfunction getRelativePath(path$1, cwd, root) {\n\treturn posix.relative(cwd, `${root}/${path$1}`) || \".\";\n}\nfunction processPath(path$1, cwd, root, isDirectory, absolute) {\n\tconst relativePath = absolute ? path$1.slice(root === \"/\" ? 1 : root.length + 1) || \".\" : path$1;\n\tif (root === cwd) return isDirectory && relativePath !== \".\" ? relativePath.slice(0, -1) : relativePath;\n\treturn getRelativePath(relativePath, cwd, root);\n}\nfunction formatPaths(paths, cwd, root) {\n\tfor (let i = paths.length - 1; i >= 0; i--) {\n\t\tconst path$1 = paths[i];\n\t\tpaths[i] = getRelativePath(path$1, cwd, root) + (!path$1 || path$1.endsWith(\"/\") ? \"/\" : \"\");\n\t}\n\treturn paths;\n}\nfunction crawl(options, cwd, sync) {\n\tif (process.env.TINYGLOBBY_DEBUG) options.debug = true;\n\tif (options.debug) log(\"globbing with options:\", options, \"cwd:\", cwd);\n\tif (Array.isArray(options.patterns) && options.patterns.length === 0) return sync ? [] : Promise.resolve([]);\n\tconst props = {\n\t\troot: cwd,\n\t\tcommonPath: null,\n\t\tdepthOffset: 0\n\t};\n\tconst processed = processPatterns(options, cwd, props);\n\tconst nocase = options.caseSensitiveMatch === false;\n\tif (options.debug) log(\"internal processing patterns:\", processed);\n\tconst matcher = picomatch(processed.match, {\n\t\tdot: options.dot,\n\t\tnocase,\n\t\tignore: processed.ignore\n\t});\n\tconst ignore = picomatch(processed.ignore, {\n\t\tdot: options.dot,\n\t\tnocase\n\t});\n\tconst partialMatcher = getPartialMatcher(processed.match, {\n\t\tdot: options.dot,\n\t\tnocase\n\t});\n\tconst fdirOptions = {\n\t\tfilters: [options.debug ? (p, isDirectory) => {\n\t\t\tconst path$1 = processPath(p, cwd, props.root, isDirectory, options.absolute);\n\t\t\tconst matches = matcher(path$1);\n\t\t\tif (matches) log(`matched ${path$1}`);\n\t\t\treturn matches;\n\t\t} : (p, isDirectory) => matcher(processPath(p, cwd, props.root, isDirectory, options.absolute))],\n\t\texclude: options.debug ? (_, p) => {\n\t\t\tconst relativePath = processPath(p, cwd, props.root, true, true);\n\t\t\tconst skipped = relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n\t\t\tif (skipped) log(`skipped ${p}`);\n\t\t\telse log(`crawling ${p}`);\n\t\t\treturn skipped;\n\t\t} : (_, p) => {\n\t\t\tconst relativePath = processPath(p, cwd, props.root, true, true);\n\t\t\treturn relativePath !== \".\" && !partialMatcher(relativePath) || ignore(relativePath);\n\t\t},\n\t\tpathSeparator: \"/\",\n\t\trelativePaths: true,\n\t\tresolveSymlinks: true\n\t};\n\tif (options.deep !== void 0) fdirOptions.maxDepth = Math.round(options.deep - props.depthOffset);\n\tif (options.absolute) {\n\t\tfdirOptions.relativePaths = false;\n\t\tfdirOptions.resolvePaths = true;\n\t\tfdirOptions.includeBasePath = true;\n\t}\n\tif (options.followSymbolicLinks === false) {\n\t\tfdirOptions.resolveSymlinks = false;\n\t\tfdirOptions.excludeSymlinks = true;\n\t}\n\tif (options.onlyDirectories) {\n\t\tfdirOptions.excludeFiles = true;\n\t\tfdirOptions.includeDirs = true;\n\t} else if (options.onlyFiles === false) fdirOptions.includeDirs = true;\n\tprops.root = props.root.replace(BACKSLASHES, \"\");\n\tconst root = props.root;\n\tif (options.debug) log(\"internal properties:\", props);\n\tconst api = new fdir(fdirOptions).crawl(root);\n\tif (cwd === root || options.absolute) return sync ? api.sync() : api.withPromise();\n\treturn sync ? formatPaths(api.sync(), cwd, root) : api.withPromise().then((paths) => formatPaths(paths, cwd, root));\n}\nasync function glob(patternsOrOptions, options) {\n\tif (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n\tconst opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? {\n\t\t...options,\n\t\tpatterns: patternsOrOptions\n\t} : patternsOrOptions;\n\tconst cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n\treturn crawl(opts, cwd, false);\n}\nfunction globSync(patternsOrOptions, options) {\n\tif (patternsOrOptions && (options === null || options === void 0 ? void 0 : options.patterns)) throw new Error(\"Cannot pass patterns as both an argument and an option\");\n\tconst opts = Array.isArray(patternsOrOptions) || typeof patternsOrOptions === \"string\" ? {\n\t\t...options,\n\t\tpatterns: patternsOrOptions\n\t} : patternsOrOptions;\n\tconst cwd = opts.cwd ? path.resolve(opts.cwd).replace(BACKSLASHES, \"/\") : process.cwd().replace(BACKSLASHES, \"/\");\n\treturn crawl(opts, cwd, true);\n}\n\n//#endregion\nexport { convertPathToPattern, escapePath, glob, globSync, isDynamicPattern };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}