{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { dirname, resolve, extname, posix, sep } from 'path';\nimport { emitWarning, cwd } from 'process';\nimport { readFileSync } from 'fs';\nimport { platform } from 'os';\n\n/**\r\n * @name recursiveChunk\r\n * @type {string}\r\n * \r\n * @description Shader chunk path\r\n * that caused a recursion error\r\n */\nlet recursiveChunk = '';\n\n/**\r\n * @const\r\n * @name allChunks\r\n * @type {readonly Set<string>}\r\n * \r\n * @description List of all shader chunks,\r\n * it's used to track included files\r\n */\nconst allChunks = new Set();\n\n/**\r\n * @const\r\n * @name dependentChunks\r\n * @type {readonly Map<string, string[]>}\r\n * \r\n * @description Map of shaders that import other chunks, it's\r\n * used to track included files in order to avoid recursion\r\n * - Key: shader path that uses other chunks as dependencies\r\n * - Value: list of chunk paths included within the shader\r\n */\nconst dependentChunks = new Map();\n\n/**\r\n * @const\r\n * @name duplicatedChunks\r\n * @type {readonly Map<string, string[]>}\r\n * \r\n * @description Map of duplicated shader\r\n * imports, used by warning messages\r\n */\nconst duplicatedChunks = new Map();\n\n/**\r\n * @function\r\n * @name resetSavedChunks\r\n * @description Clears all lists of saved chunks\r\n * and resets \"recursiveChunk\" path to empty\r\n * \r\n * @returns {string} Copy of \"recursiveChunk\" path\r\n */\nfunction resetSavedChunks() {\n  const chunk = recursiveChunk;\n  duplicatedChunks.clear();\n  dependentChunks.clear();\n  recursiveChunk = '';\n  allChunks.clear();\n  return chunk;\n}\n\n/**\r\n * @function\r\n * @name getRecursionCaller\r\n * @description Gets last chunk that caused a\r\n * recursion error from the \"dependentChunks\" list\r\n * \r\n * @returns {string} Chunk path that started a recursion\r\n */\nfunction getRecursionCaller() {\n  const dependencies = [...dependentChunks.keys()];\n  return dependencies[dependencies.length - 1];\n}\n\n/**\r\n * @function\r\n * @name checkDuplicatedImports\r\n * @description Checks if shader chunk was already included\r\n * and adds it to the \"duplicatedChunks\" list if yes\r\n * \r\n * @param {string} path Shader's absolute path\r\n * \r\n * @throws {Warning} If shader chunk was already included\r\n */\nfunction checkDuplicatedImports(path) {\n  const caller = getRecursionCaller();\n  const chunks = duplicatedChunks.get(caller) ?? [];\n  if (chunks.includes(path)) return;\n  chunks.push(path);\n  duplicatedChunks.set(caller, chunks);\n  emitWarning(`'${path}' was included multiple times.`, {\n    code: 'vite-plugin-glsl',\n    detail: 'Please avoid multiple imports of the same chunk in order to avoid' + ` recursions and optimize your shader length.\\nDuplicated import found in file '${caller}'.`\n  });\n}\n\n/**\r\n * @function\r\n * @name removeSourceComments\r\n * @description Removes comments from shader source\r\n * code in order to avoid including commented chunks\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  keyword Keyword to import chunks\r\n * @param {boolean} triple  Remove comments starting with `///`\r\n * \r\n * @returns {string} Shader's source code without comments\r\n */\nfunction removeSourceComments(source, keyword, triple = false) {\n  const pattern = new RegExp(String.raw`${keyword}(\\s+([^\\s<>]+));?`, 'gi');\n  if (source.includes('/*') && source.includes('*/')) {\n    source = source.slice(0, source.indexOf('/*')) + source.slice(source.indexOf('*/') + 2, source.length);\n  }\n  const lines = source.split('\\n');\n  for (let l = lines.length; l--;) {\n    const index = lines[l].indexOf('//');\n    if (index > -1) {\n      if (lines[l][index + 2] === '/' && !pattern.test(lines[l]) && !triple) continue;\n      lines[l] = lines[l].slice(0, lines[l].indexOf('//'));\n    }\n  }\n  return lines.join('\\n');\n}\n\n/**\r\n * @function\r\n * @name checkRecursiveImports\r\n * @description Checks if shader dependencies\r\n * have caused a recursion error or warning\r\n * ignoring duplicate chunks if required\r\n * \r\n * @param {string}  path    Shader's absolute path\r\n * @param {string}  lowPath Shader's lowercase path\r\n * @param {boolean} warn    Check already included chunks\r\n * @param {boolean} ignore  Ignore already included chunks\r\n * \r\n * @returns {boolean | null} Import recursion has occurred\r\n * or chunk was ignored because of `ignore` argument\r\n */\nfunction checkRecursiveImports(path, lowPath, warn, ignore) {\n  if (allChunks.has(lowPath)) {\n    if (ignore) return null;\n    warn && checkDuplicatedImports(path);\n  }\n  return checkIncludedDependencies(path, path);\n}\n\n/**\r\n * @function\r\n * @name checkIncludedDependencies\r\n * @description Checks if included\r\n * chunks caused a recursion error\r\n * \r\n * @param {string} path Current chunk absolute path\r\n * @param {string} root Main shader path that imports chunks\r\n * \r\n * @returns {boolean} Included chunk started a recursion\r\n */\nfunction checkIncludedDependencies(path, root) {\n  const dependencies = dependentChunks.get(path);\n  let recursiveDependency = false;\n  if (dependencies?.includes(root)) {\n    recursiveChunk = root;\n    return true;\n  }\n  dependencies?.forEach(dependency => recursiveDependency ||= checkIncludedDependencies(dependency, root));\n  return recursiveDependency;\n}\n\n/**\r\n * @function\r\n * @name minifyShader\r\n * @description Minifies shader source code by\r\n * removing unnecessary whitespace and empty lines\r\n * \r\n * @param {string}  shader  Shader code with included chunks\r\n * @param {boolean} newLine Flag to require a new line for the code\r\n * \r\n * @returns {string} Minified shader's source code\r\n */\nfunction minifyShader(shader, newLine = false) {\n  return shader.replace(/\\\\(?:\\r\\n|\\n\\r|\\n|\\r)|\\/\\*.*?\\*\\/|\\/\\/(?:\\\\(?:\\r\\n|\\n\\r|\\n|\\r)|[^\\n\\r])*/g, '').split(/\\n+/).reduce((result, line) => {\n    line = line.trim().replace(/\\s{2,}|\\t/, ' ');\n    if (/@(vertex|fragment|compute)/.test(line) || line.endsWith('return')) line += ' ';\n    if (line[0] === '#') {\n      newLine && result.push('\\n');\n      result.push(line, '\\n');\n      newLine = false;\n    } else {\n      !line.startsWith('{') && result.length && result[result.length - 1].endsWith('else') && result.push(' ');\n      result.push(line.replace(/\\s*({|}|=|\\*|,|\\+|\\/|>|<|&|\\||\\[|\\]|\\(|\\)|\\-|!|;)\\s*/g, '$1'));\n      newLine = true;\n    }\n    return result;\n  }, []).join('').replace(/\\n+/g, '\\n');\n}\n\n/**\r\n * @function\r\n * @name loadChunks\r\n * @description Includes shader's dependencies\r\n * and removes comments from the source code\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  path    Shader's absolute path\r\n * @param {Options} options Shader loading config object\r\n * \r\n * @throws {Error} If shader chunks started a recursion loop\r\n * \r\n * @returns {string} Shader's source code without external chunks\r\n */\nfunction loadChunks(source, path, options) {\n  const {\n    importKeyword,\n    warnDuplicatedImports,\n    removeDuplicatedImports\n  } = options;\n  const pattern = new RegExp(String.raw`${importKeyword}(\\s+([^\\s<>]+));?`, 'gi');\n  const unixPath = path.split(sep).join(posix.sep);\n  const chunkPath = platform() === 'win32' && unixPath.toLocaleLowerCase() || unixPath;\n  const recursion = checkRecursiveImports(unixPath, chunkPath, warnDuplicatedImports, removeDuplicatedImports);\n  if (recursion) return recursiveChunk;else if (recursion === null) return '';\n  source = removeSourceComments(source);\n  let directory = dirname(unixPath);\n  allChunks.add(chunkPath);\n  if (pattern.test(source)) {\n    dependentChunks.set(unixPath, []);\n    const currentDirectory = directory;\n    const ext = options.defaultExtension;\n    source = source.replace(pattern, (_, chunkPath) => {\n      chunkPath = chunkPath.trim().replace(/^(?:\"|')?|(?:\"|')?;?$/gi, '');\n      if (!chunkPath.indexOf('/')) {\n        const base = cwd().split(sep).join(posix.sep);\n        chunkPath = base + options.root + chunkPath;\n      }\n      const directoryIndex = chunkPath.lastIndexOf('/');\n      directory = currentDirectory;\n      if (directoryIndex !== -1) {\n        directory = resolve(directory, chunkPath.slice(0, directoryIndex + 1));\n        chunkPath = chunkPath.slice(directoryIndex + 1, chunkPath.length);\n      }\n      let shader = resolve(directory, chunkPath);\n      if (!extname(shader)) shader = `${shader}.${ext}`;\n      const shaderPath = shader.split(sep).join(posix.sep);\n      dependentChunks.get(unixPath)?.push(shaderPath);\n      return loadChunks(readFileSync(shader, 'utf8'), shader, options);\n    });\n  }\n  if (recursiveChunk) {\n    const caller = getRecursionCaller();\n    const recursiveChunk = resetSavedChunks();\n    throw new Error(`Recursion detected when importing \"${recursiveChunk}\" in \"${caller}\".`);\n  }\n  return source.trim().replace(/(\\r\\n|\\r|\\n){3,}/g, '$1\\n');\n}\n\n/**\r\n * @function\r\n * @name loadShader\r\n * @description Iterates through all external chunks, includes them\r\n * into the shader's source code and optionally minifies the output\r\n * \r\n * @typedef {import('./types').LoadingOptions} Options\r\n * @typedef {import('./types').LoadingOutput} Output\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  shader  Shader's absolute path\r\n * @param {Options} options Configuration object to define:\r\n * \r\n *  - Shader suffix to use when no extension is specified\r\n *  - Warn if the same chunk was imported multiple times\r\n *  - Automatically remove an already imported chunk\r\n *  - Keyword used to import shader chunks\r\n *  - Directory for root imports\r\n *  - Minify output shader code\r\n * \r\n * @returns {Promise<Output>} Loaded, parsed (and minified)\r\n * shader output and Map of shaders that import other chunks\r\n */\nexport default async function (source, shader, options) {\n  const {\n    minify,\n    ...config\n  } = options;\n  resetSavedChunks();\n  let output = loadChunks(source, shader, config);\n  output = minify ? removeSourceComments(output, options.importKeyword, true) : output;\n  return {\n    dependentChunks,\n    outputShader: minify ? typeof minify !== 'function' ? minifyShader(output) : await minify(output) : output\n  };\n}","map":{"version":3,"names":["dirname","resolve","extname","posix","sep","emitWarning","cwd","readFileSync","platform","recursiveChunk","allChunks","Set","dependentChunks","Map","duplicatedChunks","resetSavedChunks","chunk","clear","getRecursionCaller","dependencies","keys","length","checkDuplicatedImports","path","caller","chunks","get","includes","push","set","code","detail","removeSourceComments","source","keyword","triple","pattern","RegExp","String","raw","slice","indexOf","lines","split","l","index","test","join","checkRecursiveImports","lowPath","warn","ignore","has","checkIncludedDependencies","root","recursiveDependency","forEach","dependency","minifyShader","shader","newLine","replace","reduce","result","line","trim","endsWith","startsWith","loadChunks","options","importKeyword","warnDuplicatedImports","removeDuplicatedImports","unixPath","chunkPath","toLocaleLowerCase","recursion","directory","add","currentDirectory","ext","defaultExtension","_","base","directoryIndex","lastIndexOf","shaderPath","Error","minify","config","output","outputShader"],"sources":["/Users/linhankuan/fvl2025/node_modules/vite-plugin-glsl/src/loadShader.js"],"sourcesContent":["import { dirname, resolve, extname, posix, sep } from 'path';\r\nimport { emitWarning, cwd } from 'process';\r\nimport { readFileSync } from 'fs';\r\nimport { platform } from 'os';\r\n\r\n/**\r\n * @name recursiveChunk\r\n * @type {string}\r\n * \r\n * @description Shader chunk path\r\n * that caused a recursion error\r\n */\r\nlet recursiveChunk = '';\r\n\r\n/**\r\n * @const\r\n * @name allChunks\r\n * @type {readonly Set<string>}\r\n * \r\n * @description List of all shader chunks,\r\n * it's used to track included files\r\n */\r\nconst allChunks = new Set();\r\n\r\n/**\r\n * @const\r\n * @name dependentChunks\r\n * @type {readonly Map<string, string[]>}\r\n * \r\n * @description Map of shaders that import other chunks, it's\r\n * used to track included files in order to avoid recursion\r\n * - Key: shader path that uses other chunks as dependencies\r\n * - Value: list of chunk paths included within the shader\r\n */\r\nconst dependentChunks = new Map();\r\n\r\n/**\r\n * @const\r\n * @name duplicatedChunks\r\n * @type {readonly Map<string, string[]>}\r\n * \r\n * @description Map of duplicated shader\r\n * imports, used by warning messages\r\n */\r\nconst duplicatedChunks = new Map();\r\n\r\n/**\r\n * @function\r\n * @name resetSavedChunks\r\n * @description Clears all lists of saved chunks\r\n * and resets \"recursiveChunk\" path to empty\r\n * \r\n * @returns {string} Copy of \"recursiveChunk\" path\r\n */\r\nfunction resetSavedChunks () {\r\n  const chunk = recursiveChunk;\r\n  duplicatedChunks.clear();\r\n  dependentChunks.clear();\r\n\r\n  recursiveChunk = '';\r\n  allChunks.clear();\r\n  return chunk;\r\n}\r\n\r\n/**\r\n * @function\r\n * @name getRecursionCaller\r\n * @description Gets last chunk that caused a\r\n * recursion error from the \"dependentChunks\" list\r\n * \r\n * @returns {string} Chunk path that started a recursion\r\n */\r\nfunction getRecursionCaller () {\r\n  const dependencies = [...dependentChunks.keys()];\r\n  return dependencies[dependencies.length - 1];\r\n}\r\n\r\n/**\r\n * @function\r\n * @name checkDuplicatedImports\r\n * @description Checks if shader chunk was already included\r\n * and adds it to the \"duplicatedChunks\" list if yes\r\n * \r\n * @param {string} path Shader's absolute path\r\n * \r\n * @throws {Warning} If shader chunk was already included\r\n */\r\nfunction checkDuplicatedImports (path) {\r\n  const caller = getRecursionCaller();\r\n\r\n  const chunks = duplicatedChunks.get(caller) ?? [];\r\n  if (chunks.includes(path)) return;\r\n\r\n  chunks.push(path);\r\n  duplicatedChunks.set(caller, chunks);\r\n\r\n  emitWarning(`'${path}' was included multiple times.`, {\r\n    code: 'vite-plugin-glsl',\r\n    detail: 'Please avoid multiple imports of the same chunk in order to avoid' +\r\n    ` recursions and optimize your shader length.\\nDuplicated import found in file '${caller}'.`\r\n  });\r\n}\r\n\r\n/**\r\n * @function\r\n * @name removeSourceComments\r\n * @description Removes comments from shader source\r\n * code in order to avoid including commented chunks\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  keyword Keyword to import chunks\r\n * @param {boolean} triple  Remove comments starting with `///`\r\n * \r\n * @returns {string} Shader's source code without comments\r\n */\r\nfunction removeSourceComments (source, keyword, triple = false) {\r\n  const pattern = new RegExp(String.raw`${keyword}(\\s+([^\\s<>]+));?`, 'gi');\r\n\r\n  if (source.includes('/*') && source.includes('*/')) {\r\n    source = source.slice(0, source.indexOf('/*')) +\r\n    source.slice(source.indexOf('*/') + 2, source.length);\r\n  }\r\n\r\n  const lines = source.split('\\n');\r\n\r\n  for (let l = lines.length; l--; ) {\r\n    const index = lines[l].indexOf('//');\r\n\r\n    if (index > -1) {\r\n      if (lines[l][index + 2] === '/' && !pattern.test(lines[l]) && !triple) continue;\r\n      lines[l] = lines[l].slice(0, lines[l].indexOf('//'));\r\n    }\r\n  }\r\n\r\n  return lines.join('\\n');\r\n}\r\n\r\n/**\r\n * @function\r\n * @name checkRecursiveImports\r\n * @description Checks if shader dependencies\r\n * have caused a recursion error or warning\r\n * ignoring duplicate chunks if required\r\n * \r\n * @param {string}  path    Shader's absolute path\r\n * @param {string}  lowPath Shader's lowercase path\r\n * @param {boolean} warn    Check already included chunks\r\n * @param {boolean} ignore  Ignore already included chunks\r\n * \r\n * @returns {boolean | null} Import recursion has occurred\r\n * or chunk was ignored because of `ignore` argument\r\n */\r\nfunction checkRecursiveImports (path, lowPath, warn, ignore) {\r\n  if (allChunks.has(lowPath)) {\r\n    if (ignore) return null;\r\n    warn && checkDuplicatedImports(path);\r\n  }\r\n\r\n  return checkIncludedDependencies(path, path);\r\n}\r\n\r\n/**\r\n * @function\r\n * @name checkIncludedDependencies\r\n * @description Checks if included\r\n * chunks caused a recursion error\r\n * \r\n * @param {string} path Current chunk absolute path\r\n * @param {string} root Main shader path that imports chunks\r\n * \r\n * @returns {boolean} Included chunk started a recursion\r\n */\r\nfunction checkIncludedDependencies (path, root) {\r\n  const dependencies = dependentChunks.get(path);\r\n  let recursiveDependency = false;\r\n\r\n  if (dependencies?.includes(root)) {\r\n    recursiveChunk = root;\r\n    return true;\r\n  }\r\n\r\n  dependencies?.forEach(dependency => recursiveDependency ||=\r\n    checkIncludedDependencies(dependency, root)\r\n  );\r\n\r\n  return recursiveDependency;\r\n}\r\n\r\n/**\r\n * @function\r\n * @name minifyShader\r\n * @description Minifies shader source code by\r\n * removing unnecessary whitespace and empty lines\r\n * \r\n * @param {string}  shader  Shader code with included chunks\r\n * @param {boolean} newLine Flag to require a new line for the code\r\n * \r\n * @returns {string} Minified shader's source code\r\n */\r\nfunction minifyShader (shader, newLine = false) {\r\n  return shader.replace(/\\\\(?:\\r\\n|\\n\\r|\\n|\\r)|\\/\\*.*?\\*\\/|\\/\\/(?:\\\\(?:\\r\\n|\\n\\r|\\n|\\r)|[^\\n\\r])*/g, '')\r\n    .split(/\\n+/).reduce((result, line) => {\r\n      line = line.trim().replace(/\\s{2,}|\\t/, ' ');\r\n\r\n      if (/@(vertex|fragment|compute)/.test(line) || line.endsWith('return')) line += ' ';\r\n\r\n      if (line[0] === '#') {\r\n        newLine && result.push('\\n');\r\n        result.push(line, '\\n');\r\n        newLine = false;\r\n      }\r\n\r\n      else {\r\n        !line.startsWith('{') && result.length && result[result.length - 1].endsWith('else') && result.push(' ');\r\n        result.push(line.replace(/\\s*({|}|=|\\*|,|\\+|\\/|>|<|&|\\||\\[|\\]|\\(|\\)|\\-|!|;)\\s*/g, '$1'));\r\n        newLine = true;\r\n      }\r\n\r\n      return result;\r\n    }, []).join('').replace(/\\n+/g, '\\n');\r\n}\r\n\r\n/**\r\n * @function\r\n * @name loadChunks\r\n * @description Includes shader's dependencies\r\n * and removes comments from the source code\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  path    Shader's absolute path\r\n * @param {Options} options Shader loading config object\r\n * \r\n * @throws {Error} If shader chunks started a recursion loop\r\n * \r\n * @returns {string} Shader's source code without external chunks\r\n */\r\nfunction loadChunks (source, path, options) {\r\n  const { importKeyword, warnDuplicatedImports, removeDuplicatedImports } = options;\r\n  const pattern = new RegExp(String.raw`${importKeyword}(\\s+([^\\s<>]+));?`, 'gi');\r\n  const unixPath = path.split(sep).join(posix.sep);\r\n\r\n  const chunkPath = platform() === 'win32' &&\r\n    unixPath.toLocaleLowerCase() || unixPath; \r\n\r\n  const recursion = checkRecursiveImports(\r\n    unixPath, chunkPath,\r\n    warnDuplicatedImports,\r\n    removeDuplicatedImports\r\n  );\r\n\r\n  if (recursion) return recursiveChunk;\r\n  else if (recursion === null) return '';\r\n\r\n  source = removeSourceComments(source);\r\n  let directory = dirname(unixPath);\r\n  allChunks.add(chunkPath);\r\n\r\n  if (pattern.test(source)) {\r\n    dependentChunks.set(unixPath, []);\r\n    const currentDirectory = directory;\r\n    const ext = options.defaultExtension;\r\n\r\n    source = source.replace(pattern, (_, chunkPath) => {\r\n      chunkPath = chunkPath.trim().replace(/^(?:\"|')?|(?:\"|')?;?$/gi, '');\r\n\r\n      if (!chunkPath.indexOf('/')) {\r\n        const base = cwd().split(sep).join(posix.sep);\r\n        chunkPath = base + options.root + chunkPath;\r\n      }\r\n\r\n      const directoryIndex = chunkPath.lastIndexOf('/');\r\n      directory = currentDirectory;\r\n\r\n      if (directoryIndex !== -1) {\r\n        directory = resolve(directory, chunkPath.slice(0, directoryIndex + 1));\r\n        chunkPath = chunkPath.slice(directoryIndex + 1, chunkPath.length);\r\n      }\r\n\r\n      let shader = resolve(directory, chunkPath);\r\n      if (!extname(shader)) shader = `${shader}.${ext}`;\r\n\r\n      const shaderPath = shader.split(sep).join(posix.sep);\r\n      dependentChunks.get(unixPath)?.push(shaderPath);\r\n\r\n      return loadChunks(\r\n        readFileSync(shader, 'utf8'),\r\n        shader, options\r\n      );\r\n    });\r\n  }\r\n\r\n  if (recursiveChunk) {\r\n    const caller = getRecursionCaller();\r\n    const recursiveChunk = resetSavedChunks();\r\n\r\n    throw new Error(\r\n      `Recursion detected when importing \"${recursiveChunk}\" in \"${caller}\".`\r\n    );\r\n  }\r\n\r\n  return source.trim().replace(/(\\r\\n|\\r|\\n){3,}/g, '$1\\n');\r\n}\r\n\r\n/**\r\n * @function\r\n * @name loadShader\r\n * @description Iterates through all external chunks, includes them\r\n * into the shader's source code and optionally minifies the output\r\n * \r\n * @typedef {import('./types').LoadingOptions} Options\r\n * @typedef {import('./types').LoadingOutput} Output\r\n * \r\n * @param {string}  source  Shader's source code\r\n * @param {string}  shader  Shader's absolute path\r\n * @param {Options} options Configuration object to define:\r\n * \r\n *  - Shader suffix to use when no extension is specified\r\n *  - Warn if the same chunk was imported multiple times\r\n *  - Automatically remove an already imported chunk\r\n *  - Keyword used to import shader chunks\r\n *  - Directory for root imports\r\n *  - Minify output shader code\r\n * \r\n * @returns {Promise<Output>} Loaded, parsed (and minified)\r\n * shader output and Map of shaders that import other chunks\r\n */\r\nexport default async function (source, shader, options) {\r\n  const { minify, ...config } = options;\r\n\r\n  resetSavedChunks();\r\n\r\n  let output = loadChunks(source, shader, config);\r\n  output = minify ? removeSourceComments(output, options.importKeyword, true) : output;\r\n\r\n  return {\r\n    dependentChunks,\r\n    outputShader: minify\r\n      ? typeof minify !== 'function'\r\n      ? minifyShader(output)\r\n      : await minify(output)\r\n      : output\r\n  };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}