{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\n/*!\n * VelocityTracker: 3.13.0\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _toArray,\n  _getUnit,\n  _first,\n  _ticker,\n  _time1,\n  _time2,\n  _getCache,\n  _getGSAP = () => gsap || typeof window !== \"undefined\" && (gsap = window.gsap),\n  _lookup = {},\n  _round = value => Math.round(value * 10000) / 10000,\n  _getID = target => _getCache(target).id,\n  _getByTarget = target => _lookup[_getID(typeof target === \"string\" ? _toArray(target)[0] : target)],\n  _onTick = time => {\n    let pt = _first,\n      val;\n    //if the frame rate is too high, we won't be able to track the velocity as well, so only update the values about 20 times per second\n    if (time - _time1 >= 0.05) {\n      _time2 = _time1;\n      _time1 = time;\n      while (pt) {\n        val = pt.g(pt.t, pt.p);\n        if (val !== pt.v1 || time - pt.t1 > 0.2) {\n          //use a threshold of 0.2 seconds for zeroing-out velocity. If we only use 0.05 and things update slightly slower, like some Android devices dispatch \"touchmove\" events sluggishly so 2 or 3 ticks of the gsap.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it's not updating as frequently. A threshold of 0.2 seconds seems to be a good balance. We want to update things frequently (0.05 seconds) when they're moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.\n          pt.v2 = pt.v1;\n          pt.v1 = val;\n          pt.t2 = pt.t1;\n          pt.t1 = time;\n        }\n        pt = pt._next;\n      }\n    }\n  },\n  _types = {\n    deg: 360,\n    rad: Math.PI * 2\n  },\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (gsap) {\n      _toArray = gsap.utils.toArray;\n      _getUnit = gsap.utils.getUnit;\n      _getCache = gsap.core.getCache;\n      _ticker = gsap.ticker;\n      _coreInitted = 1;\n    }\n  };\nclass PropTracker {\n  constructor(target, property, type, next) {\n    this.t = target;\n    this.p = property;\n    this.g = target._gsap.get;\n    this.rCap = _types[type || _getUnit(this.g(target, property))]; //rotational cap (for degrees, \"deg\", it's 360 and for radians, \"rad\", it's Math.PI * 2)\n    this.v1 = this.v2 = 0;\n    this.t1 = this.t2 = _ticker.time;\n    if (next) {\n      this._next = next;\n      next._prev = this;\n    }\n  }\n}\nexport class VelocityTracker {\n  constructor(target, property) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n    this.target = _toArray(target)[0];\n    _lookup[_getID(this.target)] = this;\n    this._props = {};\n    property && this.add(property);\n  }\n  static register(core) {\n    gsap = core;\n    _initCore();\n  }\n  get(property, skipRecentTick) {\n    let pt = this._props[property] || console.warn(\"Not tracking \" + property + \" velocity.\"),\n      val,\n      dif,\n      rotationCap;\n    val = parseFloat(skipRecentTick ? pt.v1 : pt.g(pt.t, pt.p));\n    dif = val - parseFloat(pt.v2);\n    rotationCap = pt.rCap;\n    if (rotationCap) {\n      //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.\n      dif = dif % rotationCap;\n      if (dif !== dif % (rotationCap / 2)) {\n        dif = dif < 0 ? dif + rotationCap : dif - rotationCap;\n      }\n    }\n    return _round(dif / ((skipRecentTick ? pt.t1 : _ticker.time) - pt.t2));\n  }\n  getAll() {\n    let result = {},\n      props = this._props,\n      p;\n    for (p in props) {\n      result[p] = this.get(p);\n    }\n    return result;\n  }\n  isTracking(property) {\n    return property in this._props;\n  }\n  add(property, type) {\n    if (!(property in this._props)) {\n      if (!_first) {\n        _ticker.add(_onTick);\n        _time1 = _time2 = _ticker.time;\n      }\n      _first = this._props[property] = new PropTracker(this.target, property, type, _first);\n    }\n  }\n  remove(property) {\n    let pt = this._props[property],\n      prev,\n      next;\n    if (pt) {\n      prev = pt._prev;\n      next = pt._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      } else if (_first === pt) {\n        _ticker.remove(_onTick);\n        _first = 0;\n      }\n      delete this._props[property];\n    }\n  }\n  kill(shallow) {\n    for (let p in this._props) {\n      this.remove(p);\n    }\n    if (!shallow) {\n      delete _lookup[_getID(this.target)];\n    }\n  }\n  static track(targets, properties, types) {\n    if (!_coreInitted) {\n      _initCore();\n    }\n    let result = [],\n      targs = _toArray(targets),\n      a = properties.split(\",\"),\n      t = (types || \"\").split(\",\"),\n      i = targs.length,\n      tracker,\n      j;\n    while (i--) {\n      tracker = _getByTarget(targs[i]) || new VelocityTracker(targs[i]);\n      j = a.length;\n      while (j--) {\n        tracker.add(a[j], t[j] || t[0]);\n      }\n      result.push(tracker);\n    }\n    return result;\n  }\n  static untrack(targets, properties) {\n    let props = (properties || \"\").split(\",\");\n    _toArray(targets).forEach(target => {\n      let tracker = _getByTarget(target);\n      if (tracker) {\n        if (!props.length) {\n          tracker.kill(1);\n        } else {\n          props.forEach(p => tracker.remove(p));\n        }\n      }\n    });\n  }\n  static isTracking(target, property) {\n    let tracker = _getByTarget(target);\n    return tracker && tracker.isTracking(property);\n  }\n  static getVelocity(target, property) {\n    let tracker = _getByTarget(target);\n    return !tracker || !tracker.isTracking(property) ? console.warn(\"Not tracking velocity of \" + property) : tracker.get(property);\n  }\n}\nVelocityTracker.getByTarget = _getByTarget;\n_getGSAP() && gsap.registerPlugin(VelocityTracker);\nexport { VelocityTracker as default };","map":{"version":3,"names":["gsap","_coreInitted","_toArray","_getUnit","_first","_ticker","_time1","_time2","_getCache","_getGSAP","window","_lookup","_round","value","Math","round","_getID","target","id","_getByTarget","_onTick","time","pt","val","g","t","p","v1","t1","v2","t2","_next","_types","deg","rad","PI","_initCore","utils","toArray","getUnit","core","getCache","ticker","PropTracker","constructor","property","type","next","_gsap","get","rCap","_prev","VelocityTracker","_props","add","register","skipRecentTick","console","warn","dif","rotationCap","parseFloat","getAll","result","props","isTracking","remove","prev","kill","shallow","track","targets","properties","types","targs","a","split","i","length","tracker","j","push","untrack","forEach","getVelocity","getByTarget","registerPlugin","default"],"sources":["/Users/linhankuan/fvl2025/node_modules/gsap/src/utils/VelocityTracker.js"],"sourcesContent":["/*!\n * VelocityTracker: 3.13.0\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _toArray, _getUnit, _first, _ticker, _time1, _time2, _getCache,\n\t_getGSAP = () => gsap || typeof(window) !== \"undefined\" && (gsap = window.gsap),\n\t_lookup = {},\n\t_round = value => Math.round(value * 10000) / 10000,\n\t_getID = target => _getCache(target).id,\n\t_getByTarget = target => _lookup[_getID(typeof(target) === \"string\" ? _toArray(target)[0] : target)],\n\t_onTick = (time) => {\n\t\tlet pt = _first,\n\t\t\tval;\n\t\t//if the frame rate is too high, we won't be able to track the velocity as well, so only update the values about 20 times per second\n\t\tif (time - _time1 >= 0.05) {\n\t\t\t_time2 = _time1;\n\t\t\t_time1 = time;\n\t\t\twhile (pt) {\n\t\t\t\tval = pt.g(pt.t, pt.p);\n\t\t\t\tif (val !== pt.v1 || time - pt.t1 > 0.2) { //use a threshold of 0.2 seconds for zeroing-out velocity. If we only use 0.05 and things update slightly slower, like some Android devices dispatch \"touchmove\" events sluggishly so 2 or 3 ticks of the gsap.ticker may elapse inbetween, thus it may appear like the object is not moving but it actually is but it's not updating as frequently. A threshold of 0.2 seconds seems to be a good balance. We want to update things frequently (0.05 seconds) when they're moving so that we can respond to fast motions accurately, but we want to be more resistant to go back to a zero velocity.\n\t\t\t\t\tpt.v2 = pt.v1;\n\t\t\t\t\tpt.v1 = val;\n\t\t\t\t\tpt.t2 = pt.t1;\n\t\t\t\t\tpt.t1 = time;\n\t\t\t\t}\n\t\t\t\tpt = pt._next;\n\t\t\t}\n\t\t}\n\t},\n\t_types = {deg: 360, rad: Math.PI * 2},\n\n\t_initCore = () => {\n\t\tgsap = _getGSAP();\n\t\tif (gsap) {\n\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t_getUnit = gsap.utils.getUnit;\n\t\t\t_getCache = gsap.core.getCache;\n\t\t\t_ticker = gsap.ticker;\n\t\t\t_coreInitted = 1;\n\t\t}\n\t};\n\nclass PropTracker {\n\n\tconstructor(target, property, type, next) {\n\t\tthis.t = target;\n\t\tthis.p = property;\n\t\tthis.g = target._gsap.get;\n\t\tthis.rCap = _types[type || _getUnit(this.g(target, property))]; //rotational cap (for degrees, \"deg\", it's 360 and for radians, \"rad\", it's Math.PI * 2)\n\t\tthis.v1 = this.v2 = 0;\n\t\tthis.t1 = this.t2 = _ticker.time;\n\t\tif (next) {\n\t\t\tthis._next = next;\n\t\t\tnext._prev = this;\n\t\t}\n\t}\n\n}\n\nexport class VelocityTracker {\n\n\tconstructor(target, property) {\n\t\tif (!_coreInitted) {\n\t\t\t_initCore();\n\t\t}\n\t\tthis.target = _toArray(target)[0];\n\t\t_lookup[_getID(this.target)] = this;\n\t\tthis._props = {};\n\t\tproperty && this.add(property);\n\t}\n\n\tstatic register(core) {\n\t\tgsap = core;\n\t\t_initCore();\n\t}\n\n\tget(property, skipRecentTick) {\n\t\tlet pt = this._props[property] || console.warn(\"Not tracking \" + property + \" velocity.\"),\n\t\t\tval, dif, rotationCap;\n\t\tval = parseFloat(skipRecentTick ? pt.v1 : pt.g(pt.t, pt.p));\n\t\tdif = (val - parseFloat(pt.v2));\n\t\trotationCap = pt.rCap;\n\t\tif (rotationCap) { //rotational values need special interpretation so that if, for example, they go from 179 to -178 degrees it is interpreted as a change of 3 instead of -357.\n\t\t\tdif = dif % rotationCap;\n\t\t\tif (dif !== dif % (rotationCap / 2)) {\n\t\t\t\tdif = (dif < 0) ? dif + rotationCap : dif - rotationCap;\n\t\t\t}\n\t\t}\n\t\treturn _round(dif / ((skipRecentTick ? pt.t1 : _ticker.time) - pt.t2));\n\t}\n\n\tgetAll() {\n\t\tlet result = {},\n\t\t\tprops = this._props,\n\t\t\tp;\n\t\tfor (p in props) {\n\t\t\tresult[p] = this.get(p);\n\t\t}\n\t\treturn result;\n\t}\n\n\tisTracking(property) {\n\t\treturn (property in this._props);\n\t}\n\n\tadd(property, type) {\n\t\tif (!(property in this._props)) {\n\t\t\tif (!_first) {\n\t\t\t\t_ticker.add(_onTick);\n\t\t\t\t_time1 = _time2 = _ticker.time;\n\t\t\t}\n\t\t\t_first = this._props[property] = new PropTracker(this.target, property, type, _first);\n\t\t}\n\t}\n\n\tremove(property) {\n\t\tlet pt = this._props[property],\n\t\t\tprev, next;\n\t\tif (pt) {\n\t\t\tprev = pt._prev;\n\t\t\tnext = pt._next;\n\t\t\tif (prev) {\n\t\t\t\tprev._next = next;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tnext._prev = prev;\n\t\t\t} else if (_first === pt) {\n\t\t\t\t_ticker.remove(_onTick);\n\t\t\t\t_first = 0;\n\t\t\t}\n\t\t\tdelete this._props[property];\n\t\t}\n\t}\n\n\tkill(shallow) {\n\t\tfor (let p in this._props) {\n\t\t\tthis.remove(p);\n\t\t}\n\t\tif (!shallow) {\n\t\t\tdelete _lookup[_getID(this.target)];\n\t\t}\n\t}\n\n\tstatic track(targets, properties, types) {\n\t\tif (!_coreInitted) {\n\t\t\t_initCore();\n\t\t}\n\t\tlet result = [],\n\t\t\ttargs = _toArray(targets),\n\t\t\ta = properties.split(\",\"),\n\t\t\tt = (types || \"\").split(\",\"),\n\t\t\ti = targs.length,\n\t\t\ttracker, j;\n\t\twhile (i--) {\n\t\t\ttracker = _getByTarget(targs[i]) || new VelocityTracker(targs[i]);\n\t\t\tj = a.length;\n\t\t\twhile (j--) {\n\t\t\t\ttracker.add(a[j], t[j] || t[0]);\n\t\t\t}\n\t\t\tresult.push(tracker);\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic untrack(targets, properties) {\n\t\tlet props = (properties || \"\").split(\",\");\n\t\t_toArray(targets).forEach(target => {\n\t\t\tlet tracker = _getByTarget(target);\n\t\t\tif (tracker) {\n\t\t\t\tif (!props.length) {\n\t\t\t\t\ttracker.kill(1);\n\t\t\t\t} else {\n\t\t\t\t\tprops.forEach(p => tracker.remove(p));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic isTracking(target, property) {\n\t\tlet tracker = _getByTarget(target);\n\t\treturn tracker && tracker.isTracking(property);\n\t}\n\n\tstatic getVelocity(target, property) {\n\t\tlet tracker = _getByTarget(target);\n\t\treturn (!tracker || !tracker.isTracking(property)) ? console.warn(\"Not tracking velocity of \" + property) : tracker.get(property);\n\t}\n}\n\nVelocityTracker.getByTarget = _getByTarget;\n\n\n_getGSAP() && gsap.registerPlugin(VelocityTracker);\n\nexport { VelocityTracker as default };"],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,IAAI;EAAEC,YAAY;EAAEC,QAAQ;EAAEC,QAAQ;EAAEC,MAAM;EAAEC,OAAO;EAAEC,MAAM;EAAEC,MAAM;EAAEC,SAAS;EACrFC,QAAQ,GAAGA,CAAA,KAAMT,IAAI,IAAI,OAAOU,MAAO,KAAK,WAAW,KAAKV,IAAI,GAAGU,MAAM,CAACV,IAAI,CAAC;EAC/EW,OAAO,GAAG,CAAC,CAAC;EACZC,MAAM,GAAGC,KAAK,IAAIC,IAAI,CAACC,KAAK,CAACF,KAAK,GAAG,KAAK,CAAC,GAAG,KAAK;EACnDG,MAAM,GAAGC,MAAM,IAAIT,SAAS,CAACS,MAAM,CAAC,CAACC,EAAE;EACvCC,YAAY,GAAGF,MAAM,IAAIN,OAAO,CAACK,MAAM,CAAC,OAAOC,MAAO,KAAK,QAAQ,GAAGf,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC;EACpGG,OAAO,GAAIC,IAAI,IAAK;IACnB,IAAIC,EAAE,GAAGlB,MAAM;MACdmB,GAAG;IACJ;IACA,IAAIF,IAAI,GAAGf,MAAM,IAAI,IAAI,EAAE;MAC1BC,MAAM,GAAGD,MAAM;MACfA,MAAM,GAAGe,IAAI;MACb,OAAOC,EAAE,EAAE;QACVC,GAAG,GAAGD,EAAE,CAACE,CAAC,CAACF,EAAE,CAACG,CAAC,EAAEH,EAAE,CAACI,CAAC,CAAC;QACtB,IAAIH,GAAG,KAAKD,EAAE,CAACK,EAAE,IAAIN,IAAI,GAAGC,EAAE,CAACM,EAAE,GAAG,GAAG,EAAE;UAAE;UAC1CN,EAAE,CAACO,EAAE,GAAGP,EAAE,CAACK,EAAE;UACbL,EAAE,CAACK,EAAE,GAAGJ,GAAG;UACXD,EAAE,CAACQ,EAAE,GAAGR,EAAE,CAACM,EAAE;UACbN,EAAE,CAACM,EAAE,GAAGP,IAAI;QACb;QACAC,EAAE,GAAGA,EAAE,CAACS,KAAK;MACd;IACD;EACD,CAAC;EACDC,MAAM,GAAG;IAACC,GAAG,EAAE,GAAG;IAAEC,GAAG,EAAEpB,IAAI,CAACqB,EAAE,GAAG;EAAC,CAAC;EAErCC,SAAS,GAAGA,CAAA,KAAM;IACjBpC,IAAI,GAAGS,QAAQ,CAAC,CAAC;IACjB,IAAIT,IAAI,EAAE;MACTE,QAAQ,GAAGF,IAAI,CAACqC,KAAK,CAACC,OAAO;MAC7BnC,QAAQ,GAAGH,IAAI,CAACqC,KAAK,CAACE,OAAO;MAC7B/B,SAAS,GAAGR,IAAI,CAACwC,IAAI,CAACC,QAAQ;MAC9BpC,OAAO,GAAGL,IAAI,CAAC0C,MAAM;MACrBzC,YAAY,GAAG,CAAC;IACjB;EACD,CAAC;AAEF,MAAM0C,WAAW,CAAC;EAEjBC,WAAWA,CAAC3B,MAAM,EAAE4B,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACzC,IAAI,CAACtB,CAAC,GAAGR,MAAM;IACf,IAAI,CAACS,CAAC,GAAGmB,QAAQ;IACjB,IAAI,CAACrB,CAAC,GAAGP,MAAM,CAAC+B,KAAK,CAACC,GAAG;IACzB,IAAI,CAACC,IAAI,GAAGlB,MAAM,CAACc,IAAI,IAAI3C,QAAQ,CAAC,IAAI,CAACqB,CAAC,CAACP,MAAM,EAAE4B,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAChE,IAAI,CAAClB,EAAE,GAAG,IAAI,CAACE,EAAE,GAAG,CAAC;IACrB,IAAI,CAACD,EAAE,GAAG,IAAI,CAACE,EAAE,GAAGzB,OAAO,CAACgB,IAAI;IAChC,IAAI0B,IAAI,EAAE;MACT,IAAI,CAAChB,KAAK,GAAGgB,IAAI;MACjBA,IAAI,CAACI,KAAK,GAAG,IAAI;IAClB;EACD;AAED;AAEA,OAAO,MAAMC,eAAe,CAAC;EAE5BR,WAAWA,CAAC3B,MAAM,EAAE4B,QAAQ,EAAE;IAC7B,IAAI,CAAC5C,YAAY,EAAE;MAClBmC,SAAS,CAAC,CAAC;IACZ;IACA,IAAI,CAACnB,MAAM,GAAGf,QAAQ,CAACe,MAAM,CAAC,CAAC,CAAC,CAAC;IACjCN,OAAO,CAACK,MAAM,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,IAAI;IACnC,IAAI,CAACoC,MAAM,GAAG,CAAC,CAAC;IAChBR,QAAQ,IAAI,IAAI,CAACS,GAAG,CAACT,QAAQ,CAAC;EAC/B;EAEA,OAAOU,QAAQA,CAACf,IAAI,EAAE;IACrBxC,IAAI,GAAGwC,IAAI;IACXJ,SAAS,CAAC,CAAC;EACZ;EAEAa,GAAGA,CAACJ,QAAQ,EAAEW,cAAc,EAAE;IAC7B,IAAIlC,EAAE,GAAG,IAAI,CAAC+B,MAAM,CAACR,QAAQ,CAAC,IAAIY,OAAO,CAACC,IAAI,CAAC,eAAe,GAAGb,QAAQ,GAAG,YAAY,CAAC;MACxFtB,GAAG;MAAEoC,GAAG;MAAEC,WAAW;IACtBrC,GAAG,GAAGsC,UAAU,CAACL,cAAc,GAAGlC,EAAE,CAACK,EAAE,GAAGL,EAAE,CAACE,CAAC,CAACF,EAAE,CAACG,CAAC,EAAEH,EAAE,CAACI,CAAC,CAAC,CAAC;IAC3DiC,GAAG,GAAIpC,GAAG,GAAGsC,UAAU,CAACvC,EAAE,CAACO,EAAE,CAAE;IAC/B+B,WAAW,GAAGtC,EAAE,CAAC4B,IAAI;IACrB,IAAIU,WAAW,EAAE;MAAE;MAClBD,GAAG,GAAGA,GAAG,GAAGC,WAAW;MACvB,IAAID,GAAG,KAAKA,GAAG,IAAIC,WAAW,GAAG,CAAC,CAAC,EAAE;QACpCD,GAAG,GAAIA,GAAG,GAAG,CAAC,GAAIA,GAAG,GAAGC,WAAW,GAAGD,GAAG,GAAGC,WAAW;MACxD;IACD;IACA,OAAOhD,MAAM,CAAC+C,GAAG,IAAI,CAACH,cAAc,GAAGlC,EAAE,CAACM,EAAE,GAAGvB,OAAO,CAACgB,IAAI,IAAIC,EAAE,CAACQ,EAAE,CAAC,CAAC;EACvE;EAEAgC,MAAMA,CAAA,EAAG;IACR,IAAIC,MAAM,GAAG,CAAC,CAAC;MACdC,KAAK,GAAG,IAAI,CAACX,MAAM;MACnB3B,CAAC;IACF,KAAKA,CAAC,IAAIsC,KAAK,EAAE;MAChBD,MAAM,CAACrC,CAAC,CAAC,GAAG,IAAI,CAACuB,GAAG,CAACvB,CAAC,CAAC;IACxB;IACA,OAAOqC,MAAM;EACd;EAEAE,UAAUA,CAACpB,QAAQ,EAAE;IACpB,OAAQA,QAAQ,IAAI,IAAI,CAACQ,MAAM;EAChC;EAEAC,GAAGA,CAACT,QAAQ,EAAEC,IAAI,EAAE;IACnB,IAAI,EAAED,QAAQ,IAAI,IAAI,CAACQ,MAAM,CAAC,EAAE;MAC/B,IAAI,CAACjD,MAAM,EAAE;QACZC,OAAO,CAACiD,GAAG,CAAClC,OAAO,CAAC;QACpBd,MAAM,GAAGC,MAAM,GAAGF,OAAO,CAACgB,IAAI;MAC/B;MACAjB,MAAM,GAAG,IAAI,CAACiD,MAAM,CAACR,QAAQ,CAAC,GAAG,IAAIF,WAAW,CAAC,IAAI,CAAC1B,MAAM,EAAE4B,QAAQ,EAAEC,IAAI,EAAE1C,MAAM,CAAC;IACtF;EACD;EAEA8D,MAAMA,CAACrB,QAAQ,EAAE;IAChB,IAAIvB,EAAE,GAAG,IAAI,CAAC+B,MAAM,CAACR,QAAQ,CAAC;MAC7BsB,IAAI;MAAEpB,IAAI;IACX,IAAIzB,EAAE,EAAE;MACP6C,IAAI,GAAG7C,EAAE,CAAC6B,KAAK;MACfJ,IAAI,GAAGzB,EAAE,CAACS,KAAK;MACf,IAAIoC,IAAI,EAAE;QACTA,IAAI,CAACpC,KAAK,GAAGgB,IAAI;MAClB;MACA,IAAIA,IAAI,EAAE;QACTA,IAAI,CAACI,KAAK,GAAGgB,IAAI;MAClB,CAAC,MAAM,IAAI/D,MAAM,KAAKkB,EAAE,EAAE;QACzBjB,OAAO,CAAC6D,MAAM,CAAC9C,OAAO,CAAC;QACvBhB,MAAM,GAAG,CAAC;MACX;MACA,OAAO,IAAI,CAACiD,MAAM,CAACR,QAAQ,CAAC;IAC7B;EACD;EAEAuB,IAAIA,CAACC,OAAO,EAAE;IACb,KAAK,IAAI3C,CAAC,IAAI,IAAI,CAAC2B,MAAM,EAAE;MAC1B,IAAI,CAACa,MAAM,CAACxC,CAAC,CAAC;IACf;IACA,IAAI,CAAC2C,OAAO,EAAE;MACb,OAAO1D,OAAO,CAACK,MAAM,CAAC,IAAI,CAACC,MAAM,CAAC,CAAC;IACpC;EACD;EAEA,OAAOqD,KAAKA,CAACC,OAAO,EAAEC,UAAU,EAAEC,KAAK,EAAE;IACxC,IAAI,CAACxE,YAAY,EAAE;MAClBmC,SAAS,CAAC,CAAC;IACZ;IACA,IAAI2B,MAAM,GAAG,EAAE;MACdW,KAAK,GAAGxE,QAAQ,CAACqE,OAAO,CAAC;MACzBI,CAAC,GAAGH,UAAU,CAACI,KAAK,CAAC,GAAG,CAAC;MACzBnD,CAAC,GAAG,CAACgD,KAAK,IAAI,EAAE,EAAEG,KAAK,CAAC,GAAG,CAAC;MAC5BC,CAAC,GAAGH,KAAK,CAACI,MAAM;MAChBC,OAAO;MAAEC,CAAC;IACX,OAAOH,CAAC,EAAE,EAAE;MACXE,OAAO,GAAG5D,YAAY,CAACuD,KAAK,CAACG,CAAC,CAAC,CAAC,IAAI,IAAIzB,eAAe,CAACsB,KAAK,CAACG,CAAC,CAAC,CAAC;MACjEG,CAAC,GAAGL,CAAC,CAACG,MAAM;MACZ,OAAOE,CAAC,EAAE,EAAE;QACXD,OAAO,CAACzB,GAAG,CAACqB,CAAC,CAACK,CAAC,CAAC,EAAEvD,CAAC,CAACuD,CAAC,CAAC,IAAIvD,CAAC,CAAC,CAAC,CAAC,CAAC;MAChC;MACAsC,MAAM,CAACkB,IAAI,CAACF,OAAO,CAAC;IACrB;IACA,OAAOhB,MAAM;EACd;EAEA,OAAOmB,OAAOA,CAACX,OAAO,EAAEC,UAAU,EAAE;IACnC,IAAIR,KAAK,GAAG,CAACQ,UAAU,IAAI,EAAE,EAAEI,KAAK,CAAC,GAAG,CAAC;IACzC1E,QAAQ,CAACqE,OAAO,CAAC,CAACY,OAAO,CAAClE,MAAM,IAAI;MACnC,IAAI8D,OAAO,GAAG5D,YAAY,CAACF,MAAM,CAAC;MAClC,IAAI8D,OAAO,EAAE;QACZ,IAAI,CAACf,KAAK,CAACc,MAAM,EAAE;UAClBC,OAAO,CAACX,IAAI,CAAC,CAAC,CAAC;QAChB,CAAC,MAAM;UACNJ,KAAK,CAACmB,OAAO,CAACzD,CAAC,IAAIqD,OAAO,CAACb,MAAM,CAACxC,CAAC,CAAC,CAAC;QACtC;MACD;IACD,CAAC,CAAC;EACH;EAEA,OAAOuC,UAAUA,CAAChD,MAAM,EAAE4B,QAAQ,EAAE;IACnC,IAAIkC,OAAO,GAAG5D,YAAY,CAACF,MAAM,CAAC;IAClC,OAAO8D,OAAO,IAAIA,OAAO,CAACd,UAAU,CAACpB,QAAQ,CAAC;EAC/C;EAEA,OAAOuC,WAAWA,CAACnE,MAAM,EAAE4B,QAAQ,EAAE;IACpC,IAAIkC,OAAO,GAAG5D,YAAY,CAACF,MAAM,CAAC;IAClC,OAAQ,CAAC8D,OAAO,IAAI,CAACA,OAAO,CAACd,UAAU,CAACpB,QAAQ,CAAC,GAAIY,OAAO,CAACC,IAAI,CAAC,2BAA2B,GAAGb,QAAQ,CAAC,GAAGkC,OAAO,CAAC9B,GAAG,CAACJ,QAAQ,CAAC;EAClI;AACD;AAEAO,eAAe,CAACiC,WAAW,GAAGlE,YAAY;AAG1CV,QAAQ,CAAC,CAAC,IAAIT,IAAI,CAACsF,cAAc,CAAClC,eAAe,CAAC;AAElD,SAASA,eAAe,IAAImC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}