{"ast":null,"code":"import { Alias } from '../nodes/Alias.js';\nimport { isScalar } from '../nodes/identity.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\nconst CN = {\n  composeNode,\n  composeEmptyNode\n};\nfunction composeNode(ctx, token, props, onError) {\n  const atKey = ctx.atKey;\n  const {\n    spaceBefore,\n    comment,\n    anchor,\n    tag\n  } = props;\n  let node;\n  let isSrcToken = true;\n  switch (token.type) {\n    case 'alias':\n      node = composeAlias(ctx, token, onError);\n      if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n      break;\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'block-scalar':\n      node = composeScalar(ctx, token, tag, onError);\n      if (anchor) node.anchor = anchor.source.substring(1);\n      break;\n    case 'block-map':\n    case 'block-seq':\n    case 'flow-collection':\n      node = composeCollection(CN, ctx, token, props, onError);\n      if (anchor) node.anchor = anchor.source.substring(1);\n      break;\n    default:\n      {\n        const message = token.type === 'error' ? token.message : `Unsupported token (type: ${token.type})`;\n        onError(token, 'UNEXPECTED_TOKEN', message);\n        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n        isSrcToken = false;\n      }\n  }\n  if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== 'string' || node.tag && node.tag !== 'tag:yaml.org,2002:str')) {\n    const msg = 'With stringKeys, all keys must be strings';\n    onError(tag ?? token, 'NON_STRING_KEY', msg);\n  }\n  if (spaceBefore) node.spaceBefore = true;\n  if (comment) {\n    if (token.type === 'scalar' && token.source === '') node.comment = comment;else node.commentBefore = comment;\n  }\n  // @ts-expect-error Type checking misses meaning of isSrcToken\n  if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;\n  return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, {\n  spaceBefore,\n  comment,\n  anchor,\n  tag,\n  end\n}, onError) {\n  const token = {\n    type: 'scalar',\n    offset: emptyScalarPosition(offset, before, pos),\n    indent: -1,\n    source: ''\n  };\n  const node = composeScalar(ctx, token, tag, onError);\n  if (anchor) {\n    node.anchor = anchor.source.substring(1);\n    if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n  }\n  if (spaceBefore) node.spaceBefore = true;\n  if (comment) {\n    node.comment = comment;\n    node.range[2] = end;\n  }\n  return node;\n}\nfunction composeAlias({\n  options\n}, {\n  offset,\n  source,\n  end\n}, onError) {\n  const alias = new Alias(source.substring(1));\n  if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n  if (alias.source.endsWith(':')) onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n  const valueEnd = offset + source.length;\n  const re = resolveEnd(end, valueEnd, options.strict, onError);\n  alias.range = [offset, valueEnd, re.offset];\n  if (re.comment) alias.comment = re.comment;\n  return alias;\n}\nexport { composeEmptyNode, composeNode };","map":{"version":3,"names":["Alias","isScalar","composeCollection","composeScalar","resolveEnd","emptyScalarPosition","CN","composeNode","composeEmptyNode","ctx","token","props","onError","atKey","spaceBefore","comment","anchor","tag","node","isSrcToken","type","composeAlias","source","substring","message","offset","undefined","options","stringKeys","value","msg","commentBefore","keepSourceTokens","srcToken","before","pos","end","indent","range","alias","endsWith","length","valueEnd","re","strict"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/compose-node.js"],"sourcesContent":["import { Alias } from '../nodes/Alias.js';\nimport { isScalar } from '../nodes/identity.js';\nimport { composeCollection } from './compose-collection.js';\nimport { composeScalar } from './compose-scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { emptyScalarPosition } from './util-empty-scalar-position.js';\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const atKey = ctx.atKey;\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection(CN, ctx, token, props, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (atKey &&\n        ctx.options.stringKeys &&\n        (!isScalar(node) ||\n            typeof node.value !== 'string' ||\n            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {\n        const msg = 'With stringKeys, all keys must be strings';\n        onError(tag ?? token, 'NON_STRING_KEY', msg);\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexport { composeEmptyNode, composeNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}