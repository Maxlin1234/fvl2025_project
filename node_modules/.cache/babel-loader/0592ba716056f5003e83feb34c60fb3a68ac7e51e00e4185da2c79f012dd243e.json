{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({\n  composeNode,\n  composeEmptyNode\n}, ctx, bm, onError, tag) {\n  const NodeClass = tag?.nodeClass ?? YAMLMap;\n  const map = new NodeClass(ctx.schema);\n  if (ctx.atRoot) ctx.atRoot = false;\n  let offset = bm.offset;\n  let commentEnd = null;\n  for (const collItem of bm.items) {\n    const {\n      start,\n      key,\n      sep,\n      value\n    } = collItem;\n    // key properties\n    const keyProps = resolveProps(start, {\n      indicator: 'explicit-key-ind',\n      next: key ?? sep?.[0],\n      offset,\n      onError,\n      parentIndent: bm.indent,\n      startOnNewline: true\n    });\n    const implicitKey = !keyProps.found;\n    if (implicitKey) {\n      if (key) {\n        if (key.type === 'block-seq') onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');else if ('indent' in key && key.indent !== bm.indent) onError(offset, 'BAD_INDENT', startColMsg);\n      }\n      if (!keyProps.anchor && !keyProps.tag && !sep) {\n        commentEnd = keyProps.end;\n        if (keyProps.comment) {\n          if (map.comment) map.comment += '\\n' + keyProps.comment;else map.comment = keyProps.comment;\n        }\n        continue;\n      }\n      if (keyProps.newlineAfterProp || containsNewline(key)) {\n        onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n      }\n    } else if (keyProps.found?.indent !== bm.indent) {\n      onError(offset, 'BAD_INDENT', startColMsg);\n    }\n    // key value\n    ctx.atKey = true;\n    const keyStart = keyProps.end;\n    const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n    if (ctx.schema.compat) flowIndentCheck(bm.indent, key, onError);\n    ctx.atKey = false;\n    if (mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n    // value properties\n    const valueProps = resolveProps(sep ?? [], {\n      indicator: 'map-value-ind',\n      next: value,\n      offset: keyNode.range[2],\n      onError,\n      parentIndent: bm.indent,\n      startOnNewline: !key || key.type === 'block-scalar'\n    });\n    offset = valueProps.end;\n    if (valueProps.found) {\n      if (implicitKey) {\n        if (value?.type === 'block-map' && !valueProps.hasNewline) onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024) onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n      }\n      // value value\n      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n      if (ctx.schema.compat) flowIndentCheck(bm.indent, value, onError);\n      offset = valueNode.range[2];\n      const pair = new Pair(keyNode, valueNode);\n      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;\n      map.items.push(pair);\n    } else {\n      // key with no value\n      if (implicitKey) onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n      if (valueProps.comment) {\n        if (keyNode.comment) keyNode.comment += '\\n' + valueProps.comment;else keyNode.comment = valueProps.comment;\n      }\n      const pair = new Pair(keyNode);\n      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;\n      map.items.push(pair);\n    }\n  }\n  if (commentEnd && commentEnd < offset) onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n  map.range = [bm.offset, offset, commentEnd ?? offset];\n  return map;\n}\nexport { resolveBlockMap };","map":{"version":3,"names":["Pair","YAMLMap","resolveProps","containsNewline","flowIndentCheck","mapIncludes","startColMsg","resolveBlockMap","composeNode","composeEmptyNode","ctx","bm","onError","tag","NodeClass","nodeClass","map","schema","atRoot","offset","commentEnd","collItem","items","start","key","sep","value","keyProps","indicator","next","parentIndent","indent","startOnNewline","implicitKey","found","type","anchor","end","comment","newlineAfterProp","length","atKey","keyStart","keyNode","compat","valueProps","range","hasNewline","options","strict","valueNode","pair","keepSourceTokens","srcToken","push"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/resolve-block-map.js"],"sourcesContent":["import { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { flowIndentCheck } from './util-flow-indent-check.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {\n    const NodeClass = tag?.nodeClass ?? YAMLMap;\n    const map = new NodeClass(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.newlineAfterProp || containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        ctx.atKey = true;\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            flowIndentCheck(bm.indent, key, onError);\n        ctx.atKey = false;\n        if (mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            parentIndent: bm.indent,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexport { resolveBlockMap };\n"],"mappings":";AAAA,SAASA,IAAI,QAAQ,kBAAkB;AACvC,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,eAAe,QAAQ,4BAA4B;AAC5D,SAASC,eAAe,QAAQ,6BAA6B;AAC7D,SAASC,WAAW,QAAQ,wBAAwB;AAEpD,MAAMC,WAAW,GAAG,iDAAiD;AACrE,SAASC,eAAeA,CAAC;EAAEC,WAAW;EAAEC;AAAiB,CAAC,EAAEC,GAAG,EAAEC,EAAE,EAAEC,OAAO,EAAEC,GAAG,EAAE;EAC/E,MAAMC,SAAS,GAAGD,GAAG,EAAEE,SAAS,IAAId,OAAO;EAC3C,MAAMe,GAAG,GAAG,IAAIF,SAAS,CAACJ,GAAG,CAACO,MAAM,CAAC;EACrC,IAAIP,GAAG,CAACQ,MAAM,EACVR,GAAG,CAACQ,MAAM,GAAG,KAAK;EACtB,IAAIC,MAAM,GAAGR,EAAE,CAACQ,MAAM;EACtB,IAAIC,UAAU,GAAG,IAAI;EACrB,KAAK,MAAMC,QAAQ,IAAIV,EAAE,CAACW,KAAK,EAAE;IAC7B,MAAM;MAAEC,KAAK;MAAEC,GAAG;MAAEC,GAAG;MAAEC;IAAM,CAAC,GAAGL,QAAQ;IAC3C;IACA,MAAMM,QAAQ,GAAGzB,YAAY,CAACqB,KAAK,EAAE;MACjCK,SAAS,EAAE,kBAAkB;MAC7BC,IAAI,EAAEL,GAAG,IAAIC,GAAG,GAAG,CAAC,CAAC;MACrBN,MAAM;MACNP,OAAO;MACPkB,YAAY,EAAEnB,EAAE,CAACoB,MAAM;MACvBC,cAAc,EAAE;IACpB,CAAC,CAAC;IACF,MAAMC,WAAW,GAAG,CAACN,QAAQ,CAACO,KAAK;IACnC,IAAID,WAAW,EAAE;MACb,IAAIT,GAAG,EAAE;QACL,IAAIA,GAAG,CAACW,IAAI,KAAK,WAAW,EACxBvB,OAAO,CAACO,MAAM,EAAE,uBAAuB,EAAE,yDAAyD,CAAC,CAAC,KACnG,IAAI,QAAQ,IAAIK,GAAG,IAAIA,GAAG,CAACO,MAAM,KAAKpB,EAAE,CAACoB,MAAM,EAChDnB,OAAO,CAACO,MAAM,EAAE,YAAY,EAAEb,WAAW,CAAC;MAClD;MACA,IAAI,CAACqB,QAAQ,CAACS,MAAM,IAAI,CAACT,QAAQ,CAACd,GAAG,IAAI,CAACY,GAAG,EAAE;QAC3CL,UAAU,GAAGO,QAAQ,CAACU,GAAG;QACzB,IAAIV,QAAQ,CAACW,OAAO,EAAE;UAClB,IAAItB,GAAG,CAACsB,OAAO,EACXtB,GAAG,CAACsB,OAAO,IAAI,IAAI,GAAGX,QAAQ,CAACW,OAAO,CAAC,KAEvCtB,GAAG,CAACsB,OAAO,GAAGX,QAAQ,CAACW,OAAO;QACtC;QACA;MACJ;MACA,IAAIX,QAAQ,CAACY,gBAAgB,IAAIpC,eAAe,CAACqB,GAAG,CAAC,EAAE;QACnDZ,OAAO,CAACY,GAAG,IAAID,KAAK,CAACA,KAAK,CAACiB,MAAM,GAAG,CAAC,CAAC,EAAE,wBAAwB,EAAE,2CAA2C,CAAC;MAClH;IACJ,CAAC,MACI,IAAIb,QAAQ,CAACO,KAAK,EAAEH,MAAM,KAAKpB,EAAE,CAACoB,MAAM,EAAE;MAC3CnB,OAAO,CAACO,MAAM,EAAE,YAAY,EAAEb,WAAW,CAAC;IAC9C;IACA;IACAI,GAAG,CAAC+B,KAAK,GAAG,IAAI;IAChB,MAAMC,QAAQ,GAAGf,QAAQ,CAACU,GAAG;IAC7B,MAAMM,OAAO,GAAGnB,GAAG,GACbhB,WAAW,CAACE,GAAG,EAAEc,GAAG,EAAEG,QAAQ,EAAEf,OAAO,CAAC,GACxCH,gBAAgB,CAACC,GAAG,EAAEgC,QAAQ,EAAEnB,KAAK,EAAE,IAAI,EAAEI,QAAQ,EAAEf,OAAO,CAAC;IACrE,IAAIF,GAAG,CAACO,MAAM,CAAC2B,MAAM,EACjBxC,eAAe,CAACO,EAAE,CAACoB,MAAM,EAAEP,GAAG,EAAEZ,OAAO,CAAC;IAC5CF,GAAG,CAAC+B,KAAK,GAAG,KAAK;IACjB,IAAIpC,WAAW,CAACK,GAAG,EAAEM,GAAG,CAACM,KAAK,EAAEqB,OAAO,CAAC,EACpC/B,OAAO,CAAC8B,QAAQ,EAAE,eAAe,EAAE,yBAAyB,CAAC;IACjE;IACA,MAAMG,UAAU,GAAG3C,YAAY,CAACuB,GAAG,IAAI,EAAE,EAAE;MACvCG,SAAS,EAAE,eAAe;MAC1BC,IAAI,EAAEH,KAAK;MACXP,MAAM,EAAEwB,OAAO,CAACG,KAAK,CAAC,CAAC,CAAC;MACxBlC,OAAO;MACPkB,YAAY,EAAEnB,EAAE,CAACoB,MAAM;MACvBC,cAAc,EAAE,CAACR,GAAG,IAAIA,GAAG,CAACW,IAAI,KAAK;IACzC,CAAC,CAAC;IACFhB,MAAM,GAAG0B,UAAU,CAACR,GAAG;IACvB,IAAIQ,UAAU,CAACX,KAAK,EAAE;MAClB,IAAID,WAAW,EAAE;QACb,IAAIP,KAAK,EAAES,IAAI,KAAK,WAAW,IAAI,CAACU,UAAU,CAACE,UAAU,EACrDnC,OAAO,CAACO,MAAM,EAAE,uBAAuB,EAAE,qDAAqD,CAAC;QACnG,IAAIT,GAAG,CAACsC,OAAO,CAACC,MAAM,IAClBtB,QAAQ,CAACJ,KAAK,GAAGsB,UAAU,CAACX,KAAK,CAACf,MAAM,GAAG,IAAI,EAC/CP,OAAO,CAAC+B,OAAO,CAACG,KAAK,EAAE,qBAAqB,EAAE,6FAA6F,CAAC;MACpJ;MACA;MACA,MAAMI,SAAS,GAAGxB,KAAK,GACjBlB,WAAW,CAACE,GAAG,EAAEgB,KAAK,EAAEmB,UAAU,EAAEjC,OAAO,CAAC,GAC5CH,gBAAgB,CAACC,GAAG,EAAES,MAAM,EAAEM,GAAG,EAAE,IAAI,EAAEoB,UAAU,EAAEjC,OAAO,CAAC;MACnE,IAAIF,GAAG,CAACO,MAAM,CAAC2B,MAAM,EACjBxC,eAAe,CAACO,EAAE,CAACoB,MAAM,EAAEL,KAAK,EAAEd,OAAO,CAAC;MAC9CO,MAAM,GAAG+B,SAAS,CAACJ,KAAK,CAAC,CAAC,CAAC;MAC3B,MAAMK,IAAI,GAAG,IAAInD,IAAI,CAAC2C,OAAO,EAAEO,SAAS,CAAC;MACzC,IAAIxC,GAAG,CAACsC,OAAO,CAACI,gBAAgB,EAC5BD,IAAI,CAACE,QAAQ,GAAGhC,QAAQ;MAC5BL,GAAG,CAACM,KAAK,CAACgC,IAAI,CAACH,IAAI,CAAC;IACxB,CAAC,MACI;MACD;MACA,IAAIlB,WAAW,EACXrB,OAAO,CAAC+B,OAAO,CAACG,KAAK,EAAE,cAAc,EAAE,qDAAqD,CAAC;MACjG,IAAID,UAAU,CAACP,OAAO,EAAE;QACpB,IAAIK,OAAO,CAACL,OAAO,EACfK,OAAO,CAACL,OAAO,IAAI,IAAI,GAAGO,UAAU,CAACP,OAAO,CAAC,KAE7CK,OAAO,CAACL,OAAO,GAAGO,UAAU,CAACP,OAAO;MAC5C;MACA,MAAMa,IAAI,GAAG,IAAInD,IAAI,CAAC2C,OAAO,CAAC;MAC9B,IAAIjC,GAAG,CAACsC,OAAO,CAACI,gBAAgB,EAC5BD,IAAI,CAACE,QAAQ,GAAGhC,QAAQ;MAC5BL,GAAG,CAACM,KAAK,CAACgC,IAAI,CAACH,IAAI,CAAC;IACxB;EACJ;EACA,IAAI/B,UAAU,IAAIA,UAAU,GAAGD,MAAM,EACjCP,OAAO,CAACQ,UAAU,EAAE,YAAY,EAAE,mCAAmC,CAAC;EAC1EJ,GAAG,CAAC8B,KAAK,GAAG,CAACnC,EAAE,CAACQ,MAAM,EAAEA,MAAM,EAAEC,UAAU,IAAID,MAAM,CAAC;EACrD,OAAOH,GAAG;AACd;AAEA,SAAST,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}