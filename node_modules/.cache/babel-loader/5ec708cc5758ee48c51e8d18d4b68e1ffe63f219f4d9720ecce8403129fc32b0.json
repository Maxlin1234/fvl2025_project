{"ast":null,"code":"/*!\n * GSDevTools 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { Draggable } from \"./Draggable.js\";\nlet gsap,\n  _coreInitted,\n  _doc,\n  _docEl,\n  _win,\n  _recordedRoot,\n  Animation,\n  _rootTween,\n  _rootInstance,\n  _rootIsDirty,\n  _keyboardInstance,\n  _globalTimeline,\n  _independentRoot,\n  _delayedCall,\n  _context,\n  _recording = true,\n  _startupPhase = true,\n  //for the first 2 seconds, we don't record any zero-duration tweens because they're typically just setup stuff and/or the \"from\" or \"startAt\" tweens. In version 1.20.3 we started flagging those with data:\"isStart\"|\"isFromStart\" but this logic helps GSDevTools work with older versions too.\n  _globalStartTime = 0,\n  _windowExists = () => typeof window !== \"undefined\",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isString = value => typeof value === \"string\",\n  _isFunction = value => typeof value === \"function\",\n  _isObject = value => typeof value === \"object\",\n  _isUndefined = value => typeof value === \"undefined\",\n  _bonusValidated = 1,\n  //<name>GSDevTools</name>\n  _svgNS = \"http://www.w3.org/2000/svg\",\n  _domNS = \"http://www.w3.org/1999/xhtml\",\n  _idSeed = 0,\n  //we assign an ID to each GSDevTools instance so that we can segregate the sessionStorage data accordingly.\n  _lookup = {},\n  _supportsStorage = function () {\n    try {\n      sessionStorage.setItem(\"gsTest\", \"1\");\n      sessionStorage.removeItem(\"gsTest\");\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  _parseAnimation = animationOrId => animationOrId instanceof Animation ? animationOrId : animationOrId ? gsap.getById(animationOrId) : null,\n  _createElement = (type, container, cssText) => {\n    let element = _doc.createElementNS ? _doc.createElementNS(type === \"svg\" ? _svgNS : _domNS, type) : _doc.createElement(type);\n    if (container) {\n      if (_isString(container)) {\n        container = _doc.querySelector(container);\n      }\n      container.appendChild(element);\n    }\n    if (type === \"svg\") {\n      element.setAttribute(\"xmlns\", _svgNS);\n      element.setAttribute(\"xmlns:xlink\", _domNS);\n    }\n    cssText && (element.style.cssText = cssText);\n    return element;\n  },\n  _clearSelection = () => {\n    if (_doc.selection) {\n      _doc.selection.empty();\n    } else if (_win.getSelection) {\n      _win.getSelection().removeAllRanges();\n    }\n  },\n  _getChildrenOf = (timeline, includeTimelines) => {\n    let a = [],\n      cnt = 0,\n      Tween = gsap.core.Tween,\n      tween = timeline._first;\n    while (tween) {\n      if (tween instanceof Tween) {\n        if (tween.vars.id) {\n          a[cnt++] = tween;\n        }\n      } else {\n        if (includeTimelines && tween.vars.id) {\n          a[cnt++] = tween;\n        }\n        a = a.concat(_getChildrenOf(tween, includeTimelines));\n        cnt = a.length;\n      }\n      tween = tween._next;\n    }\n    return a;\n  },\n  _getClippedDuration = (animation, excludeRootRepeats) => {\n    let max = 0,\n      repeat = Math.max(0, animation._repeat),\n      t = animation._first;\n    if (!t) {\n      max = animation.duration();\n    }\n    while (t) {\n      max = Math.max(max, t.totalDuration() > 999 ? t.endTime(false) : t._start + t._tDur / t._ts);\n      t = t._next;\n    }\n    return !excludeRootRepeats && repeat ? max * (repeat + 1) + animation._rDelay * repeat : max;\n  },\n  _globalizeTime = function (animation, rawTime) {\n    let a = animation,\n      time = arguments.length > 1 ? +rawTime : a.rawTime();\n    while (a) {\n      time = a._start + time / (a._ts || 1);\n      a = a.parent;\n    }\n    return time;\n  },\n  _timeToProgress = (time, animation, defaultValue, relativeProgress) => {\n    let add, i, a;\n    if (_isString(time)) {\n      if (time.charAt(1) === \"=\") {\n        add = parseInt(time.charAt(0) + \"1\", 10) * parseFloat(time.substr(2));\n        if (add < 0 && relativeProgress === 0) {\n          //if something like inTime:\"-=2\", we measure it from the END, not the beginning\n          relativeProgress = 100;\n        }\n        time = relativeProgress / 100 * animation.duration() + add;\n      } else if (isNaN(time) && animation.labels && animation.labels[time] !== -1) {\n        time = animation.labels[time];\n      } else if (animation === _recordedRoot) {\n        //perhaps they defined an id of an animation, like \"myAnimation+=2\"\n        i = time.indexOf(\"=\");\n        if (i > 0) {\n          add = parseInt(time.charAt(i - 1) + \"1\", 10) * parseFloat(time.substr(i + 1));\n          time = time.substr(0, i - 1);\n        } else {\n          add = 0;\n        }\n        a = gsap.getById(time);\n        if (a) {\n          time = _globalizeTime(a, defaultValue / 100 * a.duration()) + add;\n        }\n      }\n    }\n    time = isNaN(time) ? defaultValue : parseFloat(time);\n    return Math.min(100, Math.max(0, time / animation.duration() * 100));\n  },\n  _addedCSS,\n  _createRootElement = (element, minimal, css) => {\n    if (!_addedCSS) {\n      _createElement(\"style\", _docEl).innerHTML = '.gs-dev-tools{height:51px;bottom:0;left:0;right:0;display:block;position:fixed;overflow:visible;padding:0;font-size:15px;font-family:-apple-system,BlinkMacSystemFont,avenir next,sans-serif;color:#bbbaa6}.gs-dev-tools *{box-sizing:content-box;visibility:visible}.gs-dev-tools .gs-top{position:relative;z-index:499}.gs-dev-tools .gs-bottom{display:flex;align-items:center;justify-content:space-between;gap:1rem;background-color:#0e100f;height:42px;position:relative}.gs-dev-tools .timeline{position:relative;height:8px;margin-left:15px;margin-right:15px;overflow:visible}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{height:8px;position:absolute;top:0;left:-15px;right:-15px}.gs-dev-tools .timeline-track{background-color:#222}.gs-dev-tools .progress-bar{background:linear-gradient(114.41deg,#0ae448 20.74%,#abff84 65.5%);height:8px;top:0;width:0;pointer-events:none}.gs-dev-tools .seek-bar{width:100%;position:absolute;height:24px;top:-12px;left:0;background-color:transparent}.gs-dev-tools .in-point,.gs-dev-tools .out-point{width:15px;height:26px;position:absolute;top:-18px}.gs-dev-tools .in-point-shape{fill:#0ae448;transform:translateX(1px)}.gs-dev-tools .out-point-shape{fill:#ff8709}.gs-dev-tools .in-point{transform:translateX(-100%)}.gs-dev-tools .out-point{left:100%}.gs-dev-tools .playhead{position:absolute;top:-5px;transform:translate(-50%,0);left:0;border-radius:50%;width:16px;height:16px;background:linear-gradient(114.41deg,#0ae448 20.74%,#abff84 65.5%)}.gs-dev-tools .gs-btn-white{fill:#fffce1}.gs-dev-tools .pause{opacity:0}.gs-dev-tools .select-animation{vertical-align:middle;position:relative;padding:6px 10px}.gs-dev-tools .select-animation-container{flex-grow:4;width:40%}.gs-dev-tools .select-arrow{display:inline-block;width:12px;height:7px;margin:0 7px;transform:translate(0,-2px)}.gs-dev-tools .select-arrow-shape{stroke:currentcolor;stroke-width:2px;fill:none}.gs-dev-tools .rewind{height:14px}.gs-dev-tools .ease-border,.gs-dev-tools .rewind-path{fill:currentColor}.gs-dev-tools .play-pause{width:18px;height:18px}.gs-dev-tools .ease{width:20px;height:20px;min-width:30px;display:none}.gs-dev-tools .ease-path{fill:none;stroke:#abff84;stroke-width:2px}.gs-dev-tools .time-scale{text-align:center;min-width:30px}.gs-dev-tools .loop{width:15px}.gs-dev-tools label span{text-decoration:none}.gs-dev-tools button:focus,.gs-dev-tools select:focus{outline:0}.gs-dev-tools label{position:relative;cursor:pointer}.gs-dev-tools label.locked{text-decoration:none;cursor:auto}.gs-dev-tools label input,.gs-dev-tools label select{position:absolute;left:0;top:0;z-index:1;font:inherit;font-size:inherit;line-height:inherit;height:100%;width:100%;color:#000!important;opacity:0;background:0 0;border:none;padding:0;margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer}.gs-dev-tools label input+.display{position:relative;z-index:2}.gs-dev-tools .gs-bottom-right{vertical-align:middle;display:flex;align-items:center;flex-grow:4;width:40%;justify-content:flex-end}.gs-dev-tools .time-container{margin:0 5px}.gs-dev-tools .logo{width:32px;height:32px;position:relative;top:2px;margin:0 12px}.gs-dev-tools .gs-hit-area{background-color:transparent;width:100%;height:100%;top:0;position:absolute}.gs-dev-tools.minimal{height:auto;display:flex;align-items:stretch}.gs-dev-tools.minimal .gs-top{order:2;flex-grow:4;background-color:#000}.gs-dev-tools.minimal .gs-bottom{background-color:#0e100f;border-top:none}.gs-dev-tools.minimal .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools.minimal .gs-bottom-right,.gs-dev-tools.minimal .in-point,.gs-dev-tools.minimal .out-point,.gs-dev-tools.minimal .rewind,.gs-dev-tools.minimal .select-animation-container{display:none}.gs-dev-tools.minimal .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools.minimal .time-scale{min-width:26px}.gs-dev-tools.minimal .loop{width:18px;min-width:18px;display:none}@media only screen and (max-width:600px){.gs-dev-tools{height:auto;display:flex;align-items:stretch}.gs-dev-tools .gs-top{order:2;flex-grow:4;background-color:#000;height:42px}.gs-dev-tools .gs-bottom{background-color:#000;border-top:none}.gs-dev-tools .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools .gs-bottom-right,.gs-dev-tools .in-point,.gs-dev-tools .out-point,.gs-dev-tools .rewind,.gs-dev-tools .select-animation-container{display:none}.gs-dev-tools .play-pause{width:18px;height:18px;padding:4px 6px;margin-left:14px}.gs-dev-tools .time-scale{min-width:26px}.gs-dev-tools .loop{width:18px;min-width:18px;display:none}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{right:0}}';\n      _addedCSS = true;\n    }\n    if (_isString(element)) {\n      element = _doc.querySelector(element);\n    }\n    let root = _createElement(\"div\", element || _docEl.getElementsByTagName(\"body\")[0] || _docEl);\n    root.setAttribute(\"class\", \"gs-dev-tools\" + (minimal ? \" minimal\" : \"\"));\n    root.innerHTML = '<div class=gs-hit-area></div><div class=gs-top><div class=timeline><div class=timeline-track></div><div class=progress-bar></div><div class=seek-bar></div><svg class=in-point viewBox=\"0 0 15 26\" xmlns=http://www.w3.org/2000/svg><path class=in-point-shape d=\"M0.5,2.283c0,-0.985 0.798,-1.783 1.783,-1.783c2.679,0 7.717,0 10.41,0c0.48,-0 0.939,0.19 1.278,0.529c0.339,0.339 0.529,0.798 0.529,1.277c-0,4.821 -0,17.897 0,21.968c0,0.253 -0.135,0.488 -0.354,0.615c-0.22,0.128 -0.49,0.128 -0.711,0.003c-2.653,-1.517 -9.526,-5.444 -12.016,-6.867c-0.568,-0.325 -0.919,-0.929 -0.919,-1.583c-0,-2.835 -0,-10.627 -0,-14.159Z\" style=\"fill:#00ff52;fill-rule:nonzero;\"/></svg><svg class=out-point viewBox=\"0 0 15 26\" xmlns=http://www.w3.org/2000/svg><path class=out-point-shape d=\"M0.5,2.251c0,-0.465 0.184,-0.91 0.513,-1.238c0.328,-0.329 0.773,-0.513 1.238,-0.513c2.669,0 7.733,0 10.439,0c0.48,-0 0.94,0.191 1.28,0.53c0.339,0.34 0.53,0.8 0.53,1.28l0,14.17c-0,0.631 -0.338,1.213 -0.886,1.526c-2.44,1.395 -9.262,5.293 -11.977,6.845c-0.236,0.134 -0.524,0.133 -0.759,-0.003c-0.234,-0.136 -0.378,-0.386 -0.378,-0.657c0,-4.178 0,-17.198 0,-21.94Z\" style=\"fill-rule:nonzero;\"/></svg><div class=playhead></div></div></div><div class=gs-bottom><div class=select-animation-container><label class=select-animation><select class=animation-list><option>Global Timeline<option>myTimeline</select><nobr><span class=\"display animation-label\">Global Timeline</span><svg class=select-arrow viewBox=\"0 0 12.05 6.73\" xmlns=http://www.w3.org/2000/svg><polyline class=select-arrow-shape points=\"0.35 0.35 6.03 6.03 11.7 0.35\"/></svg></nobr></label></div><svg class=rewind viewBox=\"0 0 12 15.38\" xmlns=http://www.w3.org/2000/svg><path d=M0,.38H2v15H0Zm2,7,10,7.36V0Z class=\"gs-btn-white rewind-path\"/></svg><svg class=play-pause viewBox=\"0 0 20.97 25.67\" xmlns=http://www.w3.org/2000/svg><g class=play><path d=\"M8,4.88 C8,10.18 8,15.48 8,20.79 5.33,22.41 2.66,24.04 0,25.67 0,17.11 0,8.55 0,0 2.66,1.62 5.33,3.25 8,4.88\" class=\"gs-btn-white play-1\" style=stroke:#fffce1;stroke-width:.6px /><path d=\"M14.485,8.855 C16.64,10.18 18.8,11.5 20.97,12.83 16.64,15.48 12.32,18.13 8,20.79 8,15.48 8,10.18 8,4.88 10.16,6.2 12.32,7.53 14.48,8.85\" class=\"gs-btn-white play-2\" style=stroke:#fffce1;stroke-width:.6px /></g></svg> <svg class=loop viewBox=\"0 0 29 25.38\" xmlns=http://www.w3.org/2000/svg fill=\"currentcolor\"><path d=M27.44,5.44,20.19,0V3.06H9.06A9.31,9.31,0,0,0,0,12.41,9.74,9.74,0,0,0,.69,16l3.06-2.23a6,6,0,0,1-.12-1.22,5.49,5.49,0,0,1,5.43-5.5H20.19v3.81Z class=loop-path /><path d=M25.25,11.54a5.18,5.18,0,0,1,.12,1.12,5.41,5.41,0,0,1-5.43,5.41H9.19V14.5L1.94,19.94l7.25,5.44V22.06H19.94A9.2,9.2,0,0,0,29,12.84a9.42,9.42,0,0,0-.68-3.53Z class=loop-path /></svg> <svg class=ease viewBox=\"0 0 25.67 25.67\" xmlns=http://www.w3.org/2000/svg><path d=M.48,25.12c1.74-3.57,4.28-12.6,8.8-10.7s4.75,1.43,6.5-1.11S19.89,1.19,25.2.55 class=ease-path /><path d=M24.67,1V24.67H1V1H24.67m1-1H0V25.67H25.67V0Z class=ease-border /></svg><label class=time-scale><select><option value=10>10x<option value=5>5x<option value=2>2x<option value=1 selected>1x<option value=0.5>0.5x<option value=0.25>0.25x<option value=0.1>0.1x</select><span class=\"display time-scale-label\">1x</span></label><div class=gs-bottom-right><div class=time-container><span class=time>0.00</span> / <span class=duration>0.00</span></div><a href=\"https://gsap.com/docs/v3/Plugins/GSDevTools?source=GSDevTools\" target=_blank title=Docs><svg class=\"logo\" viewBox=\"0 0 1080 1080\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M793 518.654C793 518.654 793 518.829 793 518.934L770.197 618.386C768.967 624.012 763.38 628.135 756.915 628.135H729.404C727.366 628.135 725.539 629.498 724.977 631.455C699.573 718.082 665.175 777.628 619.745 813.376C581.095 843.813 533.451 858 469.819 858C412.618 858 374.074 839.514 341.362 803.032C298.145 754.809 280.261 675.869 291.083 580.75C310.618 402.184 402.745 222.01 580.217 222.01C634.185 221.521 676.559 238.26 706.039 271.667C737.204 306.995 753.05 360.216 753.121 429.86C753.015 436.185 747.78 441.287 741.491 441.287H611.488C606.885 441.287 602.774 437.129 602.844 432.551C601.79 384.397 587.56 360.915 559.311 360.915C509.488 360.915 480.079 428.917 464.479 466.622C442.694 519.283 431.627 576.452 433.805 633.412C434.824 659.935 439.075 697.22 464.127 712.666C486.333 726.364 518.026 717.279 537.21 702.113C556.394 686.947 571.819 660.703 578.319 636.766C579.233 633.447 579.303 630.861 578.425 629.708C577.511 628.52 574.981 628.24 573.049 628.24H539.67C536.086 628.24 532.537 626.598 530.394 623.942C528.602 621.705 527.899 618.945 528.532 616.219L551.37 516.592C552.494 511.49 557.097 507.647 562.754 506.948V506.703H781.827C782.354 506.703 782.881 506.703 783.373 506.808C789.065 507.542 793.07 512.853 792.965 518.654H793Z\" fill=\"#0AE448\"/></svg></a></div></div>';\n    if (element) {\n      root.style.position = \"absolute\";\n      root.style.top = minimal ? \"calc(100% - 42px)\" : \"calc(100% - 51px)\";\n    }\n    if (css) {\n      if (_isString(css)) {\n        root.style.cssText = css;\n      } else if (_isObject(css)) {\n        css.data = \"root\";\n        gsap.set(root, css).kill();\n      }\n      if (root.style.top) {\n        root.style.bottom = \"auto\";\n      }\n      if (root.style.width) {\n        gsap.set(root, {\n          xPercent: -50,\n          left: \"50%\",\n          right: \"auto\",\n          data: \"root\"\n        }).kill();\n      }\n    }\n    if (!minimal && root.offsetWidth < 600) {\n      root.setAttribute(\"class\", \"gs-dev-tools minimal\");\n      if (element) {\n        root.style.top = \"calc(100% - 42px)\";\n      }\n    }\n    return root;\n  },\n  _clickedOnce = true,\n  //perhaps we shouldn't preventDefault() on the first mousedown/touchstart/pointerdown so that iframes get focus properly. Did that previously, but now it seems to prevent interaction on the first click (annoying).\n  _addListener = (e, type, callback, capture) => {\n    let handler, altType;\n    if (type === \"mousedown\" || type === \"mouseup\") {\n      e.style.cursor = \"pointer\";\n    }\n    if (type === \"mousedown\") {\n      //some browsers call BOTH mousedown AND touchstart, for example, on a single interaction so we need to skip one of them if both are called within 100ms.\n      altType = !_isUndefined(e.onpointerdown) ? \"pointerdown\" : !_isUndefined(e.ontouchstart) ? \"touchstart\" : null;\n      if (altType) {\n        handler = event => {\n          if (event.target.nodeName.toLowerCase() !== \"select\" && event.type === altType) {\n            //don't preventDefault() on a <select> or else it won't open!\n            event.stopPropagation();\n            if (_clickedOnce) {\n              //otherwise, both touchstart and mousedown will get called.\n              event.preventDefault();\n              callback.call(e, event);\n            }\n          } else if (event.type !== altType) {\n            callback.call(e, event);\n          }\n          _clickedOnce = true;\n        };\n        e.addEventListener(altType, handler, capture);\n        if (altType !== \"pointerdown\") {\n          e.addEventListener(type, handler, capture);\n        }\n        return;\n      }\n    }\n    e.addEventListener(type, callback, capture);\n  },\n  _removeListener = (e, type, callback) => {\n    e.removeEventListener(type, callback);\n    type = type !== \"mousedown\" ? null : !_isUndefined(e.onpointerdown) ? \"pointerdown\" : !_isUndefined(e.ontouchstart) ? \"touchstart\" : null;\n    if (type) {\n      e.removeEventListener(type, callback);\n    }\n  },\n  _selectValue = (element, value, label, insertIfAbsent) => {\n    let options = element.options,\n      i = options.length,\n      option;\n    value += \"\";\n    while (--i > -1) {\n      if (options[i].innerHTML === value || options[i].value === value) {\n        element.selectedIndex = i;\n        label.innerHTML = options[i].innerHTML;\n        return options[i];\n      }\n    }\n    if (insertIfAbsent) {\n      option = _createElement(\"option\", element);\n      option.setAttribute(\"value\", value);\n      option.innerHTML = label.innerHTML = _isString(insertIfAbsent) ? insertIfAbsent : value;\n      element.selectedIndex = options.length - 1;\n    }\n  },\n  //increments the selected value of a <select> up or down by a certain amount.\n  _shiftSelectedValue = (element, amount, label) => {\n    let options = element.options,\n      i = Math.min(options.length - 1, Math.max(0, element.selectedIndex + amount));\n    element.selectedIndex = i;\n    if (label) {\n      label.innerHTML = options[i].innerHTML;\n    }\n    return options[i].value;\n  },\n  //moves everything from _globalTimeline into _recordedRoot and updates the _rootTween if it is currently controlling the Global timeline (_recordedRoot). _recordedTemp is just a temporary recording area for anything that happens while _recordedRoot is paused. Returns true if the _recordedRoot's duration changed due to the merge.\n  _merge = () => {\n    let t = _globalTimeline._first,\n      duration,\n      next,\n      target;\n    if (_rootInstance) {\n      duration = _recordedRoot._dur;\n      while (t) {\n        next = t._next;\n        target = t._targets && t._targets[0];\n        if (!(_isFunction(target) && target === t.vars.onComplete && !t._dur) && !(target && target._gsIgnore)) {\n          //typically, delayedCalls aren't included in the _recordedTemp, but since the hijacked add() below fires BEFORE TweenLite's constructor sets the target, we couldn't check that target === vars.onComplete there. And Draggable creates a tween with just an onComplete (no onReverseComplete), thus it fails that test. Therefore, we test again here to avoid merging that in.\n          _recordedRoot.add(t, t._start - t._delay);\n        }\n        t = next;\n      }\n      return duration !== _recordedRoot.duration();\n    }\n  },\n  _updateRootDuration = () => {\n    if (_rootInstance) {\n      _rootInstance.update();\n      _rootIsDirty = false;\n    }\n    gsap.ticker.remove(_updateRootDuration);\n  },\n  _buildPlayPauseMorph = svg => {\n    let tl = gsap.timeline({\n      data: \"root\",\n      parent: _independentRoot,\n      onComplete: () => tl.kill()\n    }, _independentRoot._time);\n    tl.to(svg.querySelector(\".play-1\"), {\n      duration: 0.4,\n      attr: {\n        d: \"M5.75,3.13 C5.75,9.79 5.75,16.46 5.75,23.13 4.08,23.13 2.41,23.13 0.75,23.13 0.75,16.46 0.75,9.79 0.75,3.12 2.41,3.12 4.08,3.12 5.75,3.12\"\n      },\n      ease: \"power2.inOut\",\n      rotation: 360,\n      transformOrigin: \"50% 50%\"\n    }).to(svg.querySelector(\".play-2\"), {\n      duration: 0.4,\n      attr: {\n        d: \"M16.38,3.13 C16.38,9.79 16.38,16.46 16.38,23.13 14.71,23.13 13.04,23.13 11.38,23.13 11.38,16.46 11.38,9.79 11.38,3.12 13.04,3.12 14.71,3.12 16.38,3.12\"\n      },\n      ease: \"power2.inOut\",\n      rotation: 360,\n      transformOrigin: \"50% 50%\"\n    }, 0.05);\n    return tl;\n  },\n  _buildLoopAnimation = svg => {\n    let tl = gsap.timeline({\n      data: \"root\",\n      id: \"loop\",\n      parent: _independentRoot,\n      paused: true,\n      onComplete: () => tl.kill()\n    }, _independentRoot._time);\n    tl.to(svg, {\n      duration: 0.5,\n      rotation: 360,\n      ease: \"power3.inOut\",\n      transformOrigin: \"50% 50%\"\n    }).to(svg.querySelectorAll(\".loop-path\"), {\n      duration: 0.5,\n      fill: \"#91e600\",\n      ease: \"none\"\n    }, 0);\n    return tl;\n  },\n  _getAnimationById = id => gsap.getById(id) || _independentRoot.getById(id) || id === _recordedRoot.vars.id && _recordedRoot,\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (!_coreInitted) {\n      if (gsap && _windowExists()) {\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _win = window;\n        _context = gsap.core.context || function () {};\n        gsap.registerPlugin(Draggable);\n        _globalTimeline = gsap.globalTimeline;\n        _globalTimeline._sort = true;\n        _globalTimeline.autoRemoveChildren = false;\n        Animation = gsap.core.Animation;\n        _independentRoot = gsap.timeline({\n          data: \"indy\",\n          autoRemoveChildren: true,\n          smoothChildTiming: true\n        });\n        _independentRoot.kill();\n        _independentRoot._dp = 0; //don't let it revert to the global timeline as its parent.\n        _independentRoot.to({}, {\n          duration: 1e12\n        });\n        _recordedRoot = gsap.timeline({\n          data: \"root\",\n          id: \"Global Timeline\",\n          autoRemoveChildren: false,\n          smoothChildTiming: true,\n          parent: _independentRoot\n        }, 0);\n        _rootTween = gsap.to(_recordedRoot, {\n          duration: 1,\n          time: 1,\n          ease: \"none\",\n          data: \"root\",\n          id: \"_rootTween\",\n          paused: true,\n          immediateRender: false,\n          parent: _independentRoot\n        }, 0);\n        // so that auto-overwriting works. Initially we transferred the tweens to the _recordedRoot.\n        _globalTimeline.killTweensOf = function (targets, props, onlyActive) {\n          _recordedRoot.killTweensOf(targets, props, onlyActive);\n          _recordedRoot.killTweensOf.call(_globalTimeline, targets, props, onlyActive);\n        };\n        _independentRoot._start = gsap.ticker.time;\n        gsap.ticker.add(time => _independentRoot.render(time - _independentRoot._start));\n        // before 3.7.0, the listener below was necessary (in place of the line above)\n        // gsap.ticker.add(time => {\n        // \t_independentRoot._initted || _independentRoot.render(0.001, true); // to prevent callbacks from being fired on the first tick, like onComplete would fire immediately and then again at the correct time.\n        // \t_independentRoot.render(time - _independentRoot._start);\n        // });\n\n        //align the all of the playheads so they're starting at 0 now.\n        _globalTimeline._start += _globalTimeline._time;\n        _recordedRoot._start = _globalTimeline._time = _globalTimeline._tTime = 0;\n        _delayedCall = (delay, callback, params, scope) => gsap.to(callback, {\n          delay: delay,\n          duration: 0,\n          onComplete: callback,\n          onReverseComplete: callback,\n          onCompleteParams: params,\n          onReverseCompleteParams: params,\n          callbackScope: scope,\n          parent: _independentRoot\n        }, _independentRoot._time);\n\n        //in case GSDevTools.create() is called before anything is actually on the global timeline, we've gotta update it or else the duration will be 0 and it'll be stuck.\n        _delayedCall(0.01, () => _rootInstance ? _rootInstance.update() : _merge());\n\n        //initially we record everything into the _recordedRoot Timeline because developers might call GSDevTools.create() AFTER some of their code executes, but after 2 seconds if there aren't any GSDevTool instances that have globalSync enabled, we should dump all the stuff from _recordedRoot into the global timeline to improve performance and avoid issues where _recordedRoot is paused and reaches its end and wants to stop the playhead.\n        _delayedCall(2, () => {\n          let t, next, offset;\n          if (!_rootInstance) {\n            _merge();\n            t = _recordedRoot._first;\n            offset = _recordedRoot._start;\n            while (t) {\n              next = t._next;\n              //any animations that aren't finished should be dumped into the root timeline. If they're done, just kill them.\n              if (t._tDur !== t._tTime || !t._dur && t.progress() !== 1) {\n                _globalTimeline.add(t, t._start - t._delay + offset);\n              } else {\n                t.kill();\n              }\n              t = next;\n            }\n          }\n          if (GSDevTools.globalRecordingTime > 2) {\n            _delayedCall(GSDevTools.globalRecordingTime - 2, () => {\n              _rootInstance && _rootInstance.update();\n              _recording = false;\n              _globalTimeline.autoRemoveChildren = true;\n            });\n          } else {\n            _recording = false;\n            _globalTimeline.autoRemoveChildren = true;\n          }\n          _startupPhase = false;\n        });\n        _coreInitted = 1;\n      }\n    }\n  },\n  _checkIndependence = (animation, vars) => {\n    if (!vars.globalSync && animation.parent !== _globalTimeline) {\n      //in case it's nested in a timeline (playing it won't help if the parent timeline isn't playing).\n      _globalTimeline.add(animation, _globalTimeline.time());\n    }\n  },\n  GSDevTools = function (vars) {\n    if (!_coreInitted) {\n      _initCore();\n      gsap || console.warn(\"Please gsap.registerPlugin(GSDevTools)\");\n    }\n    this.vars = vars = vars || {};\n    if (vars.animation) {\n      (GSDevTools.getByAnimation(vars.animation) || {\n        kill: () => 0\n      }).kill();\n    }\n    vars.id = vars.id || (_isString(vars.animation) ? vars.animation : _idSeed++); //try to find a unique ID so that sessionStorage can be mapped to it (otherwise, for example, all the embedded codepens on a page would share the same settings). So if no id is defined, see if there's a string-based \"animation\" defined. Last of all, we default to a numeric counter that we increment.\n    _lookup[vars.id + \"\"] = this;\n    \"globalSync\" in vars || (vars.globalSync = !vars.animation); //if the user calls create() and passes in an animation AFTER the initial recording time has elapsed, there's a good chance the animation won't be in the recordedRoot, so we change the default globalSync to false because that's the most intuitive behavior.\n\n    //GENERAL/UTILITY\n    let _self = this,\n      root = _createRootElement(vars.container, vars.minimal, vars.css),\n      find = s => root.querySelector(s),\n      record = (key, value) => {\n        if (vars.persist !== false && _supportsStorage) {\n          sessionStorage.setItem(\"gs-dev-\" + key + vars.id, value);\n        }\n        return value;\n      },\n      recall = key => {\n        let value;\n        if (vars.persist !== false && _supportsStorage) {\n          value = sessionStorage.getItem(\"gs-dev-\" + key + vars.id);\n          return key === \"animation\" ? value : key === \"loop\" ? value === \"true\" : parseFloat(value); // handle data typing too.\n        }\n      },\n      //SCRUBBER/PROGRESS\n      playhead = find(\".playhead\"),\n      timelineTrack = find(\".timeline-track\"),\n      progressBar = find(\".progress-bar\"),\n      timeLabel = find(\".time\"),\n      durationLabel = find(\".duration\"),\n      pixelToTimeRatio,\n      timeAtDragStart,\n      dragged,\n      skipDragUpdates,\n      progress = 0,\n      inPoint = find(\".in-point\"),\n      outPoint = find(\".out-point\"),\n      inProgress = 0,\n      outProgress = 100,\n      pausedWhenDragStarted,\n      list = find(\".animation-list\"),\n      animationLabel = find(\".animation-label\"),\n      selectedAnimation,\n      //the currently selected animation\n      linkedAnimation,\n      //the animation that's linked to all the controls and scrubber. This is always _rootTween if globalSync is true, so it can be different than the selectedAnimation!\n      declaredAnimation,\n      //whatever the user defines in the config object initially (often this will be null). If the user defines a string, it'll be resolved to a real Animation instance for this variable.\n      startTime,\n      endTime,\n      _fullyInitialized,\n      //we call initialize() initially, and then again on the very next tick just in case someone called GSDevTools.create() BEFORE they create their animations. This variable tracks that state. Note: we don't record sessionStorage.setItem() until we're fully initialized, otherwise we may inadvertently set in/out points to the defaults just because the animation couldn't be found (yet).\n      keyboardHandler,\n      playPauseButton = find(\".play-pause\"),\n      playPauseMorph = _buildPlayPauseMorph(playPauseButton),\n      paused = false,\n      loopButton = find(\".loop\"),\n      loopAnimation = _buildLoopAnimation(loopButton),\n      loopEnabled,\n      timeScale = find(\".time-scale select\"),\n      timeScaleLabel = find(\".time-scale-label\"),\n      //spits back a common onPress function for anything that's dragged along the timeline (playhead, inPoint, outPoint). The originRatio is a value from 0-1 indicating how far along the x-axis the origin is located (0.5 is in the center, 0 is left, 1 is on right side). limitElement is optional, and sets the bounds such that the element can't be dragged past the limitElement.\n      onPressTimeline = (element, originRatio, limitToInOut) => {\n        return function (e) {\n          let trackBounds = timelineTrack.getBoundingClientRect(),\n            elementBounds = element.getBoundingClientRect(),\n            left = elementBounds.width * originRatio,\n            x = gsap.getProperty(element, \"x\"),\n            minX = trackBounds.left - elementBounds.left - left + x,\n            maxX = trackBounds.right - elementBounds.right + (elementBounds.width - left) + x,\n            unlimitedMinX = minX,\n            limitBounds;\n          if (limitToInOut) {\n            if (element !== inPoint) {\n              limitBounds = inPoint.getBoundingClientRect();\n              if (limitBounds.left) {\n                //if inPoint is hidden (like display:none), ignore.\n                minX += limitBounds.left + limitBounds.width - trackBounds.left;\n              }\n            }\n            if (element !== outPoint) {\n              limitBounds = outPoint.getBoundingClientRect();\n              if (limitBounds.left) {\n                //if outPoint is hidden (like display:none), ignore.\n                maxX -= trackBounds.left + trackBounds.width - limitBounds.left;\n              }\n            }\n          }\n          pausedWhenDragStarted = paused;\n          this.applyBounds({\n            minX: minX,\n            maxX: maxX\n          });\n          pixelToTimeRatio = linkedAnimation.duration() / trackBounds.width;\n          timeAtDragStart = -unlimitedMinX * pixelToTimeRatio;\n          if (!skipDragUpdates) {\n            linkedAnimation.pause(timeAtDragStart + pixelToTimeRatio * this.x);\n          } else {\n            linkedAnimation.pause();\n          }\n          if (this.target === playhead) {\n            if (this.activated) {\n              this.allowEventDefault = false;\n            }\n            this.activated = true;\n          }\n          dragged = true;\n        };\n      },\n      progressDrag = Draggable.create(playhead, {\n        type: \"x\",\n        cursor: \"ew-resize\",\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n        onPress: onPressTimeline(playhead, 0.5, true),\n        onDrag: function () {\n          let time = timeAtDragStart + pixelToTimeRatio * this.x;\n          if (time < 0) {\n            time = 0;\n          } else if (time > linkedAnimation._dur) {\n            time = linkedAnimation._dur;\n          }\n          if (!skipDragUpdates) {\n            linkedAnimation.time(time);\n          }\n          progressBar.style.width = Math.min(outProgress - inProgress, Math.max(0, time / linkedAnimation._dur * 100 - inProgress)) + \"%\";\n          timeLabel.innerHTML = time.toFixed(2);\n        },\n        onRelease: function () {\n          paused || linkedAnimation.resume();\n        }\n      })[0],\n      resetInOut = () => {\n        inProgress = 0;\n        outProgress = 100;\n        inPoint.style.left = \"0%\";\n        outPoint.style.left = \"100%\";\n        record(\"in\", inProgress);\n        record(\"out\", outProgress);\n        updateProgress(true);\n      },\n      inDrag = Draggable.create(inPoint, {\n        type: \"x\",\n        cursor: \"ew-resize\",\n        zIndexBoost: false,\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n        onPress: onPressTimeline(inPoint, 1, true),\n        onDoubleClick: resetInOut,\n        onDrag: function () {\n          inProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n          linkedAnimation.progress(inProgress / 100);\n          updateProgress(true);\n        },\n        onRelease: function () {\n          if (inProgress < 0) {\n            inProgress = 0;\n          }\n          _clearSelection();\n          //for responsiveness, convert the px-based transform into %-based left position.\n          inPoint.style.left = inProgress + \"%\";\n          record(\"in\", inProgress);\n          gsap.set(inPoint, {\n            x: 0,\n            data: \"root\",\n            display: \"block\"\n          }); //set display:block so that it remains visible even when the minimal skin is enabled.\n          if (!paused) {\n            linkedAnimation.resume();\n          }\n        }\n      })[0],\n      outDrag = Draggable.create(outPoint, {\n        type: \"x\",\n        cursor: \"ew-resize\",\n        allowNativeTouchScrolling: false,\n        allowEventDefault: true,\n        //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n        zIndexBoost: false,\n        onPress: onPressTimeline(outPoint, 0, true),\n        onDoubleClick: resetInOut,\n        onDrag: function () {\n          outProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n          linkedAnimation.progress(outProgress / 100);\n          updateProgress(true);\n        },\n        onRelease: function () {\n          if (outProgress > 100) {\n            outProgress = 100;\n          }\n          _clearSelection();\n          //for responsiveness, convert the px-based transform into %-based left position.\n          outPoint.style.left = outProgress + \"%\";\n          record(\"out\", outProgress);\n          gsap.set(outPoint, {\n            x: 0,\n            data: \"root\",\n            display: \"block\"\n          }); //set display:block so that it remains visible even when the minimal skin is enabled.\n          if (!pausedWhenDragStarted) {\n            play();\n            linkedAnimation.resume();\n          }\n        }\n      })[0],\n      updateProgress = function (force) {\n        // NOTE: \"force\" is actually the \"time\" when this method gets called by the gsap.ticker!\n        if (progressDrag.isPressed && force !== true) {\n          return;\n        }\n        let p = !loopEnabled && selectedAnimation._repeat === -1 ? selectedAnimation.totalTime() / selectedAnimation.duration() * 100 : linkedAnimation.progress() * 100 || 0,\n          repeatDelayPhase = selectedAnimation._repeat && selectedAnimation._rDelay && selectedAnimation.totalTime() % (selectedAnimation.duration() + selectedAnimation._rDelay) > selectedAnimation.duration(),\n          target;\n        if (p > 100) {\n          p = 100;\n        }\n        if (p >= outProgress) {\n          if (loopEnabled && !linkedAnimation.paused() && !progressDrag.isDragging) {\n            if (!repeatDelayPhase) {\n              p = inProgress;\n              target = linkedAnimation._targets && linkedAnimation._targets[0];\n              if (target === selectedAnimation) {\n                //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n                target.seek(startTime + (endTime - startTime) * inProgress / 100);\n              }\n              if (selectedAnimation._repeat > 0 && !inProgress && outProgress === 100) {\n                if (selectedAnimation.totalProgress() === 1) {\n                  linkedAnimation.totalProgress(0, true).resume();\n                }\n              } else {\n                linkedAnimation.progress(p / 100, true).resume();\n              }\n            }\n          } else {\n            if (p !== outProgress || selectedAnimation._repeat === -1) {\n              p = outProgress;\n              linkedAnimation.progress(p / 100);\n            }\n            if (!paused && (outProgress < 100 || selectedAnimation.totalProgress() === 1 || selectedAnimation._repeat === -1)) {\n              pause();\n            }\n          }\n        } else if (p < inProgress) {\n          p = inProgress;\n          linkedAnimation.progress(p / 100, true);\n        }\n        if (p !== progress || force === true) {\n          progressBar.style.left = inProgress + \"%\";\n          progressBar.style.width = Math.max(0, p - inProgress) + \"%\";\n          playhead.style.left = p + \"%\";\n          timeLabel.innerHTML = linkedAnimation._time.toFixed(2);\n          durationLabel.innerHTML = linkedAnimation._dur.toFixed(2);\n          if (dragged) {\n            playhead.style.transform = \"translate(-50%,0)\";\n            playhead._gsap.x = \"0px\";\n            playhead._gsap.xPercent = -50;\n            dragged = false;\n          }\n          progress = p;\n        }\n        linkedAnimation.paused() !== paused && togglePlayPause(); // if the user has an addPause() in the middle of the animation.\n      },\n      onPressSeekBar = function (e) {\n        if (progressDrag.isPressed) {\n          return;\n        }\n        let bounds = e.target.getBoundingClientRect(),\n          x = (e.changedTouches ? e.changedTouches[0] : e).clientX,\n          p = (x - bounds.left) / bounds.width * 100;\n        if (p < inProgress) {\n          inProgress = p = Math.max(0, p);\n          inPoint.style.left = inProgress + \"%\";\n          inDrag.startDrag(e);\n          return;\n        } else if (p > outProgress) {\n          outProgress = p = Math.min(100, p);\n          outPoint.style.left = outProgress + \"%\";\n          outDrag.startDrag(e);\n          return;\n        }\n        linkedAnimation.progress(p / 100).pause();\n        updateProgress(true);\n        progressDrag.startDrag(e);\n      },\n      //PLAY/PAUSE button\n      play = () => {\n        if (linkedAnimation.progress() >= outProgress / 100) {\n          _checkIndependence(linkedAnimation, vars);\n          let target = linkedAnimation._targets && linkedAnimation._targets[0];\n          if (target === selectedAnimation) {\n            //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n            target.seek(startTime + (endTime - startTime) * inProgress / 100);\n          }\n          if (linkedAnimation._repeat && !inProgress) {\n            linkedAnimation.totalProgress(0, true); //for repeating animations, don't get stuck in the last iteration - jump all the way back to the start.\n          } else if (!linkedAnimation.reversed()) {\n            linkedAnimation.progress(inProgress / 100, true);\n          }\n        }\n        playPauseMorph.play();\n        linkedAnimation.resume();\n        if (paused) {\n          _self.update();\n        }\n        paused = false;\n      },\n      pause = () => {\n        playPauseMorph.reverse();\n        if (linkedAnimation) {\n          linkedAnimation.pause();\n        }\n        paused = true;\n      },\n      togglePlayPause = () => {\n        if (paused) {\n          play();\n        } else {\n          pause();\n        }\n      },\n      //REWIND button\n      onPressRewind = e => {\n        if (progressDrag.isPressed) {\n          return;\n        }\n        //_self.update();\n        _checkIndependence(linkedAnimation, vars);\n        let target = linkedAnimation._targets && linkedAnimation._targets[0];\n        if (target === selectedAnimation) {\n          //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n          target.seek(startTime + (endTime - startTime) * inProgress / 100);\n        }\n        linkedAnimation.progress(inProgress / 100, true);\n        if (!paused) {\n          linkedAnimation.resume();\n        }\n      },\n      //LOOP button\n      loop = value => {\n        loopEnabled = value;\n        record(\"loop\", loopEnabled);\n        if (loopEnabled) {\n          loopAnimation.play();\n          if (linkedAnimation.progress() >= outProgress / 100) {\n            let target = linkedAnimation._targets && linkedAnimation._targets[0];\n            if (target === selectedAnimation) {\n              //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n              target.seek(startTime + (endTime - startTime) * inProgress / 100);\n            }\n            if (selectedAnimation._repeat && !inProgress && outProgress === 100) {\n              linkedAnimation.totalProgress(0, true);\n            } else {\n              linkedAnimation.progress(inProgress / 100, true);\n            }\n            play();\n          }\n        } else {\n          loopAnimation.reverse();\n        }\n      },\n      toggleLoop = () => loop(!loopEnabled),\n      //ANIMATIONS list\n      updateList = () => {\n        let animations = _getChildrenOf(declaredAnimation && !vars.globalSync ? declaredAnimation : _recordedRoot, true),\n          options = list.children,\n          matches = 0,\n          option,\n          i;\n        if (declaredAnimation && !vars.globalSync) {\n          animations.unshift(declaredAnimation);\n        } else if (!vars.hideGlobalTimeline) {\n          animations.unshift(_recordedRoot);\n        }\n        for (i = 0; i < animations.length; i++) {\n          option = options[i] || _createElement(\"option\", list);\n          option.animation = animations[i];\n          matches = i && animations[i].vars.id === animations[i - 1].vars.id ? matches + 1 : 0;\n          option.setAttribute(\"value\", option.innerHTML = animations[i].vars.id + (matches ? \" [\" + matches + \"]\" : animations[i + 1] && animations[i + 1].vars.id === animations[i].vars.id ? \" [0]\" : \"\"));\n        }\n        for (; i < options.length; i++) {\n          list.removeChild(options[i]);\n        }\n      },\n      animation = function (anim) {\n        let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n          tl,\n          maxDuration;\n        if (!arguments.length) {\n          return selectedAnimation;\n        }\n        if (_isString(anim)) {\n          anim = _getAnimationById(anim);\n        }\n        //console.log(\"animation() \", anim.vars.id);\n        if (!(anim instanceof Animation)) {\n          console.warn(\"GSDevTools error: invalid animation.\");\n        }\n        if (anim.scrollTrigger) {\n          console.warn(\"GSDevTools can't work with ScrollTrigger-based animations; either the scrollbar -OR- the GSDevTools scrubber can control the animation.\");\n        }\n        if (anim === selectedAnimation) {\n          return;\n        }\n        if (selectedAnimation) {\n          selectedAnimation._inProgress = inProgress;\n          selectedAnimation._outProgress = outProgress;\n        }\n        selectedAnimation = anim;\n        if (linkedAnimation) {\n          ts = linkedAnimation.timeScale();\n          if (linkedAnimation._targets && linkedAnimation._targets[0] === declaredAnimation) {\n            declaredAnimation.resume();\n            linkedAnimation.kill();\n          }\n        }\n        inProgress = selectedAnimation._inProgress || 0;\n        outProgress = selectedAnimation._outProgress || 100;\n        inPoint.style.left = inProgress + \"%\";\n        outPoint.style.left = outProgress + \"%\";\n        if (_fullyInitialized) {\n          //don't record inProgress/outProgress unless we're fully instantiated because people may call GSDevTools.create() before creating/defining their animations, thus the inTime/outTime may not exist yet.\n          record(\"animation\", selectedAnimation.vars.id);\n          record(\"in\", inProgress);\n          record(\"out\", outProgress);\n        }\n        startTime = 0;\n        maxDuration = vars.maxDuration || Math.min(1000, _getClippedDuration(selectedAnimation));\n        if (selectedAnimation === _recordedRoot || vars.globalSync) {\n          _merge();\n          linkedAnimation = _rootTween;\n          _rootInstance && _rootInstance !== _self && console.warn(\"Error: GSDevTools can only have one instance that's globally synchronized.\");\n          _rootInstance = _self;\n          if (selectedAnimation !== _recordedRoot) {\n            tl = selectedAnimation;\n            endTime = tl.totalDuration();\n            if (endTime > 99999999) {\n              //in the case of an infinitely repeating animation, just use a single iteration's duration instead.\n              endTime = tl.duration();\n            }\n            while (tl.parent) {\n              startTime = startTime / tl._ts + tl._start;\n              endTime = endTime / tl._ts + tl._start;\n              tl = tl.parent;\n            }\n          } else {\n            endTime = _recordedRoot.duration();\n          }\n          if (endTime - startTime > maxDuration) {\n            //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.\n            endTime = startTime + maxDuration;\n          }\n          _recordedRoot.pause(startTime);\n          _rootTween.vars.time = endTime;\n          _rootTween.invalidate();\n          _rootTween.duration(endTime - startTime).timeScale(ts);\n          //wait for a tick before starting because some browsers freeze things immediately following a <select> selection, like on MacOS it flashes a few times before disappearing, so this prevents a \"jump\".\n          if (paused) {\n            //jump forward and then back in order to make sure the start/end values are recorded internally right away and don't drift outside this tween.\n            _rootTween.progress(1, true).pause(0, true);\n          } else {\n            _delayedCall(0.01, () => {\n              _rootTween.resume().progress(inProgress / 100);\n              paused && play();\n            });\n          }\n        } else {\n          if (_rootInstance === _self) {\n            _rootInstance = null;\n          }\n          startTime = Math.min(inProgress * selectedAnimation.duration(), selectedAnimation.time());\n          if (selectedAnimation === declaredAnimation || !declaredAnimation) {\n            linkedAnimation = selectedAnimation;\n            if (!loopEnabled && linkedAnimation._repeat) {\n              loop(true);\n            }\n          } else {\n            //if an animation is declared in the config object, and the user chooses a sub-animation (nested), we tween the playhead of the declaredAnimation to keep everything synchronized even though globalSync isn't true.\n            tl = selectedAnimation;\n            endTime = tl.totalDuration();\n            if (endTime > 99999999) {\n              //in the case of an infinitely repeating animation, just use a single iteration's duration instead.\n              endTime = tl.duration();\n            }\n            while (tl.parent.parent && tl !== declaredAnimation) {\n              startTime = startTime / (tl._ts || tl._pauseTS) + tl._start;\n              endTime = endTime / (tl._ts || tl._pauseTS) + tl._start;\n              tl = tl.parent;\n            }\n            if (endTime - startTime > maxDuration) {\n              //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.\n              endTime = startTime + maxDuration;\n            }\n            declaredAnimation.pause(startTime);\n            linkedAnimation = gsap.to(declaredAnimation, {\n              duration: endTime - startTime,\n              time: endTime,\n              ease: \"none\",\n              data: \"root\",\n              parent: _independentRoot\n            }, _independentRoot._time);\n          }\n          linkedAnimation.timeScale(ts);\n          _rootTween.pause();\n          _recordedRoot.resume();\n          linkedAnimation.seek(0);\n        }\n        durationLabel.innerHTML = linkedAnimation.duration().toFixed(2);\n        _selectValue(list, selectedAnimation.vars.id, animationLabel);\n      },\n      updateRootDuration = () => {\n        let time, ratio, duration;\n        if (selectedAnimation === _recordedRoot) {\n          time = _recordedRoot._time;\n          _recordedRoot.progress(1, true).time(time, true); //jump to the end and back again because sometimes a tween that hasn't rendered yet will affect duration, like a TimelineMax.tweenTo() where the duration gets set in the onStart.\n          time = (_rootTween._dp._time - _rootTween._start) * _rootTween._ts;\n          duration = Math.min(1000, _recordedRoot.duration());\n          if (duration === 1000) {\n            duration = Math.min(1000, _getClippedDuration(_recordedRoot));\n          }\n          ratio = _rootTween.duration() / duration;\n          if (ratio !== 1 && duration) {\n            inProgress *= ratio;\n            if (outProgress < 100) {\n              outProgress *= ratio;\n            }\n            _rootTween.seek(0);\n            _rootTween.vars.time = duration;\n            _rootTween.invalidate();\n            _rootTween.duration(duration);\n            _rootTween.time(time);\n            durationLabel.innerHTML = duration.toFixed(2);\n            inPoint.style.left = inProgress + \"%\";\n            outPoint.style.left = outProgress + \"%\";\n            updateProgress(true);\n          }\n        }\n      },\n      onChangeAnimation = e => {\n        animation(list.options[list.selectedIndex].animation);\n        if (e.target && e.target.blur) {\n          //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.\n          e.target.blur();\n        }\n        paused && play();\n      },\n      //TIMESCALE button\n      onChangeTimeScale = e => {\n        let ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n          target;\n        linkedAnimation.timeScale(ts);\n        record(\"timeScale\", ts);\n        if (!paused) {\n          if (linkedAnimation.progress() >= outProgress / 100) {\n            target = linkedAnimation._targets && linkedAnimation._targets[0];\n            if (target === selectedAnimation) {\n              //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n              target.seek(startTime + (endTime - startTime) * inProgress / 100);\n            }\n            linkedAnimation.progress(inProgress / 100, true).pause();\n          } else {\n            linkedAnimation.pause();\n          }\n          _delayedCall(0.01, () => linkedAnimation.resume());\n        }\n        timeScaleLabel.innerHTML = ts + \"x\";\n        if (timeScale.blur) {\n          //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.\n          timeScale.blur();\n        }\n      },\n      //AUTOHIDE\n      autoHideTween = gsap.to([find(\".gs-bottom\"), find(\".gs-top\")], {\n        duration: 0.3,\n        autoAlpha: 0,\n        y: 50,\n        ease: \"power2.in\",\n        data: \"root\",\n        paused: true,\n        parent: _independentRoot\n      }, _independentRoot._time),\n      hidden = false,\n      onMouseOut = e => {\n        if (!Draggable.hitTest(e, root) && !progressDrag.isDragging && !inDrag.isDragging && !outDrag.isDragging) {\n          autoHideDelayedCall.restart(true);\n        }\n      },\n      hide = () => {\n        if (!hidden) {\n          autoHideTween.play();\n          autoHideDelayedCall.pause();\n          hidden = true;\n        }\n      },\n      show = () => {\n        autoHideDelayedCall.pause();\n        if (hidden) {\n          autoHideTween.reverse();\n          hidden = false;\n        }\n      },\n      toggleHide = () => {\n        if (hidden) {\n          show();\n        } else {\n          hide();\n        }\n      },\n      autoHideDelayedCall = _delayedCall(1.3, hide).pause(),\n      initialize = preliminary => {\n        //if on startup, someone does a timeline.seek(), we must honor it, so when initialize() is called, we record _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n        if (_startupPhase && !_globalStartTime) {\n          _globalStartTime = _recordedRoot._start;\n        }\n        _fullyInitialized = !preliminary;\n        declaredAnimation = _parseAnimation(vars.animation);\n        if (declaredAnimation && !declaredAnimation.vars.id) {\n          declaredAnimation.vars.id = \"[no id]\";\n        }\n        _merge();\n        updateList();\n        let savedAnimation = _getAnimationById(recall(\"animation\"));\n        if (savedAnimation) {\n          savedAnimation._inProgress = recall(\"in\") || 0;\n          savedAnimation._outProgress = recall(\"out\") || 100;\n        }\n        vars.paused && pause();\n        selectedAnimation = null;\n        animation(declaredAnimation || savedAnimation || _recordedRoot);\n        let ts = vars.timeScale || recall(\"timeScale\"),\n          savedInOut = savedAnimation === selectedAnimation;\n        if (ts) {\n          _selectValue(timeScale, ts, timeScaleLabel, ts + \"x\");\n          linkedAnimation.timeScale(ts);\n        }\n        inProgress = (\"inTime\" in vars ? _timeToProgress(vars.inTime, selectedAnimation, 0, 0) : savedInOut ? savedAnimation._inProgress : 0) || 0;\n        if (inProgress === 100 && !vars.animation && savedAnimation) {\n          //in case there's a recorded animation (sessionStorage) and then the user defines an inTime that exceeds that animation's duration, just default back to the Global Timeline. Otherwise the in/out point will be at the very end and it'd be weird.\n          animation(_recordedRoot);\n          inProgress = _timeToProgress(vars.inTime, selectedAnimation, 0, 0) || 0;\n        }\n        if (inProgress) {\n          inPoint.style.left = inProgress + \"%\";\n          inPoint.style.display = outPoint.style.display = \"block\"; //set display:block so that it remains visible even when the minimal skin is enabled.\n        }\n        outProgress = (\"outTime\" in vars ? _timeToProgress(vars.outTime, selectedAnimation, 100, inProgress) : savedInOut ? savedAnimation._outProgress : 0) || 100;\n        if (outProgress < inProgress) {\n          outProgress = 100;\n        }\n        if (outProgress !== 100) {\n          outPoint.style.left = outProgress + \"%\";\n          inPoint.style.display = outPoint.style.display = \"block\"; //set display:block so that it remains visible even when the minimal skin is enabled.\n        }\n        loopEnabled = \"loop\" in vars ? vars.loop : recall(\"loop\");\n        loopEnabled && loop(true);\n        vars.paused && linkedAnimation.progress(inProgress / 100, true).pause();\n        if (_startupPhase && selectedAnimation === _recordedRoot && _globalStartTime && vars.globalSync && !paused) {\n          linkedAnimation.time(-_globalStartTime, true);\n        }\n        updateProgress(true);\n      };\n\n    //INITIALIZATION TASKS\n    _addListener(list, \"change\", onChangeAnimation);\n    _addListener(list, \"mousedown\", updateList);\n    _addListener(playPauseButton, \"mousedown\", togglePlayPause);\n    _addListener(find(\".seek-bar\"), \"mousedown\", onPressSeekBar);\n    _addListener(find(\".rewind\"), \"mousedown\", onPressRewind);\n    _addListener(loopButton, \"mousedown\", toggleLoop);\n    _addListener(timeScale, \"change\", onChangeTimeScale);\n    if (vars.visibility === \"auto\") {\n      _addListener(root, \"mouseout\", onMouseOut);\n      //_addListener(find(\".gs-hit-area\"), \"mouseover\", show);\n      _addListener(root, \"mouseover\", show);\n    } else if (vars.visibility === \"hidden\") {\n      hidden = true;\n      autoHideTween.progress(1);\n    }\n    if (vars.keyboard !== false) {\n      if (_keyboardInstance && vars.keyboard) {\n        console.warn(\"[GSDevTools warning] only one instance can be affected by keyboard shortcuts. There is already one active.\");\n      } else {\n        _keyboardInstance = _self; //we can't have multiple instances all affected by the keyboard.\n        keyboardHandler = e => {\n          //window.parent allows things to work inside of an iframe, like on codepen.\n          let key = e.keyCode ? e.keyCode : e.which,\n            ts;\n          if (key === 32) {\n            //spacebar\n            togglePlayPause();\n          } else if (key === 38) {\n            //up arrow\n            ts = parseFloat(_shiftSelectedValue(timeScale, -1, timeScaleLabel));\n            linkedAnimation.timeScale(ts);\n            record(\"timeScale\", ts);\n          } else if (key === 40) {\n            //down arrow\n            ts = parseFloat(_shiftSelectedValue(timeScale, 1, timeScaleLabel));\n            linkedAnimation.timeScale(ts);\n            record(\"timeScale\", ts);\n          } else if (key === 37) {\n            //left arrow\n            onPressRewind(e);\n          } else if (key === 39) {\n            //right arrow\n            linkedAnimation.progress(outProgress / 100);\n          } else if (key === 76) {\n            //\"L\" key\n            toggleLoop();\n          } else if (key === 72) {\n            //\"H\" key\n            toggleHide();\n          } else if (key === 73) {\n            //\"I\" key\n            inProgress = linkedAnimation.progress() * 100;\n            record(\"in\", inProgress);\n            inPoint.style.left = inProgress + \"%\";\n            updateProgress(true);\n          } else if (key === 79) {\n            //\"O\" key\n            outProgress = linkedAnimation.progress() * 100;\n            record(\"out\", outProgress);\n            outPoint.style.left = outProgress + \"%\";\n            updateProgress(true);\n          }\n        };\n        _addListener(_docEl, \"keydown\", keyboardHandler);\n      }\n    }\n    gsap.set(playhead, {\n      xPercent: -50,\n      x: 0,\n      data: \"root\"\n    }); //so that when we drag, x is properly discerned (browsers report in pure pixels rather than percents)\n    gsap.set(inPoint, {\n      xPercent: -100,\n      x: 0,\n      data: \"root\"\n    });\n    inPoint._gsIgnore = outPoint._gsIgnore = playhead._gsIgnore = playPauseButton._gsIgnore = loopButton._gsIgnore = true;\n\n    //Draggable fires off a TweenLite.set() that affects the transforms, and we don't want them to get into the _recordedRoot, so kill those tweens.\n    gsap.killTweensOf([inPoint, outPoint, playhead]);\n    initialize(_startupPhase);\n    if (_startupPhase) {\n      //developers may call GSDevTools.create() before they even create some of their animations, so the inTime/outTime or animation values may not exist, thus we wait for 1 tick and initialize again, just in case.\n      _delayedCall(0.0001, initialize, [false], this);\n    }\n    gsap.ticker.add(updateProgress);\n    this.update = forceMerge => {\n      if (_rootInstance === _self) {\n        if (!_rootTween.paused() || forceMerge) {\n          _merge();\n        }\n        updateRootDuration();\n      }\n    };\n    this.kill = this.revert = () => {\n      _removeListener(list, \"change\", onChangeAnimation);\n      _removeListener(list, \"mousedown\", updateList);\n      _removeListener(playPauseButton, \"mousedown\", togglePlayPause);\n      _removeListener(find(\".seek-bar\"), \"mousedown\", onPressSeekBar);\n      _removeListener(find(\".rewind\"), \"mousedown\", onPressRewind);\n      _removeListener(loopButton, \"mousedown\", toggleLoop);\n      _removeListener(timeScale, \"change\", onChangeTimeScale);\n      progressDrag.disable();\n      inDrag.disable();\n      outDrag.disable();\n      gsap.ticker.remove(updateProgress);\n      _removeListener(root, \"mouseout\", onMouseOut);\n      _removeListener(root, \"mouseover\", show);\n      root.parentNode.removeChild(root);\n      if (_rootInstance === _self) {\n        _rootInstance = null;\n      }\n      if (_keyboardInstance === _self) {\n        _keyboardInstance = null;\n        _removeListener(_docEl, \"keydown\", keyboardHandler);\n      }\n      delete _lookup[vars.id + \"\"];\n    };\n    this.minimal = function (value) {\n      let isMinimal = root.classList.contains(\"minimal\"),\n        p;\n      if (!arguments.length || isMinimal === value) {\n        return isMinimal;\n      }\n      if (value) {\n        root.classList.add(\"minimal\");\n      } else {\n        root.classList.remove(\"minimal\");\n      }\n      if (vars.container) {\n        root.style.top = value ? \"calc(100% - 42px)\" : \"calc(100% - 51px)\";\n      }\n      if (progressDrag.isPressed) {\n        skipDragUpdates = true; //just in case there's actually a tween/timeline in the linkedAnimation that is altering this GSDevTool instance's \"minimal()\" value, it could trigger a recursive loop in the drag handlers, like if they update linkedAnimation's time/progress which in turn triggers this minimal() function which in turn dues the same, and so on.\n        progressDrag.endDrag(progressDrag.pointerEvent);\n        skipDragUpdates = false;\n        p = linkedAnimation.progress() * 100;\n        progressBar.style.width = Math.max(0, p - inProgress) + \"%\";\n        playhead.style.left = p + \"%\";\n        playhead.style.transform = \"translate(-50%,0)\";\n        playhead._gsap.x = \"0px\";\n        playhead._gsap.xPercent = -50;\n        progressDrag.startDrag(progressDrag.pointerEvent, true);\n      }\n    };\n\n    //expose methods:\n    this.animation = animation;\n    this.updateList = updateList;\n    _context(this);\n  }; //if on startup, someone does a timeline.seek(), we need to honor it, so when initialize() is called, it'll check the _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n\nGSDevTools.version = \"3.13.0\";\nGSDevTools.globalRecordingTime = 2;\nGSDevTools.getById = id => id ? _lookup[id] : _rootInstance;\nGSDevTools.getByAnimation = animation => {\n  if (_isString(animation)) {\n    animation = gsap.getById(animation);\n  }\n  for (let p in _lookup) {\n    if (_lookup[p].animation() === animation) {\n      return _lookup[p];\n    }\n  }\n};\nGSDevTools.create = vars => new GSDevTools(vars);\nGSDevTools.register = _initCore;\n_getGSAP() && gsap.registerPlugin(GSDevTools);\nexport { GSDevTools, GSDevTools as default };","map":{"version":3,"names":["Draggable","gsap","_coreInitted","_doc","_docEl","_win","_recordedRoot","Animation","_rootTween","_rootInstance","_rootIsDirty","_keyboardInstance","_globalTimeline","_independentRoot","_delayedCall","_context","_recording","_startupPhase","_globalStartTime","_windowExists","window","_getGSAP","registerPlugin","_isString","value","_isFunction","_isObject","_isUndefined","_bonusValidated","_svgNS","_domNS","_idSeed","_lookup","_supportsStorage","sessionStorage","setItem","removeItem","e","_parseAnimation","animationOrId","getById","_createElement","type","container","cssText","element","createElementNS","createElement","querySelector","appendChild","setAttribute","style","_clearSelection","selection","empty","getSelection","removeAllRanges","_getChildrenOf","timeline","includeTimelines","a","cnt","Tween","core","tween","_first","vars","id","concat","length","_next","_getClippedDuration","animation","excludeRootRepeats","max","repeat","Math","_repeat","t","duration","totalDuration","endTime","_start","_tDur","_ts","_rDelay","_globalizeTime","rawTime","time","arguments","parent","_timeToProgress","defaultValue","relativeProgress","add","i","charAt","parseInt","parseFloat","substr","isNaN","labels","indexOf","min","_addedCSS","_createRootElement","minimal","css","innerHTML","root","getElementsByTagName","position","top","data","set","kill","bottom","width","xPercent","left","right","offsetWidth","_clickedOnce","_addListener","callback","capture","handler","altType","cursor","onpointerdown","ontouchstart","event","target","nodeName","toLowerCase","stopPropagation","preventDefault","call","addEventListener","_removeListener","removeEventListener","_selectValue","label","insertIfAbsent","options","option","selectedIndex","_shiftSelectedValue","amount","_merge","next","_dur","_targets","onComplete","_gsIgnore","_delay","_updateRootDuration","update","ticker","remove","_buildPlayPauseMorph","svg","tl","_time","to","attr","d","ease","rotation","transformOrigin","_buildLoopAnimation","paused","querySelectorAll","fill","_getAnimationById","_initCore","document","documentElement","context","globalTimeline","_sort","autoRemoveChildren","smoothChildTiming","_dp","immediateRender","killTweensOf","targets","props","onlyActive","render","_tTime","delay","params","scope","onReverseComplete","onCompleteParams","onReverseCompleteParams","callbackScope","offset","progress","GSDevTools","globalRecordingTime","_checkIndependence","globalSync","console","warn","getByAnimation","_self","find","s","record","key","persist","recall","getItem","playhead","timelineTrack","progressBar","timeLabel","durationLabel","pixelToTimeRatio","timeAtDragStart","dragged","skipDragUpdates","inPoint","outPoint","inProgress","outProgress","pausedWhenDragStarted","list","animationLabel","selectedAnimation","linkedAnimation","declaredAnimation","startTime","_fullyInitialized","keyboardHandler","playPauseButton","playPauseMorph","loopButton","loopAnimation","loopEnabled","timeScale","timeScaleLabel","onPressTimeline","originRatio","limitToInOut","trackBounds","getBoundingClientRect","elementBounds","x","getProperty","minX","maxX","unlimitedMinX","limitBounds","applyBounds","pause","activated","allowEventDefault","progressDrag","create","allowNativeTouchScrolling","onPress","onDrag","toFixed","onRelease","resume","resetInOut","updateProgress","inDrag","zIndexBoost","onDoubleClick","display","outDrag","play","force","isPressed","p","totalTime","repeatDelayPhase","isDragging","seek","totalProgress","transform","_gsap","togglePlayPause","onPressSeekBar","bounds","changedTouches","clientX","startDrag","reversed","reverse","onPressRewind","loop","toggleLoop","updateList","animations","children","matches","unshift","hideGlobalTimeline","removeChild","anim","ts","maxDuration","scrollTrigger","_inProgress","_outProgress","invalidate","_pauseTS","updateRootDuration","ratio","onChangeAnimation","blur","onChangeTimeScale","autoHideTween","autoAlpha","y","hidden","onMouseOut","hitTest","autoHideDelayedCall","restart","hide","show","toggleHide","initialize","preliminary","savedAnimation","savedInOut","inTime","outTime","visibility","keyboard","keyCode","which","forceMerge","revert","disable","parentNode","isMinimal","classList","contains","endDrag","pointerEvent","version","register","default"],"sources":["/Users/linhankuan/Documents/GitHub/fvl2025_project/node_modules/gsap/src/GSDevTools.js"],"sourcesContent":["/*!\n * GSDevTools 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { Draggable } from \"./Draggable.js\";\n\nlet gsap, _coreInitted, _doc, _docEl, _win, _recordedRoot, Animation, _rootTween, _rootInstance, _rootIsDirty, _keyboardInstance, _globalTimeline, _independentRoot, _delayedCall, _context,\n\t_recording = true,\n\t_startupPhase = true, //for the first 2 seconds, we don't record any zero-duration tweens because they're typically just setup stuff and/or the \"from\" or \"startAt\" tweens. In version 1.20.3 we started flagging those with data:\"isStart\"|\"isFromStart\" but this logic helps GSDevTools work with older versions too.\n\t_globalStartTime = 0,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_isString = value => typeof(value) === \"string\",\n\t_isFunction = value => typeof(value) === \"function\",\n\t_isObject = value => typeof(value) === \"object\",\n\t_isUndefined = value => typeof(value) === \"undefined\",\n\t_bonusValidated = 1, //<name>GSDevTools</name>\n\t_svgNS = \"http://www.w3.org/2000/svg\",\n\t_domNS = \"http://www.w3.org/1999/xhtml\",\n\t_idSeed = 0, //we assign an ID to each GSDevTools instance so that we can segregate the sessionStorage data accordingly.\n\t_lookup = {},\n\t_supportsStorage = (function() {\n\t\ttry {\n\t\t\tsessionStorage.setItem(\"gsTest\", \"1\");\n\t\t\tsessionStorage.removeItem(\"gsTest\");\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}()),\n\t_parseAnimation = animationOrId => (animationOrId instanceof Animation) ? animationOrId : animationOrId ? gsap.getById(animationOrId) : null,\n\t_createElement = (type, container, cssText) => {\n\t\tlet element = _doc.createElementNS ? _doc.createElementNS(type === \"svg\" ? _svgNS : _domNS, type) : _doc.createElement(type);\n\t\tif (container) {\n\t\t\tif (_isString(container)) {\n\t\t\t\tcontainer = _doc.querySelector(container);\n\t\t\t}\n\t\t\tcontainer.appendChild(element);\n\t\t}\n\t\tif (type === \"svg\") {\n\t\t\telement.setAttribute(\"xmlns\", _svgNS);\n\t\t\telement.setAttribute(\"xmlns:xlink\", _domNS);\n\t\t}\n\t\tcssText && (element.style.cssText = cssText);\n\t\treturn element;\n\t},\n\t_clearSelection = () => {\n\t\tif (_doc.selection) {\n\t\t\t_doc.selection.empty()\n\t\t} else if (_win.getSelection) {\n\t\t\t_win.getSelection().removeAllRanges();\n\t\t}\n\t},\n\t_getChildrenOf = (timeline, includeTimelines) => {\n\t\tlet a = [],\n\t\t\tcnt = 0,\n\t\t\tTween = gsap.core.Tween,\n\t\t\ttween = timeline._first;\n\t\twhile (tween) {\n\t\t\tif (tween instanceof Tween) {\n\t\t\t\tif (tween.vars.id) {\n\t\t\t\t\ta[cnt++] = tween;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (includeTimelines && tween.vars.id) {\n\t\t\t\t\ta[cnt++] = tween;\n\t\t\t\t}\n\t\t\t\ta = a.concat(_getChildrenOf(tween, includeTimelines));\n\t\t\t\tcnt = a.length;\n\t\t\t}\n\t\t\ttween = tween._next;\n\t\t}\n\t\treturn a;\n\t},\n\t_getClippedDuration = (animation, excludeRootRepeats) => {\n\t\tlet max = 0,\n\t\t\trepeat = Math.max(0, animation._repeat),\n\t\t\tt = animation._first;\n\t\tif (!t) {\n\t\t\tmax = animation.duration();\n\t\t}\n\t\twhile (t) {\n\t\t\tmax = Math.max(max, t.totalDuration() > 999 ? t.endTime(false) : t._start + t._tDur / t._ts);\n\t\t\tt = t._next;\n\t\t}\n\t\treturn (!excludeRootRepeats && repeat) ? max * (repeat + 1) + (animation._rDelay * repeat) : max;\n\t},\n\t_globalizeTime = function(animation, rawTime) {\n\t\tlet a = animation,\n\t\t\ttime = arguments.length > 1 ? +rawTime : a.rawTime();\n\t\twhile (a) {\n\t\t\ttime = a._start + time / (a._ts || 1);\n\t\t\ta = a.parent;\n\t\t}\n\t\treturn time;\n\t},\n\t_timeToProgress = (time, animation, defaultValue, relativeProgress) => {\n\t\tlet add, i, a;\n\t\tif (_isString(time)) {\n\t\t\tif (time.charAt(1) === \"=\") {\n\t\t\t\tadd = parseInt(time.charAt(0) + \"1\", 10) * parseFloat(time.substr(2));\n\t\t\t\tif (add < 0 && relativeProgress === 0) { //if something like inTime:\"-=2\", we measure it from the END, not the beginning\n\t\t\t\t\trelativeProgress = 100;\n\t\t\t\t}\n\t\t\t\ttime = (relativeProgress / 100 * animation.duration()) + add;\n\t\t\t} else if (isNaN(time) && animation.labels && animation.labels[time] !== -1) {\n\t\t\t\ttime = animation.labels[time];\n\t\t\t} else if (animation === _recordedRoot) { //perhaps they defined an id of an animation, like \"myAnimation+=2\"\n\t\t\t\ti = time.indexOf(\"=\");\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tadd = parseInt(time.charAt(i-1) + \"1\", 10) * parseFloat(time.substr(i+1));\n\t\t\t\t\ttime = time.substr(0, i-1);\n\t\t\t\t} else {\n\t\t\t\t\tadd = 0;\n\t\t\t\t}\n\t\t\t\ta = gsap.getById(time);\n\t\t\t\tif (a) {\n\t\t\t\t\ttime = _globalizeTime(a, defaultValue / 100 * a.duration()) + add;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttime = isNaN(time) ? defaultValue : parseFloat(time);\n\t\treturn Math.min(100, Math.max(0, time / animation.duration() * 100));\n\t},\n\t_addedCSS,\n\t_createRootElement = (element, minimal, css) => {\n\t\tif (!_addedCSS) {\n\t\t\t_createElement(\"style\", _docEl).innerHTML = '.gs-dev-tools{height:51px;bottom:0;left:0;right:0;display:block;position:fixed;overflow:visible;padding:0;font-size:15px;font-family:-apple-system,BlinkMacSystemFont,avenir next,sans-serif;color:#bbbaa6}.gs-dev-tools *{box-sizing:content-box;visibility:visible}.gs-dev-tools .gs-top{position:relative;z-index:499}.gs-dev-tools .gs-bottom{display:flex;align-items:center;justify-content:space-between;gap:1rem;background-color:#0e100f;height:42px;position:relative}.gs-dev-tools .timeline{position:relative;height:8px;margin-left:15px;margin-right:15px;overflow:visible}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{height:8px;position:absolute;top:0;left:-15px;right:-15px}.gs-dev-tools .timeline-track{background-color:#222}.gs-dev-tools .progress-bar{background:linear-gradient(114.41deg,#0ae448 20.74%,#abff84 65.5%);height:8px;top:0;width:0;pointer-events:none}.gs-dev-tools .seek-bar{width:100%;position:absolute;height:24px;top:-12px;left:0;background-color:transparent}.gs-dev-tools .in-point,.gs-dev-tools .out-point{width:15px;height:26px;position:absolute;top:-18px}.gs-dev-tools .in-point-shape{fill:#0ae448;transform:translateX(1px)}.gs-dev-tools .out-point-shape{fill:#ff8709}.gs-dev-tools .in-point{transform:translateX(-100%)}.gs-dev-tools .out-point{left:100%}.gs-dev-tools .playhead{position:absolute;top:-5px;transform:translate(-50%,0);left:0;border-radius:50%;width:16px;height:16px;background:linear-gradient(114.41deg,#0ae448 20.74%,#abff84 65.5%)}.gs-dev-tools .gs-btn-white{fill:#fffce1}.gs-dev-tools .pause{opacity:0}.gs-dev-tools .select-animation{vertical-align:middle;position:relative;padding:6px 10px}.gs-dev-tools .select-animation-container{flex-grow:4;width:40%}.gs-dev-tools .select-arrow{display:inline-block;width:12px;height:7px;margin:0 7px;transform:translate(0,-2px)}.gs-dev-tools .select-arrow-shape{stroke:currentcolor;stroke-width:2px;fill:none}.gs-dev-tools .rewind{height:14px}.gs-dev-tools .ease-border,.gs-dev-tools .rewind-path{fill:currentColor}.gs-dev-tools .play-pause{width:18px;height:18px}.gs-dev-tools .ease{width:20px;height:20px;min-width:30px;display:none}.gs-dev-tools .ease-path{fill:none;stroke:#abff84;stroke-width:2px}.gs-dev-tools .time-scale{text-align:center;min-width:30px}.gs-dev-tools .loop{width:15px}.gs-dev-tools label span{text-decoration:none}.gs-dev-tools button:focus,.gs-dev-tools select:focus{outline:0}.gs-dev-tools label{position:relative;cursor:pointer}.gs-dev-tools label.locked{text-decoration:none;cursor:auto}.gs-dev-tools label input,.gs-dev-tools label select{position:absolute;left:0;top:0;z-index:1;font:inherit;font-size:inherit;line-height:inherit;height:100%;width:100%;color:#000!important;opacity:0;background:0 0;border:none;padding:0;margin:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer}.gs-dev-tools label input+.display{position:relative;z-index:2}.gs-dev-tools .gs-bottom-right{vertical-align:middle;display:flex;align-items:center;flex-grow:4;width:40%;justify-content:flex-end}.gs-dev-tools .time-container{margin:0 5px}.gs-dev-tools .logo{width:32px;height:32px;position:relative;top:2px;margin:0 12px}.gs-dev-tools .gs-hit-area{background-color:transparent;width:100%;height:100%;top:0;position:absolute}.gs-dev-tools.minimal{height:auto;display:flex;align-items:stretch}.gs-dev-tools.minimal .gs-top{order:2;flex-grow:4;background-color:#000}.gs-dev-tools.minimal .gs-bottom{background-color:#0e100f;border-top:none}.gs-dev-tools.minimal .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools.minimal .gs-bottom-right,.gs-dev-tools.minimal .in-point,.gs-dev-tools.minimal .out-point,.gs-dev-tools.minimal .rewind,.gs-dev-tools.minimal .select-animation-container{display:none}.gs-dev-tools.minimal .play-pause{width:20px;height:20px;padding:4px 6px;margin-left:14px}.gs-dev-tools.minimal .time-scale{min-width:26px}.gs-dev-tools.minimal .loop{width:18px;min-width:18px;display:none}@media only screen and (max-width:600px){.gs-dev-tools{height:auto;display:flex;align-items:stretch}.gs-dev-tools .gs-top{order:2;flex-grow:4;background-color:#000;height:42px}.gs-dev-tools .gs-bottom{background-color:#000;border-top:none}.gs-dev-tools .timeline{top:50%;transform:translate(0,-50%)}.gs-dev-tools .gs-bottom-right,.gs-dev-tools .in-point,.gs-dev-tools .out-point,.gs-dev-tools .rewind,.gs-dev-tools .select-animation-container{display:none}.gs-dev-tools .play-pause{width:18px;height:18px;padding:4px 6px;margin-left:14px}.gs-dev-tools .time-scale{min-width:26px}.gs-dev-tools .loop{width:18px;min-width:18px;display:none}.gs-dev-tools .progress-bar,.gs-dev-tools .timeline-track{right:0}}';\n\t\t\t_addedCSS = true;\n\t\t}\n\t\tif (_isString(element)) {\n\t\t\telement = _doc.querySelector(element);\n\t\t}\n\t\tlet root = _createElement(\"div\", element || _docEl.getElementsByTagName(\"body\")[0] || _docEl);\n\t\troot.setAttribute(\"class\", \"gs-dev-tools\" + (minimal ? \" minimal\" : \"\"));\n\t\troot.innerHTML = '<div class=gs-hit-area></div><div class=gs-top><div class=timeline><div class=timeline-track></div><div class=progress-bar></div><div class=seek-bar></div><svg class=in-point viewBox=\"0 0 15 26\" xmlns=http://www.w3.org/2000/svg><path class=in-point-shape d=\"M0.5,2.283c0,-0.985 0.798,-1.783 1.783,-1.783c2.679,0 7.717,0 10.41,0c0.48,-0 0.939,0.19 1.278,0.529c0.339,0.339 0.529,0.798 0.529,1.277c-0,4.821 -0,17.897 0,21.968c0,0.253 -0.135,0.488 -0.354,0.615c-0.22,0.128 -0.49,0.128 -0.711,0.003c-2.653,-1.517 -9.526,-5.444 -12.016,-6.867c-0.568,-0.325 -0.919,-0.929 -0.919,-1.583c-0,-2.835 -0,-10.627 -0,-14.159Z\" style=\"fill:#00ff52;fill-rule:nonzero;\"/></svg><svg class=out-point viewBox=\"0 0 15 26\" xmlns=http://www.w3.org/2000/svg><path class=out-point-shape d=\"M0.5,2.251c0,-0.465 0.184,-0.91 0.513,-1.238c0.328,-0.329 0.773,-0.513 1.238,-0.513c2.669,0 7.733,0 10.439,0c0.48,-0 0.94,0.191 1.28,0.53c0.339,0.34 0.53,0.8 0.53,1.28l0,14.17c-0,0.631 -0.338,1.213 -0.886,1.526c-2.44,1.395 -9.262,5.293 -11.977,6.845c-0.236,0.134 -0.524,0.133 -0.759,-0.003c-0.234,-0.136 -0.378,-0.386 -0.378,-0.657c0,-4.178 0,-17.198 0,-21.94Z\" style=\"fill-rule:nonzero;\"/></svg><div class=playhead></div></div></div><div class=gs-bottom><div class=select-animation-container><label class=select-animation><select class=animation-list><option>Global Timeline<option>myTimeline</select><nobr><span class=\"display animation-label\">Global Timeline</span><svg class=select-arrow viewBox=\"0 0 12.05 6.73\" xmlns=http://www.w3.org/2000/svg><polyline class=select-arrow-shape points=\"0.35 0.35 6.03 6.03 11.7 0.35\"/></svg></nobr></label></div><svg class=rewind viewBox=\"0 0 12 15.38\" xmlns=http://www.w3.org/2000/svg><path d=M0,.38H2v15H0Zm2,7,10,7.36V0Z class=\"gs-btn-white rewind-path\"/></svg><svg class=play-pause viewBox=\"0 0 20.97 25.67\" xmlns=http://www.w3.org/2000/svg><g class=play><path d=\"M8,4.88 C8,10.18 8,15.48 8,20.79 5.33,22.41 2.66,24.04 0,25.67 0,17.11 0,8.55 0,0 2.66,1.62 5.33,3.25 8,4.88\" class=\"gs-btn-white play-1\" style=stroke:#fffce1;stroke-width:.6px /><path d=\"M14.485,8.855 C16.64,10.18 18.8,11.5 20.97,12.83 16.64,15.48 12.32,18.13 8,20.79 8,15.48 8,10.18 8,4.88 10.16,6.2 12.32,7.53 14.48,8.85\" class=\"gs-btn-white play-2\" style=stroke:#fffce1;stroke-width:.6px /></g></svg> <svg class=loop viewBox=\"0 0 29 25.38\" xmlns=http://www.w3.org/2000/svg fill=\"currentcolor\"><path d=M27.44,5.44,20.19,0V3.06H9.06A9.31,9.31,0,0,0,0,12.41,9.74,9.74,0,0,0,.69,16l3.06-2.23a6,6,0,0,1-.12-1.22,5.49,5.49,0,0,1,5.43-5.5H20.19v3.81Z class=loop-path /><path d=M25.25,11.54a5.18,5.18,0,0,1,.12,1.12,5.41,5.41,0,0,1-5.43,5.41H9.19V14.5L1.94,19.94l7.25,5.44V22.06H19.94A9.2,9.2,0,0,0,29,12.84a9.42,9.42,0,0,0-.68-3.53Z class=loop-path /></svg> <svg class=ease viewBox=\"0 0 25.67 25.67\" xmlns=http://www.w3.org/2000/svg><path d=M.48,25.12c1.74-3.57,4.28-12.6,8.8-10.7s4.75,1.43,6.5-1.11S19.89,1.19,25.2.55 class=ease-path /><path d=M24.67,1V24.67H1V1H24.67m1-1H0V25.67H25.67V0Z class=ease-border /></svg><label class=time-scale><select><option value=10>10x<option value=5>5x<option value=2>2x<option value=1 selected>1x<option value=0.5>0.5x<option value=0.25>0.25x<option value=0.1>0.1x</select><span class=\"display time-scale-label\">1x</span></label><div class=gs-bottom-right><div class=time-container><span class=time>0.00</span> / <span class=duration>0.00</span></div><a href=\"https://gsap.com/docs/v3/Plugins/GSDevTools?source=GSDevTools\" target=_blank title=Docs><svg class=\"logo\" viewBox=\"0 0 1080 1080\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M793 518.654C793 518.654 793 518.829 793 518.934L770.197 618.386C768.967 624.012 763.38 628.135 756.915 628.135H729.404C727.366 628.135 725.539 629.498 724.977 631.455C699.573 718.082 665.175 777.628 619.745 813.376C581.095 843.813 533.451 858 469.819 858C412.618 858 374.074 839.514 341.362 803.032C298.145 754.809 280.261 675.869 291.083 580.75C310.618 402.184 402.745 222.01 580.217 222.01C634.185 221.521 676.559 238.26 706.039 271.667C737.204 306.995 753.05 360.216 753.121 429.86C753.015 436.185 747.78 441.287 741.491 441.287H611.488C606.885 441.287 602.774 437.129 602.844 432.551C601.79 384.397 587.56 360.915 559.311 360.915C509.488 360.915 480.079 428.917 464.479 466.622C442.694 519.283 431.627 576.452 433.805 633.412C434.824 659.935 439.075 697.22 464.127 712.666C486.333 726.364 518.026 717.279 537.21 702.113C556.394 686.947 571.819 660.703 578.319 636.766C579.233 633.447 579.303 630.861 578.425 629.708C577.511 628.52 574.981 628.24 573.049 628.24H539.67C536.086 628.24 532.537 626.598 530.394 623.942C528.602 621.705 527.899 618.945 528.532 616.219L551.37 516.592C552.494 511.49 557.097 507.647 562.754 506.948V506.703H781.827C782.354 506.703 782.881 506.703 783.373 506.808C789.065 507.542 793.07 512.853 792.965 518.654H793Z\" fill=\"#0AE448\"/></svg></a></div></div>';\n\t\tif (element) {\n\t\t\troot.style.position = \"absolute\";\n\t\t\troot.style.top = minimal ? \"calc(100% - 42px)\" : \"calc(100% - 51px)\";\n\t\t}\n\t\tif (css) {\n\t\t\tif (_isString(css)) {\n\t\t\t\troot.style.cssText = css;\n\t\t\t} else if (_isObject(css)) {\n\t\t\t\tcss.data = \"root\";\n\t\t\t\tgsap.set(root, css).kill();\n\t\t\t}\n\t\t\tif (root.style.top) {\n\t\t\t\troot.style.bottom = \"auto\";\n\t\t\t}\n\t\t\tif (root.style.width) {\n\t\t\t\tgsap.set(root, {xPercent: -50, left: \"50%\", right: \"auto\", data:\"root\"}).kill();\n\t\t\t}\n\t\t}\n\t\tif (!minimal && root.offsetWidth < 600) {\n\t\t\troot.setAttribute(\"class\", \"gs-dev-tools minimal\");\n\t\t\tif (element) {\n\t\t\t\troot.style.top = \"calc(100% - 42px)\";\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t},\n\t_clickedOnce = true, //perhaps we shouldn't preventDefault() on the first mousedown/touchstart/pointerdown so that iframes get focus properly. Did that previously, but now it seems to prevent interaction on the first click (annoying).\n\t_addListener = (e, type, callback, capture) => {\n\t\tlet handler, altType;\n\t\tif (type === \"mousedown\" || type === \"mouseup\") {\n\t\t\te.style.cursor = \"pointer\";\n\t\t}\n\t\tif (type === \"mousedown\") {\n\t\t\t//some browsers call BOTH mousedown AND touchstart, for example, on a single interaction so we need to skip one of them if both are called within 100ms.\n\t\t\taltType = !_isUndefined(e.onpointerdown) ? \"pointerdown\" : !_isUndefined(e.ontouchstart) ? \"touchstart\" : null;\n\t\t\tif (altType) {\n\t\t\t\thandler = event => {\n\t\t\t\t\tif (event.target.nodeName.toLowerCase() !== \"select\" && event.type === altType) { //don't preventDefault() on a <select> or else it won't open!\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\tif (_clickedOnce) { //otherwise, both touchstart and mousedown will get called.\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tcallback.call(e, event);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (event.type !== altType) {\n\t\t\t\t\t\tcallback.call(e, event);\n\t\t\t\t\t}\n\t\t\t\t\t_clickedOnce = true;\n\t\t\t\t};\n\t\t\t\te.addEventListener(altType, handler, capture);\n\t\t\t\tif (altType !== \"pointerdown\") {\n\t\t\t\t\te.addEventListener(type, handler, capture);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\te.addEventListener(type, callback, capture);\n\t},\n\t_removeListener = (e, type, callback) => {\n\t\te.removeEventListener(type, callback);\n\t\ttype = type !== \"mousedown\" ? null : !_isUndefined(e.onpointerdown) ? \"pointerdown\" : !_isUndefined(e.ontouchstart) ? \"touchstart\" : null;\n\t\tif (type) {\n\t\t\te.removeEventListener(type, callback);\n\t\t}\n\t},\n\t_selectValue = (element, value, label, insertIfAbsent) => {\n\t\tlet options = element.options,\n\t\t\ti = options.length,\n\t\t\toption;\n\t\tvalue += \"\";\n\t\twhile (--i > -1) {\n\t\t\tif (options[i].innerHTML === value || options[i].value === value) {\n\t\t\t\telement.selectedIndex = i;\n\t\t\t\tlabel.innerHTML = options[i].innerHTML;\n\t\t\t\treturn options[i];\n\t\t\t}\n\t\t}\n\t\tif (insertIfAbsent) {\n\t\t\toption = _createElement(\"option\", element);\n\t\t\toption.setAttribute(\"value\", value);\n\t\t\toption.innerHTML = label.innerHTML = _isString(insertIfAbsent) ? insertIfAbsent : value;\n\t\t\telement.selectedIndex = options.length - 1;\n\t\t}\n\t},\n\t//increments the selected value of a <select> up or down by a certain amount.\n\t_shiftSelectedValue = (element, amount, label) => {\n\t\tlet options = element.options,\n\t\t\ti = Math.min(options.length - 1, Math.max(0, element.selectedIndex + amount));\n\t\telement.selectedIndex = i;\n\t\tif (label) {\n\t\t\tlabel.innerHTML = options[i].innerHTML;\n\t\t}\n\t\treturn options[i].value;\n\t},\n\t//moves everything from _globalTimeline into _recordedRoot and updates the _rootTween if it is currently controlling the Global timeline (_recordedRoot). _recordedTemp is just a temporary recording area for anything that happens while _recordedRoot is paused. Returns true if the _recordedRoot's duration changed due to the merge.\n\t_merge = () => {\n\t\tlet t = _globalTimeline._first,\n\t\t\tduration, next, target;\n\t\tif (_rootInstance) {\n\t\t\tduration = _recordedRoot._dur;\n\t\t\twhile (t) {\n\t\t\t\tnext = t._next;\n\t\t\t\ttarget = t._targets && t._targets[0];\n\t\t\t\tif (!(_isFunction(target) && target === t.vars.onComplete && !t._dur) && !(target && target._gsIgnore)) { //typically, delayedCalls aren't included in the _recordedTemp, but since the hijacked add() below fires BEFORE TweenLite's constructor sets the target, we couldn't check that target === vars.onComplete there. And Draggable creates a tween with just an onComplete (no onReverseComplete), thus it fails that test. Therefore, we test again here to avoid merging that in.\n\t\t\t\t\t_recordedRoot.add(t, t._start - t._delay);\n\t\t\t\t}\n\t\t\t\tt = next;\n\t\t\t}\n\t\t\treturn (duration !== _recordedRoot.duration());\n\t\t}\n\t},\n\t_updateRootDuration = () => {\n\t\tif (_rootInstance) {\n\t\t\t_rootInstance.update();\n\t\t\t_rootIsDirty = false;\n\t\t}\n\t\tgsap.ticker.remove(_updateRootDuration);\n\t},\n\n\t_buildPlayPauseMorph = svg => {\n\t\tlet tl = gsap.timeline({data:\"root\", parent:_independentRoot, onComplete:() => tl.kill() }, _independentRoot._time);\n\t\ttl.to(svg.querySelector(\".play-1\"), {duration:0.4, attr:{d:\"M5.75,3.13 C5.75,9.79 5.75,16.46 5.75,23.13 4.08,23.13 2.41,23.13 0.75,23.13 0.75,16.46 0.75,9.79 0.75,3.12 2.41,3.12 4.08,3.12 5.75,3.12\"}, ease:\"power2.inOut\", rotation:360, transformOrigin:\"50% 50%\"})\n\t\t  .to(svg.querySelector(\".play-2\"), {duration:0.4, attr:{d:\"M16.38,3.13 C16.38,9.79 16.38,16.46 16.38,23.13 14.71,23.13 13.04,23.13 11.38,23.13 11.38,16.46 11.38,9.79 11.38,3.12 13.04,3.12 14.71,3.12 16.38,3.12\"}, ease:\"power2.inOut\", rotation:360, transformOrigin:\"50% 50%\"}, 0.05);\n\t\treturn tl;\n\t},\n\n\t_buildLoopAnimation = svg => {\n\t\tlet tl = gsap.timeline({data:\"root\", id:\"loop\", parent:_independentRoot, paused:true, onComplete:() => tl.kill() }, _independentRoot._time);\n\t\ttl.to(svg, {duration: 0.5, rotation:360, ease:\"power3.inOut\", transformOrigin:\"50% 50%\"})\n\t\t  .to(svg.querySelectorAll(\".loop-path\"), {duration:0.5, fill:\"#91e600\", ease:\"none\"}, 0);\n\t\treturn tl;\n\t},\n\n\t_getAnimationById = id => gsap.getById(id) || _independentRoot.getById(id) || (id === _recordedRoot.vars.id && _recordedRoot),\n\n\n\n\t_initCore = core => {\n\t\tgsap = core || _getGSAP();\n\t\tif (!_coreInitted) {\n\t\t\tif (gsap && _windowExists()) {\n\t\t\t\t_doc = document;\n\t\t\t\t_docEl = _doc.documentElement;\n\t\t\t\t_win = window;\n\t\t\t\t_context = gsap.core.context || function() {};\n\t\t\t\tgsap.registerPlugin(Draggable);\n\t\t\t\t_globalTimeline = gsap.globalTimeline;\n\t\t\t\t_globalTimeline._sort = true;\n\t\t\t\t_globalTimeline.autoRemoveChildren = false;\n\t\t\t\tAnimation = gsap.core.Animation;\n\t\t\t\t_independentRoot = gsap.timeline({data:\"indy\", autoRemoveChildren:true, smoothChildTiming:true});\n\t\t\t\t_independentRoot.kill();\n\t\t\t\t_independentRoot._dp = 0; //don't let it revert to the global timeline as its parent.\n\t\t\t\t_independentRoot.to({}, {duration:1e12});\n\t\t\t\t_recordedRoot = gsap.timeline({data:\"root\", id:\"Global Timeline\", autoRemoveChildren:false, smoothChildTiming:true, parent:_independentRoot}, 0);\n\t\t\t\t_rootTween = gsap.to(_recordedRoot, {duration:1, time:1, ease:\"none\", data:\"root\", id:\"_rootTween\", paused:true, immediateRender:false, parent:_independentRoot}, 0);\n\t\t\t\t// so that auto-overwriting works. Initially we transferred the tweens to the _recordedRoot.\n\t\t\t\t_globalTimeline.killTweensOf = function(targets, props, onlyActive) {\n\t\t\t\t\t_recordedRoot.killTweensOf(targets, props, onlyActive);\n\t\t\t\t\t_recordedRoot.killTweensOf.call(_globalTimeline, targets, props, onlyActive);\n\t\t\t\t}\n\t\t\t\t_independentRoot._start = gsap.ticker.time;\n\t\t\t\tgsap.ticker.add(time => _independentRoot.render(time - _independentRoot._start));\n\t\t\t\t// before 3.7.0, the listener below was necessary (in place of the line above)\n\t\t\t\t// gsap.ticker.add(time => {\n\t\t\t\t// \t_independentRoot._initted || _independentRoot.render(0.001, true); // to prevent callbacks from being fired on the first tick, like onComplete would fire immediately and then again at the correct time.\n\t\t\t\t// \t_independentRoot.render(time - _independentRoot._start);\n\t\t\t\t// });\n\n\t\t\t\t//align the all of the playheads so they're starting at 0 now.\n\t\t\t\t_globalTimeline._start += _globalTimeline._time;\n\t\t\t\t_recordedRoot._start = _globalTimeline._time = _globalTimeline._tTime = 0;\n\t\t\t\t_delayedCall = (delay, callback, params, scope) => gsap.to(callback, {delay:delay, duration:0, onComplete:callback, onReverseComplete:callback, onCompleteParams:params, onReverseCompleteParams:params, callbackScope:scope, parent:_independentRoot}, _independentRoot._time);\n\n\t\t\t\t//in case GSDevTools.create() is called before anything is actually on the global timeline, we've gotta update it or else the duration will be 0 and it'll be stuck.\n\t\t\t\t_delayedCall(0.01, () => _rootInstance ? _rootInstance.update() : _merge());\n\n\t\t\t\t//initially we record everything into the _recordedRoot Timeline because developers might call GSDevTools.create() AFTER some of their code executes, but after 2 seconds if there aren't any GSDevTool instances that have globalSync enabled, we should dump all the stuff from _recordedRoot into the global timeline to improve performance and avoid issues where _recordedRoot is paused and reaches its end and wants to stop the playhead.\n\t\t\t\t_delayedCall(2, () => {\n\t\t\t\t\tlet t, next, offset;\n\t\t\t\t\tif (!_rootInstance) {\n\t\t\t\t\t\t_merge();\n\t\t\t\t\t\tt = _recordedRoot._first;\n\t\t\t\t\t\toffset = _recordedRoot._start;\n\t\t\t\t\t\twhile (t) {\n\t\t\t\t\t\t\tnext = t._next;\n\t\t\t\t\t\t\t//any animations that aren't finished should be dumped into the root timeline. If they're done, just kill them.\n\t\t\t\t\t\t\tif (t._tDur !== t._tTime || (!t._dur && t.progress() !== 1)) {\n\t\t\t\t\t\t\t\t_globalTimeline.add(t, t._start - t._delay + offset);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tt.kill();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tt = next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (GSDevTools.globalRecordingTime > 2) {\n\t\t\t\t\t\t_delayedCall(GSDevTools.globalRecordingTime - 2, () => {\n\t\t\t\t\t\t\t_rootInstance && _rootInstance.update();\n\t\t\t\t\t\t\t_recording = false;\n\t\t\t\t\t\t\t_globalTimeline.autoRemoveChildren = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_recording = false;\n\t\t\t\t\t\t_globalTimeline.autoRemoveChildren = true;\n\t\t\t\t\t}\n\t\t\t\t\t_startupPhase = false;\n\t\t\t\t});\n\t\t\t\t_coreInitted = 1;\n\t\t\t}\n\t\t}\n\t},\n\t_checkIndependence = (animation, vars) => {\n\t\tif (!vars.globalSync && animation.parent !== _globalTimeline) { //in case it's nested in a timeline (playing it won't help if the parent timeline isn't playing).\n\t\t\t_globalTimeline.add(animation, _globalTimeline.time());\n\t\t}\n\t},\n\n\n\n\n\n\n\n\tGSDevTools = function(vars) {\n\t\tif (!_coreInitted) {\n\t\t\t_initCore();\n\t\t\tgsap || console.warn(\"Please gsap.registerPlugin(GSDevTools)\");\n\t\t}\n\n\t\tthis.vars = vars = vars || {};\n\t\tif (vars.animation) {\n\t\t\t(GSDevTools.getByAnimation(vars.animation) || {kill:() => 0}).kill();\n\t\t}\n\t\tvars.id = vars.id || (_isString(vars.animation) ? vars.animation : _idSeed++); //try to find a unique ID so that sessionStorage can be mapped to it (otherwise, for example, all the embedded codepens on a page would share the same settings). So if no id is defined, see if there's a string-based \"animation\" defined. Last of all, we default to a numeric counter that we increment.\n\t\t_lookup[vars.id + \"\"] = this;\n\n\t\t(\"globalSync\" in vars) || (vars.globalSync = !vars.animation); //if the user calls create() and passes in an animation AFTER the initial recording time has elapsed, there's a good chance the animation won't be in the recordedRoot, so we change the default globalSync to false because that's the most intuitive behavior.\n\n\t\t//GENERAL/UTILITY\n\t\tlet _self = this,\n\t\t\troot = _createRootElement(vars.container, vars.minimal, vars.css),\n\t\t\tfind = s => root.querySelector(s),\n\t\t\trecord = (key, value) => {\n\t\t\t\tif (vars.persist !== false && _supportsStorage) {\n\t\t\t\t\tsessionStorage.setItem(\"gs-dev-\" + key + vars.id, value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\trecall = key => {\n\t\t\t\tlet value;\n\t\t\t\tif (vars.persist !== false && _supportsStorage) {\n\t\t\t\t\tvalue = sessionStorage.getItem(\"gs-dev-\" + key + vars.id);\n\t\t\t\t\treturn (key === \"animation\") ? value : (key === \"loop\") ? (value === \"true\") : parseFloat(value); // handle data typing too.\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\t//SCRUBBER/PROGRESS\n\t\t\tplayhead = find(\".playhead\"),\n\t\t\ttimelineTrack = find(\".timeline-track\"),\n\t\t\tprogressBar = find(\".progress-bar\"),\n\t\t\ttimeLabel = find(\".time\"),\n\t\t\tdurationLabel = find(\".duration\"),\n\t\t\tpixelToTimeRatio, timeAtDragStart, dragged, skipDragUpdates,\n\t\t\tprogress = 0,\n\t\t\tinPoint = find(\".in-point\"),\n\t\t\toutPoint = find(\".out-point\"),\n\t\t\tinProgress = 0,\n\t\t\toutProgress = 100,\n\t\t\tpausedWhenDragStarted,\n\t\t\tlist = find(\".animation-list\"),\n\t\t\tanimationLabel = find(\".animation-label\"),\n\t\t\tselectedAnimation, //the currently selected animation\n\t\t\tlinkedAnimation, //the animation that's linked to all the controls and scrubber. This is always _rootTween if globalSync is true, so it can be different than the selectedAnimation!\n\t\t\tdeclaredAnimation, //whatever the user defines in the config object initially (often this will be null). If the user defines a string, it'll be resolved to a real Animation instance for this variable.\n\t\t\tstartTime, endTime,\n\t\t\t_fullyInitialized, //we call initialize() initially, and then again on the very next tick just in case someone called GSDevTools.create() BEFORE they create their animations. This variable tracks that state. Note: we don't record sessionStorage.setItem() until we're fully initialized, otherwise we may inadvertently set in/out points to the defaults just because the animation couldn't be found (yet).\n\t\t\tkeyboardHandler,\n\t\t\tplayPauseButton = find(\".play-pause\"),\n\t\t\tplayPauseMorph = _buildPlayPauseMorph(playPauseButton),\n\t\t\tpaused = false,\n\t\t\tloopButton = find(\".loop\"),\n\t\t\tloopAnimation = _buildLoopAnimation(loopButton),\n\t\t\tloopEnabled,\n\t\t\ttimeScale = find(\".time-scale select\"),\n\t\t\ttimeScaleLabel = find(\".time-scale-label\"),\n\t\t\t//spits back a common onPress function for anything that's dragged along the timeline (playhead, inPoint, outPoint). The originRatio is a value from 0-1 indicating how far along the x-axis the origin is located (0.5 is in the center, 0 is left, 1 is on right side). limitElement is optional, and sets the bounds such that the element can't be dragged past the limitElement.\n\t\t\tonPressTimeline = (element, originRatio, limitToInOut) => {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tlet trackBounds = timelineTrack.getBoundingClientRect(),\n\t\t\t\t\t\telementBounds = element.getBoundingClientRect(),\n\t\t\t\t\t\tleft = elementBounds.width * originRatio,\n\t\t\t\t\t\tx = gsap.getProperty(element, \"x\"),\n\t\t\t\t\t\tminX = trackBounds.left - elementBounds.left - left + x,\n\t\t\t\t\t\tmaxX = trackBounds.right - elementBounds.right + (elementBounds.width - left) + x,\n\t\t\t\t\t\tunlimitedMinX = minX,\n\t\t\t\t\t\tlimitBounds;\n\t\t\t\t\tif (limitToInOut) {\n\t\t\t\t\t\tif (element !== inPoint) {\n\t\t\t\t\t\t\tlimitBounds = inPoint.getBoundingClientRect();\n\t\t\t\t\t\t\tif (limitBounds.left) { //if inPoint is hidden (like display:none), ignore.\n\t\t\t\t\t\t\t\tminX += (limitBounds.left + limitBounds.width) - trackBounds.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (element !== outPoint) {\n\t\t\t\t\t\t\tlimitBounds = outPoint.getBoundingClientRect();\n\t\t\t\t\t\t\tif (limitBounds.left) { //if outPoint is hidden (like display:none), ignore.\n\t\t\t\t\t\t\t\tmaxX -= (trackBounds.left + trackBounds.width) - limitBounds.left;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpausedWhenDragStarted = paused;\n\t\t\t\t\tthis.applyBounds({minX:minX, maxX:maxX});\n\t\t\t\t\tpixelToTimeRatio = linkedAnimation.duration() / trackBounds.width;\n\t\t\t\t\ttimeAtDragStart = -unlimitedMinX * pixelToTimeRatio;\n\t\t\t\t\tif (!skipDragUpdates) {\n\t\t\t\t\t\tlinkedAnimation.pause(timeAtDragStart + pixelToTimeRatio * this.x);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlinkedAnimation.pause();\n\t\t\t\t\t}\n\t\t\t\t\tif (this.target === playhead) {\n\t\t\t\t\t\tif (this.activated) {\n\t\t\t\t\t\t\tthis.allowEventDefault = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.activated = true;\n\t\t\t\t\t}\n\t\t\t\t\tdragged = true;\n\t\t\t\t};\n\t\t\t},\n\t\t\tprogressDrag = Draggable.create(playhead, {\n\t\t\t\ttype:\"x\",\n\t\t\t\tcursor: \"ew-resize\",\n\t\t\t\tallowNativeTouchScrolling: false,\n\t\t\t\tallowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n\t\t\t\tonPress: onPressTimeline(playhead, 0.5, true),\n\t\t\t\tonDrag: function() {\n\t\t\t\t\tlet time = timeAtDragStart + pixelToTimeRatio * this.x;\n\t\t\t\t\tif (time < 0) {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t} else if (time > linkedAnimation._dur) {\n\t\t\t\t\t\ttime = linkedAnimation._dur;\n\t\t\t\t\t}\n\t\t\t\t\tif (!skipDragUpdates) {\n\t\t\t\t\t\tlinkedAnimation.time(time);\n\t\t\t\t\t}\n\t\t\t\t\tprogressBar.style.width = Math.min(outProgress - inProgress, Math.max(0, (time / linkedAnimation._dur) * 100 - inProgress)) + \"%\";\n\t\t\t\t\ttimeLabel.innerHTML = time.toFixed(2);\n\t\t\t\t},\n\t\t\t\tonRelease: function() {\n\t\t\t\t\tpaused || linkedAnimation.resume();\n\t\t\t\t}\n\t\t\t})[0],\n\t\t\tresetInOut = () => {\n\t\t\t\tinProgress = 0;\n\t\t\t\toutProgress = 100;\n\t\t\t\tinPoint.style.left = \"0%\";\n\t\t\t\toutPoint.style.left = \"100%\";\n\t\t\t\trecord(\"in\", inProgress);\n\t\t\t\trecord(\"out\", outProgress);\n\t\t\t\tupdateProgress(true);\n\t\t\t},\n\t\t\tinDrag = Draggable.create(inPoint, {\n\t\t\t\ttype: \"x\",\n\t\t\t\tcursor: \"ew-resize\",\n\t\t\t\tzIndexBoost: false,\n\t\t\t\tallowNativeTouchScrolling: false,\n\t\t\t\tallowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n\t\t\t\tonPress: onPressTimeline(inPoint, 1, true),\n\t\t\t\tonDoubleClick: resetInOut,\n\t\t\t\tonDrag: function() {\n\t\t\t\t\tinProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n\t\t\t\t\tlinkedAnimation.progress(inProgress / 100);\n\t\t\t\t\tupdateProgress(true);\n\t\t\t\t},\n\t\t\t\tonRelease: function() {\n\t\t\t\t\tif (inProgress < 0) {\n\t\t\t\t\t\tinProgress = 0;\n\t\t\t\t\t}\n\t\t\t\t\t_clearSelection();\n\t\t\t\t\t//for responsiveness, convert the px-based transform into %-based left position.\n\t\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\t\trecord(\"in\", inProgress);\n\t\t\t\t\tgsap.set(inPoint, {x:0, data:\"root\", display:\"block\"}); //set display:block so that it remains visible even when the minimal skin is enabled.\n\t\t\t\t\tif (!paused) {\n\t\t\t\t\t\tlinkedAnimation.resume();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})[0],\n\t\t\toutDrag = Draggable.create(outPoint, {\n\t\t\t\ttype: \"x\",\n\t\t\t\tcursor: \"ew-resize\",\n\t\t\t\tallowNativeTouchScrolling: false,\n\t\t\t\tallowEventDefault: true, //otherwise, when dragged outside an iframe, the mouseup doesn't bubble up so it could seem \"stuck\" to the mouse.\n\t\t\t\tzIndexBoost: false,\n\t\t\t\tonPress: onPressTimeline(outPoint, 0, true),\n\t\t\t\tonDoubleClick: resetInOut,\n\t\t\t\tonDrag: function() {\n\t\t\t\t\toutProgress = (timeAtDragStart + pixelToTimeRatio * this.x) / linkedAnimation.duration() * 100;\n\t\t\t\t\tlinkedAnimation.progress(outProgress / 100);\n\t\t\t\t\tupdateProgress(true);\n\t\t\t\t},\n\t\t\t\tonRelease: function() {\n\t\t\t\t\tif (outProgress > 100) {\n\t\t\t\t\t\toutProgress = 100;\n\t\t\t\t\t}\n\t\t\t\t\t_clearSelection();\n\t\t\t\t\t//for responsiveness, convert the px-based transform into %-based left position.\n\t\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\t\trecord(\"out\", outProgress);\n\t\t\t\t\tgsap.set(outPoint, {x:0, data:\"root\", display:\"block\"}); //set display:block so that it remains visible even when the minimal skin is enabled.\n\t\t\t\t\tif (!pausedWhenDragStarted) {\n\t\t\t\t\t\tplay();\n\t\t\t\t\t\tlinkedAnimation.resume();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})[0],\n\t\t\tupdateProgress = function(force) { // NOTE: \"force\" is actually the \"time\" when this method gets called by the gsap.ticker!\n\t\t\t\tif (progressDrag.isPressed && force !== true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet p = (!loopEnabled && selectedAnimation._repeat === -1) ? selectedAnimation.totalTime() / selectedAnimation.duration() * 100 : (linkedAnimation.progress() * 100) || 0,\n\t\t\t\t\trepeatDelayPhase = (selectedAnimation._repeat && selectedAnimation._rDelay && selectedAnimation.totalTime() % (selectedAnimation.duration() + selectedAnimation._rDelay) > selectedAnimation.duration()),\n\t\t\t\t\ttarget;\n\t\t\t\tif (p > 100) {\n\t\t\t\t\tp = 100;\n\t\t\t\t}\n\t\t\t\tif (p >= outProgress) {\n\t\t\t\t\tif (loopEnabled && !linkedAnimation.paused() && !progressDrag.isDragging) {\n\t\t\t\t\t\tif (!repeatDelayPhase) {\n\t\t\t\t\t\t\tp = inProgress;\n\t\t\t\t\t\t\ttarget = linkedAnimation._targets && linkedAnimation._targets[0];\n\t\t\t\t\t\t\tif (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n\t\t\t\t\t\t\t\ttarget.seek(startTime + ((endTime - startTime) * inProgress / 100));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (selectedAnimation._repeat > 0 && !inProgress && outProgress === 100) {\n\t\t\t\t\t\t\t\tif (selectedAnimation.totalProgress() === 1) {\n\t\t\t\t\t\t\t\t\tlinkedAnimation.totalProgress(0, true).resume();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlinkedAnimation.progress(p / 100, true).resume();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (p !== outProgress || selectedAnimation._repeat === -1) {\n\t\t\t\t\t\t\tp = outProgress;\n\t\t\t\t\t\t\tlinkedAnimation.progress(p / 100);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!paused && (outProgress < 100 || selectedAnimation.totalProgress() === 1 || selectedAnimation._repeat === -1)) {\n\t\t\t\t\t\t\tpause();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else if (p < inProgress) {\n\t\t\t\t\tp = inProgress;\n\t\t\t\t\tlinkedAnimation.progress(p / 100, true);\n\t\t\t\t}\n\t\t\t\tif (p !== progress || force === true) {\n\t\t\t\t\tprogressBar.style.left = inProgress + \"%\";\n\t\t\t\t\tprogressBar.style.width = Math.max(0, p - inProgress) + \"%\";\n\t\t\t\t\tplayhead.style.left = p + \"%\";\n\t\t\t\t\ttimeLabel.innerHTML = linkedAnimation._time.toFixed(2);\n\t\t\t\t\tdurationLabel.innerHTML = linkedAnimation._dur.toFixed(2);\n\t\t\t\t\tif (dragged) {\n\t\t\t\t\t\tplayhead.style.transform = \"translate(-50%,0)\";\n\t\t\t\t\t\tplayhead._gsap.x = \"0px\";\n\t\t\t\t\t\tplayhead._gsap.xPercent = -50;\n\t\t\t\t\t\tdragged = false;\n\t\t\t\t\t}\n\t\t\t\t\tprogress = p;\n\t\t\t\t}\n\t\t\t\tlinkedAnimation.paused() !== paused && togglePlayPause(); // if the user has an addPause() in the middle of the animation.\n\t\t\t},\n\t\t\tonPressSeekBar = function(e) {\n\t\t\t\tif (progressDrag.isPressed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet bounds = e.target.getBoundingClientRect(),\n\t\t\t\t\tx = (e.changedTouches ? e.changedTouches[0] : e).clientX,\n\t\t\t\t\tp = ((x - bounds.left) / bounds.width) * 100;\n\t\t\t\tif (p < inProgress) {\n\t\t\t\t\tinProgress = p = Math.max(0, p);\n\t\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\t\tinDrag.startDrag(e);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (p > outProgress) {\n\t\t\t\t\toutProgress = p = Math.min(100, p);\n\t\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\t\toutDrag.startDrag(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlinkedAnimation.progress(p / 100).pause();\n\t\t\t\tupdateProgress(true);\n\t\t\t\tprogressDrag.startDrag(e);\n\t\t\t},\n\n\n\n\t\t\t//PLAY/PAUSE button\n\t\t\tplay = () => {\n\t\t\t\tif (linkedAnimation.progress() >= outProgress / 100) {\n\t\t\t\t\t_checkIndependence(linkedAnimation, vars);\n\t\t\t\t\tlet target = linkedAnimation._targets && linkedAnimation._targets[0];\n\t\t\t\t\tif (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n\t\t\t\t\t\ttarget.seek(startTime + ((endTime - startTime) * inProgress / 100));\n\t\t\t\t\t}\n\t\t\t\t\tif (linkedAnimation._repeat && !inProgress) {\n\t\t\t\t\t\tlinkedAnimation.totalProgress(0, true); //for repeating animations, don't get stuck in the last iteration - jump all the way back to the start.\n\t\t\t\t\t} else if (!linkedAnimation.reversed()) {\n\t\t\t\t\t\tlinkedAnimation.progress(inProgress / 100, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tplayPauseMorph.play();\n\t\t\t\tlinkedAnimation.resume();\n\t\t\t\tif (paused) {\n\t\t\t\t\t_self.update();\n\t\t\t\t}\n\t\t\t\tpaused = false;\n\t\t\t},\n\t\t\tpause = () => {\n\t\t\t\tplayPauseMorph.reverse();\n\t\t\t\tif (linkedAnimation) {\n\t\t\t\t\tlinkedAnimation.pause();\n\t\t\t\t}\n\t\t\t\tpaused = true;\n\t\t\t},\n\t\t\ttogglePlayPause = () => {\n\t\t\t\tif (paused) {\n\t\t\t\t\tplay();\n\t\t\t\t} else {\n\t\t\t\t\tpause();\n\t\t\t\t}\n\t\t\t},\n\n\n\n\t\t\t//REWIND button\n\t\t\tonPressRewind = e => {\n\t\t\t\tif (progressDrag.isPressed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//_self.update();\n\t\t\t\t_checkIndependence(linkedAnimation, vars);\n\t\t\t\tlet target = linkedAnimation._targets && linkedAnimation._targets[0];\n\t\t\t\tif (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n\t\t\t\t\ttarget.seek(startTime + ((endTime - startTime) * inProgress / 100));\n\t\t\t\t}\n\t\t\t\tlinkedAnimation.progress(inProgress / 100, true);\n\t\t\t\tif (!paused) {\n\t\t\t\t\tlinkedAnimation.resume();\n\t\t\t\t}\n\t\t\t},\n\n\n\n\t\t\t//LOOP button\n\t\t\tloop = value => {\n\t\t\t\tloopEnabled = value;\n\t\t\t\trecord(\"loop\", loopEnabled);\n\t\t\t\tif (loopEnabled) {\n\t\t\t\t\tloopAnimation.play();\n\t\t\t\t\tif (linkedAnimation.progress() >= outProgress / 100) {\n\t\t\t\t\t\tlet target = linkedAnimation._targets && linkedAnimation._targets[0];\n\t\t\t\t\t\tif (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n\t\t\t\t\t\t\ttarget.seek(startTime + ((endTime - startTime) * inProgress / 100));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (selectedAnimation._repeat && !inProgress && outProgress === 100) {\n\t\t\t\t\t\t\tlinkedAnimation.totalProgress(0, true);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlinkedAnimation.progress(inProgress / 100, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tplay();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tloopAnimation.reverse();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ttoggleLoop = () => loop(!loopEnabled),\n\n\n\n\t\t\t//ANIMATIONS list\n\t\t\tupdateList = () => {\n\t\t\t\tlet animations = _getChildrenOf((declaredAnimation && !vars.globalSync) ? declaredAnimation : _recordedRoot, true),\n\t\t\t\t\toptions = list.children,\n\t\t\t\t\tmatches = 0,\n\t\t\t\t\toption,\ti;\n\t\t\t\tif (declaredAnimation && !vars.globalSync) {\n\t\t\t\t\tanimations.unshift(declaredAnimation);\n\t\t\t\t} else if (!vars.hideGlobalTimeline) {\n\t\t\t\t\tanimations.unshift(_recordedRoot);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < animations.length; i++) {\n\t\t\t\t\toption = options[i] || _createElement(\"option\", list);\n\t\t\t\t\toption.animation = animations[i];\n\t\t\t\t\tmatches = (i && animations[i].vars.id === animations[i-1].vars.id) ? matches + 1 : 0;\n\t\t\t\t\toption.setAttribute(\"value\", (option.innerHTML = animations[i].vars.id + (matches ? \" [\" + matches + \"]\" : (animations[i+1] && animations[i+1].vars.id === animations[i].vars.id) ? \" [0]\" : \"\")));\n\t\t\t\t}\n\t\t\t\tfor (; i < options.length; i++) {\n\t\t\t\t\tlist.removeChild(options[i]);\n\t\t\t\t}\n\t\t\t},\n\t\t\tanimation = function(anim) {\n\t\t\t\tlet ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n\t\t\t\t\ttl, maxDuration;\n\t\t\t\tif (!arguments.length) {\n\t\t\t\t\treturn selectedAnimation;\n\t\t\t\t}\n\t\t\t\tif (_isString(anim)) {\n\t\t\t\t\tanim = _getAnimationById(anim);\n\t\t\t\t}\n\t\t\t\t//console.log(\"animation() \", anim.vars.id);\n\t\t\t\tif (!(anim instanceof Animation)) {\n\t\t\t\t\tconsole.warn(\"GSDevTools error: invalid animation.\");\n\t\t\t\t}\n\t\t\t\tif (anim.scrollTrigger) {\n\t\t\t\t\tconsole.warn(\"GSDevTools can't work with ScrollTrigger-based animations; either the scrollbar -OR- the GSDevTools scrubber can control the animation.\");\n\t\t\t\t}\n\t\t\t\tif (anim === selectedAnimation) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (selectedAnimation) {\n\t\t\t\t\tselectedAnimation._inProgress = inProgress;\n\t\t\t\t\tselectedAnimation._outProgress = outProgress;\n\t\t\t\t}\n\t\t\t\tselectedAnimation = anim;\n\t\t\t\tif (linkedAnimation) {\n\t\t\t\t\tts = linkedAnimation.timeScale();\n\t\t\t\t\tif (linkedAnimation._targets && linkedAnimation._targets[0] === declaredAnimation) {\n\t\t\t\t\t\tdeclaredAnimation.resume();\n\t\t\t\t\t\tlinkedAnimation.kill();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinProgress = selectedAnimation._inProgress || 0;\n\t\t\t\toutProgress = selectedAnimation._outProgress || 100;\n\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\tif (_fullyInitialized) { //don't record inProgress/outProgress unless we're fully instantiated because people may call GSDevTools.create() before creating/defining their animations, thus the inTime/outTime may not exist yet.\n\t\t\t\t\trecord(\"animation\", selectedAnimation.vars.id);\n\t\t\t\t\trecord(\"in\", inProgress);\n\t\t\t\t\trecord(\"out\", outProgress);\n\t\t\t\t}\n\t\t\t\tstartTime = 0;\n\t\t\t\tmaxDuration = vars.maxDuration || Math.min(1000, _getClippedDuration(selectedAnimation));\n\t\t\t\tif (selectedAnimation === _recordedRoot || vars.globalSync) {\n\t\t\t\t\t_merge();\n\t\t\t\t\tlinkedAnimation = _rootTween;\n\t\t\t\t\t_rootInstance && _rootInstance !== _self && console.warn(\"Error: GSDevTools can only have one instance that's globally synchronized.\");\n\t\t\t\t\t_rootInstance = _self;\n\t\t\t\t\tif (selectedAnimation !== _recordedRoot) {\n\t\t\t\t\t\ttl = selectedAnimation;\n\t\t\t\t\t\tendTime = tl.totalDuration();\n\t\t\t\t\t\tif (endTime > 99999999) { //in the case of an infinitely repeating animation, just use a single iteration's duration instead.\n\t\t\t\t\t\t\tendTime = tl.duration();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (tl.parent) {\n\t\t\t\t\t\t\tstartTime = (startTime / tl._ts) + tl._start;\n\t\t\t\t\t\t\tendTime = (endTime / tl._ts) + tl._start;\n\t\t\t\t\t\t\ttl = tl.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tendTime = _recordedRoot.duration();\n\t\t\t\t\t}\n\t\t\t\t\tif (endTime - startTime > maxDuration) { //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.\n\t\t\t\t\t\tendTime = startTime + maxDuration;\n\t\t\t\t\t}\n\t\t\t\t\t_recordedRoot.pause(startTime);\n\t\t\t\t\t_rootTween.vars.time = endTime;\n\t\t\t\t\t_rootTween.invalidate();\n\t\t\t\t\t_rootTween.duration(endTime - startTime).timeScale(ts);\n\t\t\t\t\t//wait for a tick before starting because some browsers freeze things immediately following a <select> selection, like on MacOS it flashes a few times before disappearing, so this prevents a \"jump\".\n\t\t\t\t\tif (paused) {\n\t\t\t\t\t\t//jump forward and then back in order to make sure the start/end values are recorded internally right away and don't drift outside this tween.\n\t\t\t\t\t\t_rootTween.progress(1, true).pause(0, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_delayedCall(0.01, () => {\n\t\t\t\t\t\t\t_rootTween.resume().progress(inProgress / 100);\n\t\t\t\t\t\t\tpaused && play();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tif (_rootInstance === _self) {\n\t\t\t\t\t\t_rootInstance = null;\n\t\t\t\t\t}\n\t\t\t\t\tstartTime = Math.min(inProgress * selectedAnimation.duration(), selectedAnimation.time());\n\t\t\t\t\tif (selectedAnimation === declaredAnimation || !declaredAnimation) {\n\t\t\t\t\t\tlinkedAnimation = selectedAnimation;\n\t\t\t\t\t\tif (!loopEnabled && linkedAnimation._repeat) {\n\t\t\t\t\t\t\tloop(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { //if an animation is declared in the config object, and the user chooses a sub-animation (nested), we tween the playhead of the declaredAnimation to keep everything synchronized even though globalSync isn't true.\n\t\t\t\t\t\ttl = selectedAnimation;\n\t\t\t\t\t\tendTime = tl.totalDuration();\n\t\t\t\t\t\tif (endTime > 99999999) { //in the case of an infinitely repeating animation, just use a single iteration's duration instead.\n\t\t\t\t\t\t\tendTime = tl.duration();\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (tl.parent.parent && tl !== declaredAnimation) {\n\t\t\t\t\t\t\tstartTime = (startTime / (tl._ts || tl._pauseTS)) + tl._start;\n\t\t\t\t\t\t\tendTime = (endTime / (tl._ts || tl._pauseTS)) + tl._start;\n\t\t\t\t\t\t\ttl = tl.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (endTime - startTime > maxDuration) { //cap end time at 1000 because it doesn't seem reasonable to accommodate super long stuff.\n\t\t\t\t\t\t\tendTime = startTime + maxDuration;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdeclaredAnimation.pause(startTime);\n\t\t\t\t\t\tlinkedAnimation = gsap.to(declaredAnimation, {duration: endTime - startTime, time:endTime, ease:\"none\", data:\"root\", parent:_independentRoot}, _independentRoot._time);\n\t\t\t\t\t}\n\t\t\t\t\tlinkedAnimation.timeScale(ts);\n\t\t\t\t\t_rootTween.pause();\n\t\t\t\t\t_recordedRoot.resume();\n\t\t\t\t\tlinkedAnimation.seek(0);\n\t\t\t\t}\n\n\t\t\t\tdurationLabel.innerHTML = linkedAnimation.duration().toFixed(2);\n\t\t\t\t_selectValue(list, selectedAnimation.vars.id, animationLabel);\n\t\t\t},\n\t\t\tupdateRootDuration = () => {\n\t\t\t\tlet time, ratio, duration;\n\t\t\t\tif (selectedAnimation === _recordedRoot) {\n\t\t\t\t\ttime = _recordedRoot._time;\n\t\t\t\t\t_recordedRoot.progress(1, true).time(time, true); //jump to the end and back again because sometimes a tween that hasn't rendered yet will affect duration, like a TimelineMax.tweenTo() where the duration gets set in the onStart.\n\t\t\t\t\ttime = (_rootTween._dp._time - _rootTween._start) * _rootTween._ts;\n\t\t\t\t\tduration = Math.min(1000, _recordedRoot.duration());\n\t\t\t\t\tif (duration === 1000) {\n\t\t\t\t\t\tduration = Math.min(1000, _getClippedDuration(_recordedRoot));\n\t\t\t\t\t}\n\t\t\t\t\tratio = _rootTween.duration() / duration;\n\t\t\t\t\tif (ratio !== 1 && duration) {\n\t\t\t\t\t\tinProgress *= ratio;\n\t\t\t\t\t\tif (outProgress < 100) {\n\t\t\t\t\t\t\toutProgress *= ratio;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_rootTween.seek(0);\n\t\t\t\t\t\t_rootTween.vars.time = duration;\n\t\t\t\t\t\t_rootTween.invalidate();\n\t\t\t\t\t\t_rootTween.duration(duration);\n\t\t\t\t\t\t_rootTween.time(time);\n\t\t\t\t\t\tdurationLabel.innerHTML = duration.toFixed(2);\n\t\t\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\t\t\tupdateProgress(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tonChangeAnimation = e => {\n\t\t\t\tanimation(list.options[list.selectedIndex].animation);\n\t\t\t\tif (e.target && e.target.blur) { //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.\n\t\t\t\t\te.target.blur();\n\t\t\t\t}\n\t\t\t\tpaused && play();\n\t\t\t},\n\n\n\n\t\t\t//TIMESCALE button\n\t\t\tonChangeTimeScale = e => {\n\t\t\t\tlet ts = parseFloat(timeScale.options[timeScale.selectedIndex].value) || 1,\n\t\t\t\t\ttarget;\n\t\t\t\tlinkedAnimation.timeScale(ts);\n\t\t\t\trecord(\"timeScale\", ts);\n\t\t\t\tif (!paused) {\n\t\t\t\t\tif (linkedAnimation.progress() >= outProgress / 100) {\n\t\t\t\t\t\ttarget = linkedAnimation._targets && linkedAnimation._targets[0];\n\t\t\t\t\t\tif (target === selectedAnimation) { //in case there are callbacks on the timeline, when we jump back to the start we should seek() so that the playhead doesn't drag [backward] past those and trigger them.\n\t\t\t\t\t\t\ttarget.seek(startTime + ((endTime - startTime) * inProgress / 100));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlinkedAnimation.progress(inProgress / 100, true).pause();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlinkedAnimation.pause();\n\t\t\t\t\t}\n\t\t\t\t\t_delayedCall(0.01, () => linkedAnimation.resume());\n\t\t\t\t}\n\t\t\t\ttimeScaleLabel.innerHTML = ts + \"x\";\n\t\t\t\tif (timeScale.blur) { //so that if an option is selected, and then the user tries to hit the up/down arrow, it doesn't just try selecting something else in the <select>.\n\t\t\t\t\ttimeScale.blur();\n\t\t\t\t}\n\t\t\t},\n\n\n\n\t\t\t//AUTOHIDE\n\t\t\tautoHideTween = gsap.to([find(\".gs-bottom\"), find(\".gs-top\")], {duration:0.3, autoAlpha:0, y:50, ease:\"power2.in\", data:\"root\", paused:true, parent:_independentRoot}, _independentRoot._time),\n\t\t\thidden = false,\n\t\t\tonMouseOut = e => {\n\t\t\t\tif (!Draggable.hitTest(e, root) && !progressDrag.isDragging && !inDrag.isDragging && !outDrag.isDragging) {\n\t\t\t\t\tautoHideDelayedCall.restart(true);\n\t\t\t\t}\n\t\t\t},\n\t\t\thide = () => {\n\t\t\t\tif (!hidden) {\n\t\t\t\t\tautoHideTween.play();\n\t\t\t\t\tautoHideDelayedCall.pause();\n\t\t\t\t\thidden = true;\n\t\t\t\t}\n\t\t\t},\n\t\t\tshow = () => {\n\t\t\t\tautoHideDelayedCall.pause();\n\t\t\t\tif (hidden) {\n\t\t\t\t\tautoHideTween.reverse();\n\t\t\t\t\thidden = false;\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoggleHide = () => {\n\t\t\t\tif (hidden) {\n\t\t\t\t\tshow();\n\t\t\t\t} else {\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t},\n\t\t\tautoHideDelayedCall = _delayedCall(1.3, hide).pause(),\n\t\t\tinitialize = preliminary => {\n\t\t\t\t//if on startup, someone does a timeline.seek(), we must honor it, so when initialize() is called, we record _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n\t\t\t\tif (_startupPhase && !_globalStartTime) {\n\t\t\t\t\t_globalStartTime = _recordedRoot._start;\n\t\t\t\t}\n\t\t\t\t_fullyInitialized = !preliminary;\n\t\t\t\tdeclaredAnimation = _parseAnimation(vars.animation);\n\t\t\t\tif (declaredAnimation && !declaredAnimation.vars.id) {\n\t\t\t\t\tdeclaredAnimation.vars.id = \"[no id]\";\n\t\t\t\t}\n\t\t\t\t_merge();\n\t\t\t\tupdateList();\n\t\t\t\tlet savedAnimation = _getAnimationById(recall(\"animation\"));\n\t\t\t\tif (savedAnimation) {\n\t\t\t\t\tsavedAnimation._inProgress = recall(\"in\") || 0;\n\t\t\t\t\tsavedAnimation._outProgress = recall(\"out\") || 100;\n\t\t\t\t}\n\t\t\t\tvars.paused && pause();\n\t\t\t\tselectedAnimation = null;\n\t\t\t\tanimation(declaredAnimation || savedAnimation || _recordedRoot);\n\t\t\t\tlet ts = vars.timeScale || recall(\"timeScale\"),\n\t\t\t\t\tsavedInOut = (savedAnimation === selectedAnimation);\n\t\t\t\tif (ts) {\n\t\t\t\t\t_selectValue(timeScale, ts, timeScaleLabel, ts + \"x\");\n\t\t\t\t\tlinkedAnimation.timeScale(ts);\n\t\t\t\t}\n\t\t\t\tinProgress = ((\"inTime\" in vars) ? _timeToProgress(vars.inTime, selectedAnimation, 0, 0) : savedInOut ? savedAnimation._inProgress : 0) || 0;\n\t\t\t\tif (inProgress === 100 && !vars.animation && savedAnimation) { //in case there's a recorded animation (sessionStorage) and then the user defines an inTime that exceeds that animation's duration, just default back to the Global Timeline. Otherwise the in/out point will be at the very end and it'd be weird.\n\t\t\t\t\tanimation(_recordedRoot);\n\t\t\t\t\tinProgress = _timeToProgress(vars.inTime, selectedAnimation, 0, 0) || 0;\n\t\t\t\t}\n\t\t\t\tif (inProgress) {\n\t\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\t\tinPoint.style.display = outPoint.style.display = \"block\"; //set display:block so that it remains visible even when the minimal skin is enabled.\n\t\t\t\t}\n\t\t\t\toutProgress = ((\"outTime\" in vars) ? _timeToProgress(vars.outTime, selectedAnimation, 100, inProgress) : savedInOut ? savedAnimation._outProgress : 0) || 100;\n\t\t\t\tif (outProgress < inProgress) {\n\t\t\t\t\toutProgress = 100;\n\t\t\t\t}\n\t\t\t\tif (outProgress !== 100) {\n\t\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\t\tinPoint.style.display = outPoint.style.display = \"block\"; //set display:block so that it remains visible even when the minimal skin is enabled.\n\t\t\t\t}\n\t\t\t\tloopEnabled = (\"loop\" in vars) ? vars.loop : recall(\"loop\");\n\t\t\t\tloopEnabled && loop(true);\n\t\t\t\tvars.paused && linkedAnimation.progress(inProgress / 100, true).pause();\n\t\t\t\tif (_startupPhase && selectedAnimation === _recordedRoot && _globalStartTime && vars.globalSync && !paused) {\n\t\t\t\t\tlinkedAnimation.time(-_globalStartTime, true);\n\t\t\t\t}\n\t\t\t\tupdateProgress(true);\n\t\t\t};\n\n\n\n\t\t//INITIALIZATION TASKS\n\t\t_addListener(list, \"change\", onChangeAnimation);\n\t\t_addListener(list, \"mousedown\", updateList);\n\t\t_addListener(playPauseButton, \"mousedown\", togglePlayPause);\n\t\t_addListener(find(\".seek-bar\"), \"mousedown\", onPressSeekBar);\n\t\t_addListener(find(\".rewind\"), \"mousedown\", onPressRewind);\n\t\t_addListener(loopButton, \"mousedown\", toggleLoop);\n\t\t_addListener(timeScale, \"change\", onChangeTimeScale);\n\n\t\tif (vars.visibility === \"auto\") {\n\t\t\t_addListener(root, \"mouseout\", onMouseOut);\n\t\t\t//_addListener(find(\".gs-hit-area\"), \"mouseover\", show);\n\t\t\t_addListener(root, \"mouseover\", show);\n\n\t\t} else if (vars.visibility === \"hidden\") {\n\t\t\thidden = true;\n\t\t\tautoHideTween.progress(1);\n\t\t}\n\n\t\tif (vars.keyboard !== false) {\n\t\t\tif (_keyboardInstance && vars.keyboard) {\n\t\t\t\tconsole.warn(\"[GSDevTools warning] only one instance can be affected by keyboard shortcuts. There is already one active.\");\n\t\t\t} else {\n\t\t\t\t_keyboardInstance = _self; //we can't have multiple instances all affected by the keyboard.\n\t\t\t\tkeyboardHandler = e => { //window.parent allows things to work inside of an iframe, like on codepen.\n\t\t\t\t\tlet key = e.keyCode ? e.keyCode : e.which,\n\t\t\t\t\t\tts;\n\t\t\t\t\tif (key === 32) { //spacebar\n\t\t\t\t\t\ttogglePlayPause();\n\t\t\t\t\t} else if (key === 38) { //up arrow\n\t\t\t\t\t\tts = parseFloat(_shiftSelectedValue(timeScale, -1, timeScaleLabel));\n\t\t\t\t\t\tlinkedAnimation.timeScale(ts);\n\t\t\t\t\t\trecord(\"timeScale\", ts);\n\t\t\t\t\t} else if (key === 40) { //down arrow\n\t\t\t\t\t\tts = parseFloat(_shiftSelectedValue(timeScale, 1, timeScaleLabel));\n\t\t\t\t\t\tlinkedAnimation.timeScale(ts);\n\t\t\t\t\t\trecord(\"timeScale\", ts);\n\t\t\t\t\t} else if (key === 37) { //left arrow\n\t\t\t\t\t\tonPressRewind(e);\n\t\t\t\t\t} else if (key === 39) { //right arrow\n\t\t\t\t\t\tlinkedAnimation.progress(outProgress / 100);\n\t\t\t\t\t} else if (key === 76) { //\"L\" key\n\t\t\t\t\t\ttoggleLoop();\n\t\t\t\t\t} else if (key === 72) { //\"H\" key\n\t\t\t\t\t\ttoggleHide();\n\t\t\t\t\t} else if (key === 73) { //\"I\" key\n\t\t\t\t\t\tinProgress = linkedAnimation.progress() * 100;\n\t\t\t\t\t\trecord(\"in\", inProgress);\n\t\t\t\t\t\tinPoint.style.left = inProgress + \"%\";\n\t\t\t\t\t\tupdateProgress(true);\n\t\t\t\t\t} else if (key === 79) { //\"O\" key\n\t\t\t\t\t\toutProgress = linkedAnimation.progress() * 100;\n\t\t\t\t\t\trecord(\"out\", outProgress);\n\t\t\t\t\t\toutPoint.style.left = outProgress + \"%\";\n\t\t\t\t\t\tupdateProgress(true);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t_addListener(_docEl, \"keydown\", keyboardHandler);\n\t\t\t}\n\t\t}\n\n\n\t\tgsap.set(playhead, {xPercent:-50, x:0, data:\"root\"}); //so that when we drag, x is properly discerned (browsers report in pure pixels rather than percents)\n\t\tgsap.set(inPoint, {xPercent:-100, x:0, data:\"root\"});\n\t\tinPoint._gsIgnore = outPoint._gsIgnore = playhead._gsIgnore = playPauseButton._gsIgnore = loopButton._gsIgnore = true;\n\n\t\t//Draggable fires off a TweenLite.set() that affects the transforms, and we don't want them to get into the _recordedRoot, so kill those tweens.\n\t\tgsap.killTweensOf([inPoint, outPoint, playhead]);\n\n\n\t\tinitialize(_startupPhase);\n\t\tif (_startupPhase) {\n\t\t\t//developers may call GSDevTools.create() before they even create some of their animations, so the inTime/outTime or animation values may not exist, thus we wait for 1 tick and initialize again, just in case.\n\t\t\t_delayedCall(0.0001, initialize, [false], this);\n\t\t}\n\t\tgsap.ticker.add(updateProgress);\n\n\t\tthis.update = forceMerge => {\n\t\t\tif (_rootInstance === _self) {\n\t\t\t\tif (!_rootTween.paused() || forceMerge) {\n\t\t\t\t\t_merge();\n\t\t\t\t}\n\t\t\t\tupdateRootDuration();\n\t\t\t}\n\t\t};\n\n\t\tthis.kill = this.revert = () => {\n\t\t\t_removeListener(list, \"change\", onChangeAnimation);\n\t\t\t_removeListener(list, \"mousedown\", updateList);\n\t\t\t_removeListener(playPauseButton, \"mousedown\", togglePlayPause);\n\t\t\t_removeListener(find(\".seek-bar\"), \"mousedown\", onPressSeekBar);\n\t\t\t_removeListener(find(\".rewind\"), \"mousedown\", onPressRewind);\n\t\t\t_removeListener(loopButton, \"mousedown\", toggleLoop);\n\t\t\t_removeListener(timeScale, \"change\", onChangeTimeScale);\n\t\t\tprogressDrag.disable();\n\t\t\tinDrag.disable();\n\t\t\toutDrag.disable();\n\t\t\tgsap.ticker.remove(updateProgress);\n\t\t\t_removeListener(root, \"mouseout\", onMouseOut);\n\t\t\t_removeListener(root, \"mouseover\", show);\n\t\t\troot.parentNode.removeChild(root);\n\t\t\tif (_rootInstance === _self) {\n\t\t\t\t_rootInstance = null;\n\t\t\t}\n\t\t\tif (_keyboardInstance === _self) {\n\t\t\t\t_keyboardInstance = null;\n\t\t\t\t_removeListener(_docEl, \"keydown\", keyboardHandler);\n\t\t\t}\n\t\t\tdelete _lookup[vars.id + \"\"];\n\t\t};\n\n\t\tthis.minimal = function(value) {\n\t\t\tlet isMinimal = root.classList.contains(\"minimal\"),\n\t\t\t\tp;\n\t\t\tif (!arguments.length || isMinimal === value) {\n\t\t\t\treturn isMinimal;\n\t\t\t}\n\t\t\tif (value) {\n\t\t\t\troot.classList.add(\"minimal\");\n\t\t\t} else {\n\t\t\t\troot.classList.remove(\"minimal\");\n\t\t\t}\n\t\t\tif (vars.container) {\n\t\t\t\troot.style.top = value ? \"calc(100% - 42px)\" : \"calc(100% - 51px)\";\n\t\t\t}\n\t\t\tif (progressDrag.isPressed) {\n\t\t\t\tskipDragUpdates = true; //just in case there's actually a tween/timeline in the linkedAnimation that is altering this GSDevTool instance's \"minimal()\" value, it could trigger a recursive loop in the drag handlers, like if they update linkedAnimation's time/progress which in turn triggers this minimal() function which in turn dues the same, and so on.\n\t\t\t\tprogressDrag.endDrag(progressDrag.pointerEvent);\n\t\t\t\tskipDragUpdates = false;\n\n\t\t\t\tp = linkedAnimation.progress() * 100;\n\t\t\t\tprogressBar.style.width = Math.max(0, p - inProgress) + \"%\";\n\t\t\t\tplayhead.style.left = p + \"%\";\n\t\t\t\tplayhead.style.transform = \"translate(-50%,0)\";\n\t\t\t\tplayhead._gsap.x = \"0px\";\n\t\t\t\tplayhead._gsap.xPercent = -50;\n\n\t\t\t\tprogressDrag.startDrag(progressDrag.pointerEvent, true);\n\t\t\t}\n\t\t};\n\n\t\t//expose methods:\n\t\tthis.animation = animation;\n\t\tthis.updateList = updateList;\n\n\t\t_context(this);\n\n\t}; //if on startup, someone does a timeline.seek(), we need to honor it, so when initialize() is called, it'll check the _recordedRoot._start so that we can use that as an offset. Remember, however, that we call initialize() twice on startup, once after a tick has elapsed just in case someone called GSDevTools.create() before their animation code, so we must record the value (once).\n\n\n\nGSDevTools.version = \"3.13.0\";\nGSDevTools.globalRecordingTime = 2;\n\nGSDevTools.getById = id => id ? _lookup[id] : _rootInstance;\n\nGSDevTools.getByAnimation = animation => {\n\tif (_isString(animation)) {\n\t\tanimation = gsap.getById(animation);\n\t}\n\tfor (let p in _lookup) {\n\t\tif (_lookup[p].animation() === animation) {\n\t\t\treturn _lookup[p];\n\t\t}\n\t}\n};\n\nGSDevTools.create = vars => new GSDevTools(vars);\n\nGSDevTools.register = _initCore;\n\n_getGSAP() && gsap.registerPlugin(GSDevTools);\n\nexport { GSDevTools, GSDevTools as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}