{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport { Alias } from '../nodes/Alias.js';\nimport { isNode, isPair, MAP, SEQ, isDocument } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n  if (tagName) {\n    const match = tags.filter(t => t.tag === tagName);\n    const tagObj = match.find(t => !t.format) ?? match[0];\n    if (!tagObj) throw new Error(`Tag ${tagName} not found`);\n    return tagObj;\n  }\n  return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n  if (isDocument(value)) value = value.contents;\n  if (isNode(value)) return value;\n  if (isPair(value)) {\n    const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n    map.items.push(value);\n    return map;\n  }\n  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== 'undefined' && value instanceof BigInt // not supported everywhere\n  ) {\n    // https://tc39.es/ecma262/#sec-serializejsonproperty\n    value = value.valueOf();\n  }\n  const {\n    aliasDuplicateObjects,\n    onAnchor,\n    onTagObj,\n    schema,\n    sourceObjects\n  } = ctx;\n  // Detect duplicate references to the same object & use Alias nodes for all\n  // after first. The `ref` wrapper allows for circular references to resolve.\n  let ref = undefined;\n  if (aliasDuplicateObjects && value && typeof value === 'object') {\n    ref = sourceObjects.get(value);\n    if (ref) {\n      ref.anchor ?? (ref.anchor = onAnchor(value));\n      return new Alias(ref.anchor);\n    } else {\n      ref = {\n        anchor: null,\n        node: null\n      };\n      sourceObjects.set(value, ref);\n    }\n  }\n  if (tagName?.startsWith('!!')) tagName = defaultTagPrefix + tagName.slice(2);\n  let tagObj = findTagObject(value, tagName, schema.tags);\n  if (!tagObj) {\n    if (value && typeof value.toJSON === 'function') {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      value = value.toJSON();\n    }\n    if (!value || typeof value !== 'object') {\n      const node = new Scalar(value);\n      if (ref) ref.node = node;\n      return node;\n    }\n    tagObj = value instanceof Map ? schema[MAP] : Symbol.iterator in Object(value) ? schema[SEQ] : schema[MAP];\n  }\n  if (onTagObj) {\n    onTagObj(tagObj);\n    delete ctx.onTagObj;\n  }\n  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === 'function' ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);\n  if (tagName) node.tag = tagName;else if (!tagObj.default) node.tag = tagObj.tag;\n  if (ref) ref.node = node;\n  return node;\n}\nexport { createNode };","map":{"version":3,"names":["Alias","isNode","isPair","MAP","SEQ","isDocument","Scalar","defaultTagPrefix","findTagObject","value","tagName","tags","match","filter","t","tag","tagObj","find","format","Error","identify","createNode","ctx","contents","map","schema","items","push","String","Number","Boolean","BigInt","valueOf","aliasDuplicateObjects","onAnchor","onTagObj","sourceObjects","ref","undefined","get","anchor","node","set","startsWith","slice","toJSON","Map","Symbol","iterator","Object","nodeClass","from","default"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/doc/createNode.js"],"sourcesContent":["import { Alias } from '../nodes/Alias.js';\nimport { isNode, isPair, MAP, SEQ, isDocument } from '../nodes/identity.js';\nimport { Scalar } from '../nodes/Scalar.js';\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (isDocument(value))\n        value = value.contents;\n    if (isNode(value))\n        return value;\n    if (isPair(value)) {\n        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            ref.anchor ?? (ref.anchor = onAnchor(value));\n            return new Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[SEQ]\n                    : schema[MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : typeof tagObj?.nodeClass?.from === 'function'\n            ? tagObj.nodeClass.from(ctx.schema, value, ctx)\n            : new Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    else if (!tagObj.default)\n        node.tag = tagObj.tag;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexport { createNode };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}