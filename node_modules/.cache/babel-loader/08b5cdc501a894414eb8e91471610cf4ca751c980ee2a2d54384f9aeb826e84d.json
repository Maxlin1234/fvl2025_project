{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { createNode } from '../doc/createNode.js';\nimport { isNode, isPair, isCollection, isScalar } from './identity.js';\nimport { NodeBase } from './Node.js';\nfunction collectionFromPath(schema, path, value) {\n  let v = value;\n  for (let i = path.length - 1; i >= 0; --i) {\n    const k = path[i];\n    if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n      const a = [];\n      a[k] = v;\n      v = a;\n    } else {\n      v = new Map([[k, v]]);\n    }\n  }\n  return createNode(v, undefined, {\n    aliasDuplicateObjects: false,\n    keepUndefined: false,\n    onAnchor: () => {\n      throw new Error('This should not happen, please report a bug.');\n    },\n    schema,\n    sourceObjects: new Map()\n  });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = path => path == null || typeof path === 'object' && !!path[Symbol.iterator]().next().done;\nclass Collection extends NodeBase {\n  constructor(type, schema) {\n    super(type);\n    Object.defineProperty(this, 'schema', {\n      value: schema,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n  }\n  /**\n   * Create a copy of this collection.\n   *\n   * @param schema - If defined, overwrites the original's schema\n   */\n  clone(schema) {\n    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n    if (schema) copy.schema = schema;\n    copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n    if (this.range) copy.range = this.range.slice();\n    return copy;\n  }\n  /**\n   * Adds a value to the collection. For `!!map` and `!!omap` the value must\n   * be a Pair instance or a `{ key, value }` object, which may not have a key\n   * that already exists in the map.\n   */\n  addIn(path, value) {\n    if (isEmptyPath(path)) this.add(value);else {\n      const [key, ...rest] = path;\n      const node = this.get(key, true);\n      if (isCollection(node)) node.addIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n  /**\n   * Removes a value from the collection.\n   * @returns `true` if the item was found and removed.\n   */\n  deleteIn(path) {\n    const [key, ...rest] = path;\n    if (rest.length === 0) return this.delete(key);\n    const node = this.get(key, true);\n    if (isCollection(node)) return node.deleteIn(rest);else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n  }\n  /**\n   * Returns item at `key`, or `undefined` if not found. By default unwraps\n   * scalar values from their surrounding node; to disable set `keepScalar` to\n   * `true` (collections are always returned intact).\n   */\n  getIn(path, keepScalar) {\n    const [key, ...rest] = path;\n    const node = this.get(key, true);\n    if (rest.length === 0) return !keepScalar && isScalar(node) ? node.value : node;else return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n  }\n  hasAllNullValues(allowScalar) {\n    return this.items.every(node => {\n      if (!isPair(node)) return false;\n      const n = node.value;\n      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;\n    });\n  }\n  /**\n   * Checks if the collection includes a value with the key `key`.\n   */\n  hasIn(path) {\n    const [key, ...rest] = path;\n    if (rest.length === 0) return this.has(key);\n    const node = this.get(key, true);\n    return isCollection(node) ? node.hasIn(rest) : false;\n  }\n  /**\n   * Sets a value in this collection. For `!!set`, `value` needs to be a\n   * boolean to add/remove the item from the set.\n   */\n  setIn(path, value) {\n    const [key, ...rest] = path;\n    if (rest.length === 0) {\n      this.set(key, value);\n    } else {\n      const node = this.get(key, true);\n      if (isCollection(node)) node.setIn(rest, value);else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n  }\n}\nexport { Collection, collectionFromPath, isEmptyPath };","map":{"version":3,"names":["createNode","isNode","isPair","isCollection","isScalar","NodeBase","collectionFromPath","schema","path","value","v","i","length","k","Number","isInteger","a","Map","undefined","aliasDuplicateObjects","keepUndefined","onAnchor","Error","sourceObjects","isEmptyPath","Symbol","iterator","next","done","Collection","constructor","type","Object","defineProperty","configurable","enumerable","writable","clone","copy","create","getPrototypeOf","getOwnPropertyDescriptors","items","map","it","range","slice","addIn","add","key","rest","node","get","set","deleteIn","delete","getIn","keepScalar","hasAllNullValues","allowScalar","every","n","commentBefore","comment","tag","hasIn","has","setIn"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/nodes/Collection.js"],"sourcesContent":["import { createNode } from '../doc/createNode.js';\nimport { isNode, isPair, isCollection, isScalar } from './identity.js';\nimport { NodeBase } from './Node.js';\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => isNode(it) || isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && isScalar(node) ? node.value : node;\n        else\n            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\n\nexport { Collection, collectionFromPath, isEmptyPath };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}