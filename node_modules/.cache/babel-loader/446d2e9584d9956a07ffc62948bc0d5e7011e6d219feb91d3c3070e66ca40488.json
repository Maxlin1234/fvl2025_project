{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\nfunction getErrorPos(src) {\n  if (typeof src === 'number') return [src, src + 1];\n  if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];\n  const {\n    offset,\n    source\n  } = src;\n  return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n  let comment = '';\n  let atComment = false;\n  let afterEmptyLine = false;\n  for (let i = 0; i < prelude.length; ++i) {\n    const source = prelude[i];\n    switch (source[0]) {\n      case '#':\n        comment += (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') + (source.substring(1) || ' ');\n        atComment = true;\n        afterEmptyLine = false;\n        break;\n      case '%':\n        if (prelude[i + 1]?.[0] !== '#') i += 1;\n        atComment = false;\n        break;\n      default:\n        // This may be wrong after doc-end, but in that case it doesn't matter\n        if (!atComment) afterEmptyLine = true;\n        atComment = false;\n    }\n  }\n  return {\n    comment,\n    afterEmptyLine\n  };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n  constructor(options = {}) {\n    this.doc = null;\n    this.atDirectives = false;\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n    this.onError = (source, code, message, warning) => {\n      const pos = getErrorPos(source);\n      if (warning) this.warnings.push(new YAMLWarning(pos, code, message));else this.errors.push(new YAMLParseError(pos, code, message));\n    };\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    this.directives = new Directives({\n      version: options.version || '1.2'\n    });\n    this.options = options;\n  }\n  decorate(doc, afterDoc) {\n    const {\n      comment,\n      afterEmptyLine\n    } = parsePrelude(this.prelude);\n    //console.log({ dc: doc.comment, prelude, comment })\n    if (comment) {\n      const dc = doc.contents;\n      if (afterDoc) {\n        doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n      } else if (afterEmptyLine || doc.directives.docStart || !dc) {\n        doc.commentBefore = comment;\n      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n        let it = dc.items[0];\n        if (isPair(it)) it = it.key;\n        const cb = it.commentBefore;\n        it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n      } else {\n        const cb = dc.commentBefore;\n        dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n      }\n    }\n    if (afterDoc) {\n      Array.prototype.push.apply(doc.errors, this.errors);\n      Array.prototype.push.apply(doc.warnings, this.warnings);\n    } else {\n      doc.errors = this.errors;\n      doc.warnings = this.warnings;\n    }\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n  }\n  /**\n   * Current stream status information.\n   *\n   * Mostly useful at the end of input for an empty stream.\n   */\n  streamInfo() {\n    return {\n      comment: parsePrelude(this.prelude).comment,\n      directives: this.directives,\n      errors: this.errors,\n      warnings: this.warnings\n    };\n  }\n  /**\n   * Compose tokens into documents.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  *compose(tokens, forceDoc = false, endOffset = -1) {\n    for (const token of tokens) yield* this.next(token);\n    yield* this.end(forceDoc, endOffset);\n  }\n  /** Advance the composer by one CST token. */\n  *next(token) {\n    switch (token.type) {\n      case 'directive':\n        this.directives.add(token.source, (offset, message, warning) => {\n          const pos = getErrorPos(token);\n          pos[0] += offset;\n          this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n        });\n        this.prelude.push(token.source);\n        this.atDirectives = true;\n        break;\n      case 'document':\n        {\n          const doc = composeDoc(this.options, this.directives, token, this.onError);\n          if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n          this.decorate(doc, false);\n          if (this.doc) yield this.doc;\n          this.doc = doc;\n          this.atDirectives = false;\n          break;\n        }\n      case 'byte-order-mark':\n      case 'space':\n        break;\n      case 'comment':\n      case 'newline':\n        this.prelude.push(token.source);\n        break;\n      case 'error':\n        {\n          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;\n          const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n          if (this.atDirectives || !this.doc) this.errors.push(error);else this.doc.errors.push(error);\n          break;\n        }\n      case 'doc-end':\n        {\n          if (!this.doc) {\n            const msg = 'Unexpected doc-end without preceding document';\n            this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n            break;\n          }\n          this.doc.directives.docEnd = true;\n          const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n          this.decorate(this.doc, true);\n          if (end.comment) {\n            const dc = this.doc.comment;\n            this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n          }\n          this.doc.range[2] = end.offset;\n          break;\n        }\n      default:\n        this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n    }\n  }\n  /**\n   * Call at end of input to yield any remaining document.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  *end(forceDoc = false, endOffset = -1) {\n    if (this.doc) {\n      this.decorate(this.doc, true);\n      yield this.doc;\n      this.doc = null;\n    } else if (forceDoc) {\n      const opts = Object.assign({\n        _directives: this.directives\n      }, this.options);\n      const doc = new Document(undefined, opts);\n      if (this.atDirectives) this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n      doc.range = [0, endOffset, endOffset];\n      this.decorate(doc, false);\n      yield doc;\n    }\n  }\n}\nexport { Composer };","map":{"version":3,"names":["Directives","Document","YAMLWarning","YAMLParseError","isCollection","isPair","composeDoc","resolveEnd","getErrorPos","src","Array","isArray","length","offset","source","parsePrelude","prelude","comment","atComment","afterEmptyLine","i","substring","Composer","constructor","options","doc","atDirectives","errors","warnings","onError","code","message","warning","pos","push","directives","version","decorate","afterDoc","dc","contents","docStart","commentBefore","flow","items","it","key","cb","prototype","apply","streamInfo","compose","tokens","forceDoc","endOffset","token","next","end","type","add","msg","JSON","stringify","error","docEnd","strict","range","opts","Object","assign","_directives","undefined"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/composer.js"],"sourcesContent":["import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexport { Composer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}