{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isScalar, isPair } from '../../nodes/identity.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { resolvePairs, createPairs } from './pairs.js';\nclass YAMLOMap extends YAMLSeq {\n  constructor() {\n    super();\n    this.add = YAMLMap.prototype.add.bind(this);\n    this.delete = YAMLMap.prototype.delete.bind(this);\n    this.get = YAMLMap.prototype.get.bind(this);\n    this.has = YAMLMap.prototype.has.bind(this);\n    this.set = YAMLMap.prototype.set.bind(this);\n    this.tag = YAMLOMap.tag;\n  }\n  /**\n   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n   * but TypeScript won't allow widening the signature of a child method.\n   */\n  toJSON(_, ctx) {\n    if (!ctx) return super.toJSON(_);\n    const map = new Map();\n    if (ctx?.onCreate) ctx.onCreate(map);\n    for (const pair of this.items) {\n      let key, value;\n      if (isPair(pair)) {\n        key = toJS(pair.key, '', ctx);\n        value = toJS(pair.value, key, ctx);\n      } else {\n        key = toJS(pair, '', ctx);\n      }\n      if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');\n      map.set(key, value);\n    }\n    return map;\n  }\n  static from(schema, iterable, ctx) {\n    const pairs = createPairs(schema, iterable, ctx);\n    const omap = new this();\n    omap.items = pairs.items;\n    return omap;\n  }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n  collection: 'seq',\n  identify: value => value instanceof Map,\n  nodeClass: YAMLOMap,\n  default: false,\n  tag: 'tag:yaml.org,2002:omap',\n  resolve(seq, onError) {\n    const pairs = resolvePairs(seq, onError);\n    const seenKeys = [];\n    for (const {\n      key\n    } of pairs.items) {\n      if (isScalar(key)) {\n        if (seenKeys.includes(key.value)) {\n          onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n        } else {\n          seenKeys.push(key.value);\n        }\n      }\n    }\n    return Object.assign(new YAMLOMap(), pairs);\n  },\n  createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\nexport { YAMLOMap, omap };","map":{"version":3,"names":["isScalar","isPair","toJS","YAMLMap","YAMLSeq","resolvePairs","createPairs","YAMLOMap","constructor","add","prototype","bind","delete","get","has","set","tag","toJSON","_","ctx","map","Map","onCreate","pair","items","key","value","Error","from","schema","iterable","pairs","omap","collection","identify","nodeClass","default","resolve","seq","onError","seenKeys","includes","push","Object","assign","createNode"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"],"sourcesContent":["import { isScalar, isPair } from '../../nodes/identity.js';\nimport { toJS } from '../../nodes/toJS.js';\nimport { YAMLMap } from '../../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../../nodes/YAMLSeq.js';\nimport { resolvePairs, createPairs } from './pairs.js';\n\nclass YAMLOMap extends YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (isPair(pair)) {\n                key = toJS(pair.key, '', ctx);\n                value = toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n    static from(schema, iterable, ctx) {\n        const pairs = createPairs(schema, iterable, ctx);\n        const omap = new this();\n        omap.items = pairs.items;\n        return omap;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs = resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs.items) {\n            if (isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs);\n    },\n    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)\n};\n\nexport { YAMLOMap, omap };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}