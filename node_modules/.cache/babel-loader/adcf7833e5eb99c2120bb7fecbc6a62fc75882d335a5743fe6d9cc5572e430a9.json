{"ast":null,"code":"import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\nfunction resolveFlowScalar(scalar, strict, onError) {\n  const {\n    offset,\n    type,\n    source,\n    end\n  } = scalar;\n  let _type;\n  let value;\n  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n  switch (type) {\n    case 'scalar':\n      _type = Scalar.PLAIN;\n      value = plainValue(source, _onError);\n      break;\n    case 'single-quoted-scalar':\n      _type = Scalar.QUOTE_SINGLE;\n      value = singleQuotedValue(source, _onError);\n      break;\n    case 'double-quoted-scalar':\n      _type = Scalar.QUOTE_DOUBLE;\n      value = doubleQuotedValue(source, _onError);\n      break;\n    /* istanbul ignore next should not happen */\n    default:\n      onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n      return {\n        value: '',\n        type: null,\n        comment: '',\n        range: [offset, offset + source.length, offset + source.length]\n      };\n  }\n  const valueEnd = offset + source.length;\n  const re = resolveEnd(end, valueEnd, strict, onError);\n  return {\n    value,\n    type: _type,\n    comment: re.comment,\n    range: [offset, valueEnd, re.offset]\n  };\n}\nfunction plainValue(source, onError) {\n  let badChar = '';\n  switch (source[0]) {\n    /* istanbul ignore next should not happen */\n    case '\\t':\n      badChar = 'a tab character';\n      break;\n    case ',':\n      badChar = 'flow indicator character ,';\n      break;\n    case '%':\n      badChar = 'directive indicator character %';\n      break;\n    case '|':\n    case '>':\n      {\n        badChar = `block scalar indicator ${source[0]}`;\n        break;\n      }\n    case '@':\n    case '`':\n      {\n        badChar = `reserved character ${source[0]}`;\n        break;\n      }\n  }\n  if (badChar) onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n  return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n  if (source[source.length - 1] !== \"'\" || source.length === 1) onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n  return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n  /**\n   * The negative lookbehind here and in the `re` RegExp is to\n   * prevent causing a polynomial search time in certain cases.\n   *\n   * The try-catch is for Safari, which doesn't support this yet:\n   * https://caniuse.com/js-regexp-lookbehind\n   */\n  let first, line;\n  try {\n    first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n    line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n  } catch {\n    first = /(.*?)[ \\t]*\\r?\\n/sy;\n    line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n  }\n  let match = first.exec(source);\n  if (!match) return source;\n  let res = match[1];\n  let sep = ' ';\n  let pos = first.lastIndex;\n  line.lastIndex = pos;\n  while (match = line.exec(source)) {\n    if (match[1] === '') {\n      if (sep === '\\n') res += sep;else sep = '\\n';\n    } else {\n      res += sep + match[1];\n      sep = ' ';\n    }\n    pos = line.lastIndex;\n  }\n  const last = /[ \\t]*(.*)/sy;\n  last.lastIndex = pos;\n  match = last.exec(source);\n  return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n  let res = '';\n  for (let i = 1; i < source.length - 1; ++i) {\n    const ch = source[i];\n    if (ch === '\\r' && source[i + 1] === '\\n') continue;\n    if (ch === '\\n') {\n      const {\n        fold,\n        offset\n      } = foldNewline(source, i);\n      res += fold;\n      i = offset;\n    } else if (ch === '\\\\') {\n      let next = source[++i];\n      const cc = escapeCodes[next];\n      if (cc) res += cc;else if (next === '\\n') {\n        // skip escaped newlines, but still trim the following line\n        next = source[i + 1];\n        while (next === ' ' || next === '\\t') next = source[++i + 1];\n      } else if (next === '\\r' && source[i + 1] === '\\n') {\n        // skip escaped CRLF newlines, but still trim the following line\n        next = source[++i + 1];\n        while (next === ' ' || next === '\\t') next = source[++i + 1];\n      } else if (next === 'x' || next === 'u' || next === 'U') {\n        const length = {\n          x: 2,\n          u: 4,\n          U: 8\n        }[next];\n        res += parseCharCode(source, i + 1, length, onError);\n        i += length;\n      } else {\n        const raw = source.substr(i - 1, 2);\n        onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        res += raw;\n      }\n    } else if (ch === ' ' || ch === '\\t') {\n      // trim trailing whitespace\n      const wsStart = i;\n      let next = source[i + 1];\n      while (next === ' ' || next === '\\t') next = source[++i + 1];\n      if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n')) res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n    } else {\n      res += ch;\n    }\n  }\n  if (source[source.length - 1] !== '\"' || source.length === 1) onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n  return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n  let fold = '';\n  let ch = source[offset + 1];\n  while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n    if (ch === '\\r' && source[offset + 2] !== '\\n') break;\n    if (ch === '\\n') fold += '\\n';\n    offset += 1;\n    ch = source[offset + 1];\n  }\n  if (!fold) fold = ' ';\n  return {\n    fold,\n    offset\n  };\n}\nconst escapeCodes = {\n  '0': '\\0',\n  // null character\n  a: '\\x07',\n  // bell character\n  b: '\\b',\n  // backspace\n  e: '\\x1b',\n  // escape character\n  f: '\\f',\n  // form feed\n  n: '\\n',\n  // line feed\n  r: '\\r',\n  // carriage return\n  t: '\\t',\n  // horizontal tab\n  v: '\\v',\n  // vertical tab\n  N: '\\u0085',\n  // Unicode next line\n  _: '\\u00a0',\n  // Unicode non-breaking space\n  L: '\\u2028',\n  // Unicode line separator\n  P: '\\u2029',\n  // Unicode paragraph separator\n  ' ': ' ',\n  '\"': '\"',\n  '/': '/',\n  '\\\\': '\\\\',\n  '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n  const cc = source.substr(offset, length);\n  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n  const code = ok ? parseInt(cc, 16) : NaN;\n  if (isNaN(code)) {\n    const raw = source.substr(offset - 2, length + 2);\n    onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n    return raw;\n  }\n  return String.fromCodePoint(code);\n}\nexport { resolveFlowScalar };","map":{"version":3,"names":["Scalar","resolveEnd","resolveFlowScalar","scalar","strict","onError","offset","type","source","end","_type","value","_onError","rel","code","msg","PLAIN","plainValue","QUOTE_SINGLE","singleQuotedValue","QUOTE_DOUBLE","doubleQuotedValue","comment","range","length","valueEnd","re","badChar","foldLines","slice","replace","first","line","RegExp","match","exec","res","sep","pos","lastIndex","last","i","ch","fold","foldNewline","next","cc","escapeCodes","x","u","U","parseCharCode","raw","substr","wsStart","a","b","e","f","n","r","t","v","N","_","L","P","ok","test","parseInt","NaN","isNaN","String","fromCodePoint"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"],"sourcesContent":["import { Scalar } from '../nodes/Scalar.js';\nimport { resolveEnd } from './resolve-end.js';\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0', // null character\n    a: '\\x07', // bell character\n    b: '\\b', // backspace\n    e: '\\x1b', // escape character\n    f: '\\f', // form feed\n    n: '\\n', // line feed\n    r: '\\r', // carriage return\n    t: '\\t', // horizontal tab\n    v: '\\v', // vertical tab\n    N: '\\u0085', // Unicode next line\n    _: '\\u00a0', // Unicode non-breaking space\n    L: '\\u2028', // Unicode line separator\n    P: '\\u2029', // Unicode paragraph separator\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexport { resolveFlowScalar };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}