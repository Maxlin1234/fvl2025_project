{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { ALIAS, isAlias, isCollection, isPair, hasAnchor } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\nclass Alias extends NodeBase {\n  constructor(source) {\n    super(ALIAS);\n    this.source = source;\n    Object.defineProperty(this, 'tag', {\n      set() {\n        throw new Error('Alias nodes cannot have tags');\n      }\n    });\n  }\n  /**\n   * Resolve the value of this alias within `doc`, finding the last\n   * instance of the `source` anchor before this node.\n   */\n  resolve(doc, ctx) {\n    let nodes;\n    if (ctx?.aliasResolveCache) {\n      nodes = ctx.aliasResolveCache;\n    } else {\n      nodes = [];\n      visit(doc, {\n        Node: (_key, node) => {\n          if (isAlias(node) || hasAnchor(node)) nodes.push(node);\n        }\n      });\n      if (ctx) ctx.aliasResolveCache = nodes;\n    }\n    let found = undefined;\n    for (const node of nodes) {\n      if (node === this) break;\n      if (node.anchor === this.source) found = node;\n    }\n    return found;\n  }\n  toJSON(_arg, ctx) {\n    if (!ctx) return {\n      source: this.source\n    };\n    const {\n      anchors,\n      doc,\n      maxAliasCount\n    } = ctx;\n    const source = this.resolve(doc, ctx);\n    if (!source) {\n      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n      throw new ReferenceError(msg);\n    }\n    let data = anchors.get(source);\n    if (!data) {\n      // Resolve anchors for Node.prototype.toJS()\n      toJS(source, null, ctx);\n      data = anchors.get(source);\n    }\n    /* istanbul ignore if */\n    if (!data || data.res === undefined) {\n      const msg = 'This should not happen: Alias anchor was not resolved?';\n      throw new ReferenceError(msg);\n    }\n    if (maxAliasCount >= 0) {\n      data.count += 1;\n      if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);\n      if (data.count * data.aliasCount > maxAliasCount) {\n        const msg = 'Excessive alias count indicates a resource exhaustion attack';\n        throw new ReferenceError(msg);\n      }\n    }\n    return data.res;\n  }\n  toString(ctx, _onComment, _onChompKeep) {\n    const src = `*${this.source}`;\n    if (ctx) {\n      anchorIsValid(this.source);\n      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n        throw new Error(msg);\n      }\n      if (ctx.implicitKey) return `${src} `;\n    }\n    return src;\n  }\n}\nfunction getAliasCount(doc, node, anchors) {\n  if (isAlias(node)) {\n    const source = node.resolve(doc);\n    const anchor = anchors && source && anchors.get(source);\n    return anchor ? anchor.count * anchor.aliasCount : 0;\n  } else if (isCollection(node)) {\n    let count = 0;\n    for (const item of node.items) {\n      const c = getAliasCount(doc, item, anchors);\n      if (c > count) count = c;\n    }\n    return count;\n  } else if (isPair(node)) {\n    const kc = getAliasCount(doc, node.key, anchors);\n    const vc = getAliasCount(doc, node.value, anchors);\n    return Math.max(kc, vc);\n  }\n  return 1;\n}\nexport { Alias };","map":{"version":3,"names":["anchorIsValid","visit","ALIAS","isAlias","isCollection","isPair","hasAnchor","NodeBase","toJS","Alias","constructor","source","Object","defineProperty","set","Error","resolve","doc","ctx","nodes","aliasResolveCache","Node","_key","node","push","found","undefined","anchor","toJSON","_arg","anchors","maxAliasCount","msg","ReferenceError","data","get","res","count","aliasCount","getAliasCount","toString","_onComment","_onChompKeep","src","options","verifyAliasOrder","has","implicitKey","item","items","c","kc","key","vc","value","Math","max"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/nodes/Alias.js"],"sourcesContent":["import { anchorIsValid } from '../doc/anchors.js';\nimport { visit } from '../visit.js';\nimport { ALIAS, isAlias, isCollection, isPair, hasAnchor } from './identity.js';\nimport { NodeBase } from './Node.js';\nimport { toJS } from './toJS.js';\n\nclass Alias extends NodeBase {\n    constructor(source) {\n        super(ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc, ctx) {\n        let nodes;\n        if (ctx?.aliasResolveCache) {\n            nodes = ctx.aliasResolveCache;\n        }\n        else {\n            nodes = [];\n            visit(doc, {\n                Node: (_key, node) => {\n                    if (isAlias(node) || hasAnchor(node))\n                        nodes.push(node);\n                }\n            });\n            if (ctx)\n                ctx.aliasResolveCache = nodes;\n        }\n        let found = undefined;\n        for (const node of nodes) {\n            if (node === this)\n                break;\n            if (node.anchor === this.source)\n                found = node;\n        }\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc, ctx);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        let data = anchors.get(source);\n        if (!data) {\n            // Resolve anchors for Node.prototype.toJS()\n            toJS(source, null, ctx);\n            data = anchors.get(source);\n        }\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexport { Alias };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}