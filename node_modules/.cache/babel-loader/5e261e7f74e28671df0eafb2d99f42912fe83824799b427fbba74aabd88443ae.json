{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = token => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({\n  composeNode,\n  composeEmptyNode\n}, ctx, fc, onError, tag) {\n  const isMap = fc.start.source === '{';\n  const fcName = isMap ? 'flow map' : 'flow sequence';\n  const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq);\n  const coll = new NodeClass(ctx.schema);\n  coll.flow = true;\n  const atRoot = ctx.atRoot;\n  if (atRoot) ctx.atRoot = false;\n  if (ctx.atKey) ctx.atKey = false;\n  let offset = fc.offset + fc.start.source.length;\n  for (let i = 0; i < fc.items.length; ++i) {\n    const collItem = fc.items[i];\n    const {\n      start,\n      key,\n      sep,\n      value\n    } = collItem;\n    const props = resolveProps(start, {\n      flow: fcName,\n      indicator: 'explicit-key-ind',\n      next: key ?? sep?.[0],\n      offset,\n      onError,\n      parentIndent: fc.indent,\n      startOnNewline: false\n    });\n    if (!props.found) {\n      if (!props.anchor && !props.tag && !sep && !value) {\n        if (i === 0 && props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);else if (i < fc.items.length - 1) onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n        if (props.comment) {\n          if (coll.comment) coll.comment += '\\n' + props.comment;else coll.comment = props.comment;\n        }\n        offset = props.end;\n        continue;\n      }\n      if (!isMap && ctx.options.strict && containsNewline(key)) onError(key,\n      // checked by containsNewline()\n      'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n    }\n    if (i === 0) {\n      if (props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n    } else {\n      if (!props.comma) onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n      if (props.comment) {\n        let prevItemComment = '';\n        loop: for (const st of start) {\n          switch (st.type) {\n            case 'comma':\n            case 'space':\n              break;\n            case 'comment':\n              prevItemComment = st.source.substring(1);\n              break loop;\n            default:\n              break loop;\n          }\n        }\n        if (prevItemComment) {\n          let prev = coll.items[coll.items.length - 1];\n          if (isPair(prev)) prev = prev.value ?? prev.key;\n          if (prev.comment) prev.comment += '\\n' + prevItemComment;else prev.comment = prevItemComment;\n          props.comment = props.comment.substring(prevItemComment.length + 1);\n        }\n      }\n    }\n    if (!isMap && !sep && !props.found) {\n      // item is a value in a seq\n      // → key & sep are empty, start does not include ? or :\n      const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n      coll.items.push(valueNode);\n      offset = valueNode.range[2];\n      if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n    } else {\n      // item is a key+value pair\n      // key value\n      ctx.atKey = true;\n      const keyStart = props.end;\n      const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n      if (isBlock(key)) onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n      ctx.atKey = false;\n      // value properties\n      const valueProps = resolveProps(sep ?? [], {\n        flow: fcName,\n        indicator: 'map-value-ind',\n        next: value,\n        offset: keyNode.range[2],\n        onError,\n        parentIndent: fc.indent,\n        startOnNewline: false\n      });\n      if (valueProps.found) {\n        if (!isMap && !props.found && ctx.options.strict) {\n          if (sep) for (const st of sep) {\n            if (st === valueProps.found) break;\n            if (st.type === 'newline') {\n              onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n              break;\n            }\n          }\n          if (props.start < valueProps.found.offset - 1024) onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n        }\n      } else if (value) {\n        if ('source' in value && value.source && value.source[0] === ':') onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);else onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n      }\n      // value value\n      const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;\n      if (valueNode) {\n        if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n      } else if (valueProps.comment) {\n        if (keyNode.comment) keyNode.comment += '\\n' + valueProps.comment;else keyNode.comment = valueProps.comment;\n      }\n      const pair = new Pair(keyNode, valueNode);\n      if (ctx.options.keepSourceTokens) pair.srcToken = collItem;\n      if (isMap) {\n        const map = coll;\n        if (mapIncludes(ctx, map.items, keyNode)) onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        map.items.push(pair);\n      } else {\n        const map = new YAMLMap(ctx.schema);\n        map.flow = true;\n        map.items.push(pair);\n        const endRange = (valueNode ?? keyNode).range;\n        map.range = [keyNode.range[0], endRange[1], endRange[2]];\n        coll.items.push(map);\n      }\n      offset = valueNode ? valueNode.range[2] : valueProps.end;\n    }\n  }\n  const expectedEnd = isMap ? '}' : ']';\n  const [ce, ...ee] = fc.end;\n  let cePos = offset;\n  if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;else {\n    const name = fcName[0].toUpperCase() + fcName.substring(1);\n    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n    onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n    if (ce && ce.source.length !== 1) ee.unshift(ce);\n  }\n  if (ee.length > 0) {\n    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n    if (end.comment) {\n      if (coll.comment) coll.comment += '\\n' + end.comment;else coll.comment = end.comment;\n    }\n    coll.range = [fc.offset, cePos, end.offset];\n  } else {\n    coll.range = [fc.offset, cePos, cePos];\n  }\n  return coll;\n}\nexport { resolveFlowCollection };","map":{"version":3,"names":["isPair","Pair","YAMLMap","YAMLSeq","resolveEnd","resolveProps","containsNewline","mapIncludes","blockMsg","isBlock","token","type","resolveFlowCollection","composeNode","composeEmptyNode","ctx","fc","onError","tag","isMap","start","source","fcName","NodeClass","nodeClass","coll","schema","flow","atRoot","atKey","offset","length","i","items","collItem","key","sep","value","props","indicator","next","parentIndent","indent","startOnNewline","found","anchor","comma","comment","end","options","strict","prevItemComment","loop","st","substring","prev","valueNode","push","range","keyStart","keyNode","valueProps","pair","keepSourceTokens","srcToken","map","endRange","expectedEnd","ce","ee","cePos","name","toUpperCase","msg","unshift"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"],"sourcesContent":["import { isPair } from '../nodes/identity.js';\nimport { Pair } from '../nodes/Pair.js';\nimport { YAMLMap } from '../nodes/YAMLMap.js';\nimport { YAMLSeq } from '../nodes/YAMLSeq.js';\nimport { resolveEnd } from './resolve-end.js';\nimport { resolveProps } from './resolve-props.js';\nimport { containsNewline } from './util-contains-newline.js';\nimport { mapIncludes } from './util-map-includes.js';\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));\n    const coll = new NodeClass(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    if (ctx.atKey)\n        ctx.atKey = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            parentIndent: fc.indent,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            // → key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            ctx.atKey = true;\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            ctx.atKey = false;\n            // value properties\n            const valueProps = resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                parentIndent: fc.indent,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                const endRange = (valueNode ?? keyNode).range;\n                map.range = [keyNode.range[0], endRange[1], endRange[2]];\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexport { resolveFlowCollection };\n"],"mappings":";AAAA,SAASA,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,IAAI,QAAQ,kBAAkB;AACvC,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,OAAO,QAAQ,qBAAqB;AAC7C,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,YAAY,QAAQ,oBAAoB;AACjD,SAASC,eAAe,QAAQ,4BAA4B;AAC5D,SAASC,WAAW,QAAQ,wBAAwB;AAEpD,MAAMC,QAAQ,GAAG,2DAA2D;AAC5E,MAAMC,OAAO,GAAIC,KAAK,IAAKA,KAAK,KAAKA,KAAK,CAACC,IAAI,KAAK,WAAW,IAAID,KAAK,CAACC,IAAI,KAAK,WAAW,CAAC;AAC9F,SAASC,qBAAqBA,CAAC;EAAEC,WAAW;EAAEC;AAAiB,CAAC,EAAEC,GAAG,EAAEC,EAAE,EAAEC,OAAO,EAAEC,GAAG,EAAE;EACrF,MAAMC,KAAK,GAAGH,EAAE,CAACI,KAAK,CAACC,MAAM,KAAK,GAAG;EACrC,MAAMC,MAAM,GAAGH,KAAK,GAAG,UAAU,GAAG,eAAe;EACnD,MAAMI,SAAS,GAAIL,GAAG,EAAEM,SAAS,KAAKL,KAAK,GAAGjB,OAAO,GAAGC,OAAO,CAAE;EACjE,MAAMsB,IAAI,GAAG,IAAIF,SAAS,CAACR,GAAG,CAACW,MAAM,CAAC;EACtCD,IAAI,CAACE,IAAI,GAAG,IAAI;EAChB,MAAMC,MAAM,GAAGb,GAAG,CAACa,MAAM;EACzB,IAAIA,MAAM,EACNb,GAAG,CAACa,MAAM,GAAG,KAAK;EACtB,IAAIb,GAAG,CAACc,KAAK,EACTd,GAAG,CAACc,KAAK,GAAG,KAAK;EACrB,IAAIC,MAAM,GAAGd,EAAE,CAACc,MAAM,GAAGd,EAAE,CAACI,KAAK,CAACC,MAAM,CAACU,MAAM;EAC/C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,EAAE,CAACiB,KAAK,CAACF,MAAM,EAAE,EAAEC,CAAC,EAAE;IACtC,MAAME,QAAQ,GAAGlB,EAAE,CAACiB,KAAK,CAACD,CAAC,CAAC;IAC5B,MAAM;MAAEZ,KAAK;MAAEe,GAAG;MAAEC,GAAG;MAAEC;IAAM,CAAC,GAAGH,QAAQ;IAC3C,MAAMI,KAAK,GAAGjC,YAAY,CAACe,KAAK,EAAE;MAC9BO,IAAI,EAAEL,MAAM;MACZiB,SAAS,EAAE,kBAAkB;MAC7BC,IAAI,EAAEL,GAAG,IAAIC,GAAG,GAAG,CAAC,CAAC;MACrBN,MAAM;MACNb,OAAO;MACPwB,YAAY,EAAEzB,EAAE,CAAC0B,MAAM;MACvBC,cAAc,EAAE;IACpB,CAAC,CAAC;IACF,IAAI,CAACL,KAAK,CAACM,KAAK,EAAE;MACd,IAAI,CAACN,KAAK,CAACO,MAAM,IAAI,CAACP,KAAK,CAACpB,GAAG,IAAI,CAACkB,GAAG,IAAI,CAACC,KAAK,EAAE;QAC/C,IAAIL,CAAC,KAAK,CAAC,IAAIM,KAAK,CAACQ,KAAK,EACtB7B,OAAO,CAACqB,KAAK,CAACQ,KAAK,EAAE,kBAAkB,EAAE,mBAAmBxB,MAAM,EAAE,CAAC,CAAC,KACrE,IAAIU,CAAC,GAAGhB,EAAE,CAACiB,KAAK,CAACF,MAAM,GAAG,CAAC,EAC5Bd,OAAO,CAACqB,KAAK,CAAClB,KAAK,EAAE,kBAAkB,EAAE,4BAA4BE,MAAM,EAAE,CAAC;QAClF,IAAIgB,KAAK,CAACS,OAAO,EAAE;UACf,IAAItB,IAAI,CAACsB,OAAO,EACZtB,IAAI,CAACsB,OAAO,IAAI,IAAI,GAAGT,KAAK,CAACS,OAAO,CAAC,KAErCtB,IAAI,CAACsB,OAAO,GAAGT,KAAK,CAACS,OAAO;QACpC;QACAjB,MAAM,GAAGQ,KAAK,CAACU,GAAG;QAClB;MACJ;MACA,IAAI,CAAC7B,KAAK,IAAIJ,GAAG,CAACkC,OAAO,CAACC,MAAM,IAAI5C,eAAe,CAAC6B,GAAG,CAAC,EACpDlB,OAAO,CAACkB,GAAG;MAAE;MACb,wBAAwB,EAAE,kEAAkE,CAAC;IACrG;IACA,IAAIH,CAAC,KAAK,CAAC,EAAE;MACT,IAAIM,KAAK,CAACQ,KAAK,EACX7B,OAAO,CAACqB,KAAK,CAACQ,KAAK,EAAE,kBAAkB,EAAE,mBAAmBxB,MAAM,EAAE,CAAC;IAC7E,CAAC,MACI;MACD,IAAI,CAACgB,KAAK,CAACQ,KAAK,EACZ7B,OAAO,CAACqB,KAAK,CAAClB,KAAK,EAAE,cAAc,EAAE,qBAAqBE,MAAM,QAAQ,CAAC;MAC7E,IAAIgB,KAAK,CAACS,OAAO,EAAE;QACf,IAAII,eAAe,GAAG,EAAE;QACxBC,IAAI,EAAE,KAAK,MAAMC,EAAE,IAAIjC,KAAK,EAAE;UAC1B,QAAQiC,EAAE,CAAC1C,IAAI;YACX,KAAK,OAAO;YACZ,KAAK,OAAO;cACR;YACJ,KAAK,SAAS;cACVwC,eAAe,GAAGE,EAAE,CAAChC,MAAM,CAACiC,SAAS,CAAC,CAAC,CAAC;cACxC,MAAMF,IAAI;YACd;cACI,MAAMA,IAAI;UAClB;QACJ;QACA,IAAID,eAAe,EAAE;UACjB,IAAII,IAAI,GAAG9B,IAAI,CAACQ,KAAK,CAACR,IAAI,CAACQ,KAAK,CAACF,MAAM,GAAG,CAAC,CAAC;UAC5C,IAAI/B,MAAM,CAACuD,IAAI,CAAC,EACZA,IAAI,GAAGA,IAAI,CAAClB,KAAK,IAAIkB,IAAI,CAACpB,GAAG;UACjC,IAAIoB,IAAI,CAACR,OAAO,EACZQ,IAAI,CAACR,OAAO,IAAI,IAAI,GAAGI,eAAe,CAAC,KAEvCI,IAAI,CAACR,OAAO,GAAGI,eAAe;UAClCb,KAAK,CAACS,OAAO,GAAGT,KAAK,CAACS,OAAO,CAACO,SAAS,CAACH,eAAe,CAACpB,MAAM,GAAG,CAAC,CAAC;QACvE;MACJ;IACJ;IACA,IAAI,CAACZ,KAAK,IAAI,CAACiB,GAAG,IAAI,CAACE,KAAK,CAACM,KAAK,EAAE;MAChC;MACA;MACA,MAAMY,SAAS,GAAGnB,KAAK,GACjBxB,WAAW,CAACE,GAAG,EAAEsB,KAAK,EAAEC,KAAK,EAAErB,OAAO,CAAC,GACvCH,gBAAgB,CAACC,GAAG,EAAEuB,KAAK,CAACU,GAAG,EAAEZ,GAAG,EAAE,IAAI,EAAEE,KAAK,EAAErB,OAAO,CAAC;MACjEQ,IAAI,CAACQ,KAAK,CAACwB,IAAI,CAACD,SAAS,CAAC;MAC1B1B,MAAM,GAAG0B,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC;MAC3B,IAAIjD,OAAO,CAAC4B,KAAK,CAAC,EACdpB,OAAO,CAACuC,SAAS,CAACE,KAAK,EAAE,eAAe,EAAElD,QAAQ,CAAC;IAC3D,CAAC,MACI;MACD;MACA;MACAO,GAAG,CAACc,KAAK,GAAG,IAAI;MAChB,MAAM8B,QAAQ,GAAGrB,KAAK,CAACU,GAAG;MAC1B,MAAMY,OAAO,GAAGzB,GAAG,GACbtB,WAAW,CAACE,GAAG,EAAEoB,GAAG,EAAEG,KAAK,EAAErB,OAAO,CAAC,GACrCH,gBAAgB,CAACC,GAAG,EAAE4C,QAAQ,EAAEvC,KAAK,EAAE,IAAI,EAAEkB,KAAK,EAAErB,OAAO,CAAC;MAClE,IAAIR,OAAO,CAAC0B,GAAG,CAAC,EACZlB,OAAO,CAAC2C,OAAO,CAACF,KAAK,EAAE,eAAe,EAAElD,QAAQ,CAAC;MACrDO,GAAG,CAACc,KAAK,GAAG,KAAK;MACjB;MACA,MAAMgC,UAAU,GAAGxD,YAAY,CAAC+B,GAAG,IAAI,EAAE,EAAE;QACvCT,IAAI,EAAEL,MAAM;QACZiB,SAAS,EAAE,eAAe;QAC1BC,IAAI,EAAEH,KAAK;QACXP,MAAM,EAAE8B,OAAO,CAACF,KAAK,CAAC,CAAC,CAAC;QACxBzC,OAAO;QACPwB,YAAY,EAAEzB,EAAE,CAAC0B,MAAM;QACvBC,cAAc,EAAE;MACpB,CAAC,CAAC;MACF,IAAIkB,UAAU,CAACjB,KAAK,EAAE;QAClB,IAAI,CAACzB,KAAK,IAAI,CAACmB,KAAK,CAACM,KAAK,IAAI7B,GAAG,CAACkC,OAAO,CAACC,MAAM,EAAE;UAC9C,IAAId,GAAG,EACH,KAAK,MAAMiB,EAAE,IAAIjB,GAAG,EAAE;YAClB,IAAIiB,EAAE,KAAKQ,UAAU,CAACjB,KAAK,EACvB;YACJ,IAAIS,EAAE,CAAC1C,IAAI,KAAK,SAAS,EAAE;cACvBM,OAAO,CAACoC,EAAE,EAAE,wBAAwB,EAAE,kEAAkE,CAAC;cACzG;YACJ;UACJ;UACJ,IAAIf,KAAK,CAAClB,KAAK,GAAGyC,UAAU,CAACjB,KAAK,CAACd,MAAM,GAAG,IAAI,EAC5Cb,OAAO,CAAC4C,UAAU,CAACjB,KAAK,EAAE,qBAAqB,EAAE,6FAA6F,CAAC;QACvJ;MACJ,CAAC,MACI,IAAIP,KAAK,EAAE;QACZ,IAAI,QAAQ,IAAIA,KAAK,IAAIA,KAAK,CAAChB,MAAM,IAAIgB,KAAK,CAAChB,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAC5DJ,OAAO,CAACoB,KAAK,EAAE,cAAc,EAAE,4BAA4Bf,MAAM,EAAE,CAAC,CAAC,KAErEL,OAAO,CAAC4C,UAAU,CAACzC,KAAK,EAAE,cAAc,EAAE,0BAA0BE,MAAM,QAAQ,CAAC;MAC3F;MACA;MACA,MAAMkC,SAAS,GAAGnB,KAAK,GACjBxB,WAAW,CAACE,GAAG,EAAEsB,KAAK,EAAEwB,UAAU,EAAE5C,OAAO,CAAC,GAC5C4C,UAAU,CAACjB,KAAK,GACZ9B,gBAAgB,CAACC,GAAG,EAAE8C,UAAU,CAACb,GAAG,EAAEZ,GAAG,EAAE,IAAI,EAAEyB,UAAU,EAAE5C,OAAO,CAAC,GACrE,IAAI;MACd,IAAIuC,SAAS,EAAE;QACX,IAAI/C,OAAO,CAAC4B,KAAK,CAAC,EACdpB,OAAO,CAACuC,SAAS,CAACE,KAAK,EAAE,eAAe,EAAElD,QAAQ,CAAC;MAC3D,CAAC,MACI,IAAIqD,UAAU,CAACd,OAAO,EAAE;QACzB,IAAIa,OAAO,CAACb,OAAO,EACfa,OAAO,CAACb,OAAO,IAAI,IAAI,GAAGc,UAAU,CAACd,OAAO,CAAC,KAE7Ca,OAAO,CAACb,OAAO,GAAGc,UAAU,CAACd,OAAO;MAC5C;MACA,MAAMe,IAAI,GAAG,IAAI7D,IAAI,CAAC2D,OAAO,EAAEJ,SAAS,CAAC;MACzC,IAAIzC,GAAG,CAACkC,OAAO,CAACc,gBAAgB,EAC5BD,IAAI,CAACE,QAAQ,GAAG9B,QAAQ;MAC5B,IAAIf,KAAK,EAAE;QACP,MAAM8C,GAAG,GAAGxC,IAAI;QAChB,IAAIlB,WAAW,CAACQ,GAAG,EAAEkD,GAAG,CAAChC,KAAK,EAAE2B,OAAO,CAAC,EACpC3C,OAAO,CAAC0C,QAAQ,EAAE,eAAe,EAAE,yBAAyB,CAAC;QACjEM,GAAG,CAAChC,KAAK,CAACwB,IAAI,CAACK,IAAI,CAAC;MACxB,CAAC,MACI;QACD,MAAMG,GAAG,GAAG,IAAI/D,OAAO,CAACa,GAAG,CAACW,MAAM,CAAC;QACnCuC,GAAG,CAACtC,IAAI,GAAG,IAAI;QACfsC,GAAG,CAAChC,KAAK,CAACwB,IAAI,CAACK,IAAI,CAAC;QACpB,MAAMI,QAAQ,GAAG,CAACV,SAAS,IAAII,OAAO,EAAEF,KAAK;QAC7CO,GAAG,CAACP,KAAK,GAAG,CAACE,OAAO,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEQ,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAC;QACxDzC,IAAI,CAACQ,KAAK,CAACwB,IAAI,CAACQ,GAAG,CAAC;MACxB;MACAnC,MAAM,GAAG0B,SAAS,GAAGA,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC,GAAGG,UAAU,CAACb,GAAG;IAC5D;EACJ;EACA,MAAMmB,WAAW,GAAGhD,KAAK,GAAG,GAAG,GAAG,GAAG;EACrC,MAAM,CAACiD,EAAE,EAAE,GAAGC,EAAE,CAAC,GAAGrD,EAAE,CAACgC,GAAG;EAC1B,IAAIsB,KAAK,GAAGxC,MAAM;EAClB,IAAIsC,EAAE,IAAIA,EAAE,CAAC/C,MAAM,KAAK8C,WAAW,EAC/BG,KAAK,GAAGF,EAAE,CAACtC,MAAM,GAAGsC,EAAE,CAAC/C,MAAM,CAACU,MAAM,CAAC,KACpC;IACD,MAAMwC,IAAI,GAAGjD,MAAM,CAAC,CAAC,CAAC,CAACkD,WAAW,CAAC,CAAC,GAAGlD,MAAM,CAACgC,SAAS,CAAC,CAAC,CAAC;IAC1D,MAAMmB,GAAG,GAAG7C,MAAM,GACZ,GAAG2C,IAAI,oBAAoBJ,WAAW,EAAE,GACxC,GAAGI,IAAI,qEAAqEJ,WAAW,EAAE;IAC/FlD,OAAO,CAACa,MAAM,EAAEF,MAAM,GAAG,cAAc,GAAG,YAAY,EAAE6C,GAAG,CAAC;IAC5D,IAAIL,EAAE,IAAIA,EAAE,CAAC/C,MAAM,CAACU,MAAM,KAAK,CAAC,EAC5BsC,EAAE,CAACK,OAAO,CAACN,EAAE,CAAC;EACtB;EACA,IAAIC,EAAE,CAACtC,MAAM,GAAG,CAAC,EAAE;IACf,MAAMiB,GAAG,GAAG5C,UAAU,CAACiE,EAAE,EAAEC,KAAK,EAAEvD,GAAG,CAACkC,OAAO,CAACC,MAAM,EAAEjC,OAAO,CAAC;IAC9D,IAAI+B,GAAG,CAACD,OAAO,EAAE;MACb,IAAItB,IAAI,CAACsB,OAAO,EACZtB,IAAI,CAACsB,OAAO,IAAI,IAAI,GAAGC,GAAG,CAACD,OAAO,CAAC,KAEnCtB,IAAI,CAACsB,OAAO,GAAGC,GAAG,CAACD,OAAO;IAClC;IACAtB,IAAI,CAACiC,KAAK,GAAG,CAAC1C,EAAE,CAACc,MAAM,EAAEwC,KAAK,EAAEtB,GAAG,CAAClB,MAAM,CAAC;EAC/C,CAAC,MACI;IACDL,IAAI,CAACiC,KAAK,GAAG,CAAC1C,EAAE,CAACc,MAAM,EAAEwC,KAAK,EAAEA,KAAK,CAAC;EAC1C;EACA,OAAO7C,IAAI;AACf;AAEA,SAASb,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}