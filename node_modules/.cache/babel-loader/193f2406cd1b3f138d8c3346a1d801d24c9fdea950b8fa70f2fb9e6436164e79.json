{"ast":null,"code":"export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = token => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = token => !!token && (token.type === 'scalar' || token.type === 'single-quoted-scalar' || token.type === 'double-quoted-scalar' || token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n  switch (token) {\n    case BOM:\n      return '<BOM>';\n    case DOCUMENT:\n      return '<DOC>';\n    case FLOW_END:\n      return '<FLOW_END>';\n    case SCALAR:\n      return '<SCALAR>';\n    default:\n      return JSON.stringify(token);\n  }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n  switch (source) {\n    case BOM:\n      return 'byte-order-mark';\n    case DOCUMENT:\n      return 'doc-mode';\n    case FLOW_END:\n      return 'flow-error-end';\n    case SCALAR:\n      return 'scalar';\n    case '---':\n      return 'doc-start';\n    case '...':\n      return 'doc-end';\n    case '':\n    case '\\n':\n    case '\\r\\n':\n      return 'newline';\n    case '-':\n      return 'seq-item-ind';\n    case '?':\n      return 'explicit-key-ind';\n    case ':':\n      return 'map-value-ind';\n    case '{':\n      return 'flow-map-start';\n    case '}':\n      return 'flow-map-end';\n    case '[':\n      return 'flow-seq-start';\n    case ']':\n      return 'flow-seq-end';\n    case ',':\n      return 'comma';\n  }\n  switch (source[0]) {\n    case ' ':\n    case '\\t':\n      return 'space';\n    case '#':\n      return 'comment';\n    case '%':\n      return 'directive-line';\n    case '*':\n      return 'alias';\n    case '&':\n      return 'anchor';\n    case '!':\n      return 'tag';\n    case \"'\":\n      return 'single-quoted-scalar';\n    case '\"':\n      return 'double-quoted-scalar';\n    case '|':\n    case '>':\n      return 'block-scalar-header';\n  }\n  return null;\n}\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };","map":{"version":3,"names":["createScalarToken","resolveAsScalar","setScalarValue","stringify","visit","BOM","DOCUMENT","FLOW_END","SCALAR","isCollection","token","isScalar","type","prettyToken","JSON","tokenType","source"],"sources":["/Users/linhankuan/fvl2025/node_modules/yaml/browser/dist/parse/cst.js"],"sourcesContent":["export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };\n"],"mappings":"AAAA,SAASA,iBAAiB,EAAEC,eAAe,EAAEC,cAAc,QAAQ,iBAAiB;AACpF,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,SAASC,KAAK,QAAQ,gBAAgB;;AAEtC;AACA,MAAMC,GAAG,GAAG,UAAU;AACtB;AACA,MAAMC,QAAQ,GAAG,MAAM,CAAC,CAAC;AACzB;AACA,MAAMC,QAAQ,GAAG,MAAM,CAAC,CAAC;AACzB;AACA,MAAMC,MAAM,GAAG,MAAM,CAAC,CAAC;AACvB;AACA,MAAMC,YAAY,GAAIC,KAAK,IAAK,CAAC,CAACA,KAAK,IAAI,OAAO,IAAIA,KAAK;AAC3D;AACA,MAAMC,QAAQ,GAAID,KAAK,IAAK,CAAC,CAACA,KAAK,KAC9BA,KAAK,CAACE,IAAI,KAAK,QAAQ,IACpBF,KAAK,CAACE,IAAI,KAAK,sBAAsB,IACrCF,KAAK,CAACE,IAAI,KAAK,sBAAsB,IACrCF,KAAK,CAACE,IAAI,KAAK,cAAc,CAAC;AACtC;AACA;AACA,SAASC,WAAWA,CAACH,KAAK,EAAE;EACxB,QAAQA,KAAK;IACT,KAAKL,GAAG;MACJ,OAAO,OAAO;IAClB,KAAKC,QAAQ;MACT,OAAO,OAAO;IAClB,KAAKC,QAAQ;MACT,OAAO,YAAY;IACvB,KAAKC,MAAM;MACP,OAAO,UAAU;IACrB;MACI,OAAOM,IAAI,CAACX,SAAS,CAACO,KAAK,CAAC;EACpC;AACJ;AACA;AACA,SAASK,SAASA,CAACC,MAAM,EAAE;EACvB,QAAQA,MAAM;IACV,KAAKX,GAAG;MACJ,OAAO,iBAAiB;IAC5B,KAAKC,QAAQ;MACT,OAAO,UAAU;IACrB,KAAKC,QAAQ;MACT,OAAO,gBAAgB;IAC3B,KAAKC,MAAM;MACP,OAAO,QAAQ;IACnB,KAAK,KAAK;MACN,OAAO,WAAW;IACtB,KAAK,KAAK;MACN,OAAO,SAAS;IACpB,KAAK,EAAE;IACP,KAAK,IAAI;IACT,KAAK,MAAM;MACP,OAAO,SAAS;IACpB,KAAK,GAAG;MACJ,OAAO,cAAc;IACzB,KAAK,GAAG;MACJ,OAAO,kBAAkB;IAC7B,KAAK,GAAG;MACJ,OAAO,eAAe;IAC1B,KAAK,GAAG;MACJ,OAAO,gBAAgB;IAC3B,KAAK,GAAG;MACJ,OAAO,cAAc;IACzB,KAAK,GAAG;MACJ,OAAO,gBAAgB;IAC3B,KAAK,GAAG;MACJ,OAAO,cAAc;IACzB,KAAK,GAAG;MACJ,OAAO,OAAO;EACtB;EACA,QAAQQ,MAAM,CAAC,CAAC,CAAC;IACb,KAAK,GAAG;IACR,KAAK,IAAI;MACL,OAAO,OAAO;IAClB,KAAK,GAAG;MACJ,OAAO,SAAS;IACpB,KAAK,GAAG;MACJ,OAAO,gBAAgB;IAC3B,KAAK,GAAG;MACJ,OAAO,OAAO;IAClB,KAAK,GAAG;MACJ,OAAO,QAAQ;IACnB,KAAK,GAAG;MACJ,OAAO,KAAK;IAChB,KAAK,GAAG;MACJ,OAAO,sBAAsB;IACjC,KAAK,GAAG;MACJ,OAAO,sBAAsB;IACjC,KAAK,GAAG;IACR,KAAK,GAAG;MACJ,OAAO,qBAAqB;EACpC;EACA,OAAO,IAAI;AACf;AAEA,SAASX,GAAG,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,YAAY,EAAEE,QAAQ,EAAEE,WAAW,EAAEE,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}