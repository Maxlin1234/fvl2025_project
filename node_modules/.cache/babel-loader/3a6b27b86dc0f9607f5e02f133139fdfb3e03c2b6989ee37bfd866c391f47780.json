{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.map.js\");\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n  args.sort();\n  const value = `[${args.join('-')}]`;\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  input = REPLACEMENTS[input] || input;\n  const opts = {\n    ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n  const negate = () => {\n    let count = 1;\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n    if (count % 2 === 0) {\n      return false;\n    }\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n  const extglobOpen = (type, value) => {\n    const token = {\n      ...EXTGLOB_CHARS[value],\n      conditions: 1,\n      inner: ''\n    };\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n    if (token.type === 'negate') {\n      let extglobStar = star;\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, {\n          ...options,\n          fastpaths: false\n        }).output;\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n      if (next === '.' || next === ';') {\n        continue;\n      }\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n      prev.value += value;\n      append({\n        value\n      });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n      let output = ')';\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += t.output || t.value;\n        }\n      }\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n    push(token);\n  }\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = {\n    ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n      case '**':\n        return nodot + globstar(opts);\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n  return source;\n};\nmodule.exports = parse;","map":{"version":3,"names":["require","constants","utils","MAX_LENGTH","POSIX_REGEX_SOURCE","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REPLACEMENTS","expandRange","args","options","sort","value","join","RegExp","ex","map","v","escapeRegex","syntaxError","type","char","parse","input","TypeError","opts","max","maxLength","Math","min","len","length","SyntaxError","bos","output","prepend","tokens","capture","PLATFORM_CHARS","globChars","windows","EXTGLOB_CHARS","extglobChars","DOT_LITERAL","PLUS_LITERAL","SLASH_LITERAL","ONE_CHAR","DOTS_SLASH","NO_DOT","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK","QMARK_NO_DOT","STAR","START_ANCHOR","globstar","dot","nodot","qmarkNoDot","star","bash","noext","noextglob","state","index","start","consumed","prefix","backtrack","negated","brackets","braces","parens","quotes","removePrefix","extglobs","stack","prev","eos","peek","n","advance","remaining","slice","consume","num","append","token","negate","count","increment","push","decrement","pop","tok","isBrace","isExtglob","extglob","inner","extglobOpen","conditions","open","extglobClose","close","rest","extglobStar","includes","test","expression","fastpaths","negatedExtglob","backslashes","replace","m","esc","chars","first","repeat","unescape","contains","wrapOutput","next","match","exec","slashes","posix","idx","lastIndexOf","pre","indexOf","keepQuotes","strictBrackets","nobracket","prevValue","literalBrackets","hasRegexChars","escaped","nobrace","outputIndex","tokensIndex","brace","dots","arr","range","i","unshift","comma","out","toks","t","isGroup","nonegate","regex","noglobstar","prior","before","isStart","afterStar","after","strictSlashes","end","escapeLast","suffix","NO_DOTS","slashDot","create","str","source","module","exports"],"sources":["/Users/linhankuan/fvl2025/node_modules/@rollup/pluginutils/node_modules/picomatch/lib/parse.js"],"sourcesContent":["'use strict';\n\nconst constants = require('./constants');\nconst utils = require('./utils');\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants.globChars(opts.windows);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index] || '';\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren') {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.output = (prev.output || prev.value) + tok.value;\n      prev.value += tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n    let rest;\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.inner.includes('*') && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.\n        // In this case, we need to parse the string and use it in the output of the original pattern.\n        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.\n        //\n        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.\n        const expression = parse(rest, { ...options, fastpaths: false }).output;\n\n        output = token.close = `)${expression})${extglobStar})`;\n      }\n\n      if (token.prev.type === 'bos') {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance();\n      } else {\n        value += advance();\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(opts.windows);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nmodule.exports = parse;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}