{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\n/*!\n * DrawSVGPlugin 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _toArray,\n  _doc,\n  _win,\n  _isEdge,\n  _coreInitted,\n  _warned,\n  _getStyleSaver,\n  _reverting,\n  _windowExists = () => typeof window !== \"undefined\",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n  //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n  _types = {\n    rect: [\"width\", \"height\"],\n    circle: [\"r\", \"r\"],\n    ellipse: [\"rx\", \"ry\"],\n    line: [\"x2\", \"y2\"]\n  },\n  _round = value => Math.round(value * 10000) / 10000,\n  _parseNum = value => parseFloat(value) || 0,\n  _parseSingleVal = (value, length) => {\n    let num = _parseNum(value);\n    return ~value.indexOf(\"%\") ? num / 100 * length : num;\n  },\n  _getAttributeAsNumber = (target, attr) => _parseNum(target.getAttribute(attr)),\n  _sqrt = Math.sqrt,\n  _getDistance = (x1, y1, x2, y2, scaleX, scaleY) => _sqrt(((_parseNum(x2) - _parseNum(x1)) * scaleX) ** 2 + ((_parseNum(y2) - _parseNum(y1)) * scaleY) ** 2),\n  _warn = message => console.warn(message),\n  _hasNonScalingStroke = target => target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\",\n  _bonusValidated = 1,\n  //<name>DrawSVGPlugin</name>\n  //accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n  _parse = (value, length, defaultStart) => {\n    let i = value.indexOf(\" \"),\n      s,\n      e;\n    if (i < 0) {\n      s = defaultStart !== undefined ? defaultStart + \"\" : value;\n      e = value;\n    } else {\n      s = value.substr(0, i);\n      e = value.substr(i + 1);\n    }\n    s = _parseSingleVal(s, length);\n    e = _parseSingleVal(e, length);\n    return s > e ? [e, s] : [s, e];\n  },\n  _getLength = target => {\n    target = _toArray(target)[0];\n    if (!target) {\n      return 0;\n    }\n    let type = target.tagName.toLowerCase(),\n      style = target.style,\n      scaleX = 1,\n      scaleY = 1,\n      length,\n      bbox,\n      points,\n      prevPoint,\n      i,\n      rx,\n      ry;\n    if (_hasNonScalingStroke(target)) {\n      //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n      scaleY = target.getScreenCTM();\n      scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n      scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n    }\n    try {\n      //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n      bbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n    } catch (e) {\n      //firefox has a bug that throws an error if the element isn't visible.\n      _warn(\"Some browsers won't measure invisible elements (like display:none or masks inside defs).\");\n    }\n    let {\n      x,\n      y,\n      width,\n      height\n    } = bbox || {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    if ((!bbox || !width && !height) && _types[type]) {\n      //if the element isn't visible, try to discern width/height using its attributes.\n      width = _getAttributeAsNumber(target, _types[type][0]);\n      height = _getAttributeAsNumber(target, _types[type][1]);\n      if (type !== \"rect\" && type !== \"line\") {\n        //double the radius for circles and ellipses\n        width *= 2;\n        height *= 2;\n      }\n      if (type === \"line\") {\n        x = _getAttributeAsNumber(target, \"x1\");\n        y = _getAttributeAsNumber(target, \"y1\");\n        width = Math.abs(width - x);\n        height = Math.abs(height - y);\n      }\n    }\n    if (type === \"path\") {\n      prevPoint = style.strokeDasharray;\n      style.strokeDasharray = \"none\";\n      length = target.getTotalLength() || 0;\n      _round(scaleX) !== _round(scaleY) && !_warned && (_warned = 1) && _warn(\"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n      length *= (scaleX + scaleY) / 2;\n      style.strokeDasharray = prevPoint;\n    } else if (type === \"rect\") {\n      length = width * 2 * scaleX + height * 2 * scaleY;\n    } else if (type === \"line\") {\n      length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\n    } else if (type === \"polyline\" || type === \"polygon\") {\n      points = target.getAttribute(\"points\").match(_numExp) || [];\n      type === \"polygon\" && points.push(points[0], points[1]);\n      length = 0;\n      for (i = 2; i < points.length; i += 2) {\n        length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;\n      }\n    } else if (type === \"circle\" || type === \"ellipse\") {\n      rx = width / 2 * scaleX;\n      ry = height / 2 * scaleY;\n      length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));\n    }\n    return length || 0;\n  },\n  _getPosition = (target, length) => {\n    target = _toArray(target)[0];\n    if (!target) {\n      return [0, 0];\n    }\n    length || (length = _getLength(target) + 1);\n    let cs = _win.getComputedStyle(target),\n      dash = cs.strokeDasharray || \"\",\n      offset = _parseNum(cs.strokeDashoffset),\n      i = dash.indexOf(\",\");\n    i < 0 && (i = dash.indexOf(\" \"));\n    dash = i < 0 ? length : _parseNum(dash.substr(0, i));\n    dash > length && (dash = length);\n    return [-offset || 0, dash - offset || 0];\n  },\n  _initCore = () => {\n    if (_windowExists()) {\n      _doc = document;\n      _win = window;\n      _coreInitted = gsap = _getGSAP();\n      _toArray = gsap.utils.toArray;\n      _getStyleSaver = gsap.core.getStyleSaver;\n      _reverting = gsap.core.reverting || function () {};\n      _isEdge = ((_win.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1; //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n    }\n  };\nexport const DrawSVGPlugin = {\n  version: \"3.13.0\",\n  name: \"drawSVG\",\n  register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    if (!target.getBBox) {\n      return false;\n    }\n    _coreInitted || _initCore();\n    let length = _getLength(target),\n      start,\n      end,\n      cs;\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"strokeDashoffset,strokeDasharray,strokeMiterlimit\");\n    this.tween = tween;\n    this._style = target.style;\n    this._target = target;\n    if (value + \"\" === \"true\") {\n      value = \"0 100%\";\n    } else if (!value) {\n      value = \"0 0\";\n    } else if ((value + \"\").indexOf(\" \") === -1) {\n      value = \"0 \" + value;\n    }\n    start = _getPosition(target, length);\n    end = _parse(value, length, start[0]);\n    this._length = _round(length);\n    this._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n    this._offset = _round(-start[0]);\n    this._dashPT = this.add(this, \"_dash\", this._dash, _round(end[1] - end[0]), 0, 0, 0, 0, 0, 1);\n    this._offsetPT = this.add(this, \"_offset\", this._offset, _round(-end[0]), 0, 0, 0, 0, 0, 1);\n    if (_isEdge) {\n      //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n      cs = _win.getComputedStyle(target);\n      if (cs.strokeLinecap !== cs.strokeLinejoin) {\n        end = _parseNum(cs.strokeMiterlimit);\n        this.add(target.style, \"strokeMiterlimit\", end, end + 0.01);\n      }\n    }\n    this._live = _hasNonScalingStroke(target) || ~(value + \"\").indexOf(\"live\");\n    this._nowrap = ~(value + \"\").indexOf(\"nowrap\");\n    this._props.push(\"drawSVG\");\n    return _bonusValidated;\n  },\n  render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      let pt = data._pt,\n        style = data._style,\n        length,\n        lengthRatio,\n        dash,\n        offset;\n      if (pt) {\n        //when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n        if (data._live) {\n          length = _getLength(data._target);\n          if (length !== data._length) {\n            lengthRatio = length / data._length;\n            data._length = length;\n            if (data._offsetPT) {\n              data._offsetPT.s *= lengthRatio;\n              data._offsetPT.c *= lengthRatio;\n            }\n            if (data._dashPT) {\n              data._dashPT.s *= lengthRatio;\n              data._dashPT.c *= lengthRatio;\n            } else {\n              data._dash *= lengthRatio;\n            }\n          }\n        }\n        while (pt) {\n          pt.r(ratio, pt.d);\n          pt = pt._next;\n        }\n        dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0; // only let it be zero if it's at the start or end of the tween.\n        length = data._length - dash + 0.1;\n        offset = data._offset;\n        dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.05 && (offset += offset < 0 ? 0.005 : -0.005) && (length += 0.005);\n        style.strokeDashoffset = dash ? offset : offset + 0.001;\n        style.strokeDasharray = length < 0.1 ? \"none\" : dash ? dash + \"px,\" + (data._nowrap ? 999999 : length) + \"px\" : \"0px, 999999px\";\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  getLength: _getLength,\n  getPosition: _getPosition\n};\n_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\nexport { DrawSVGPlugin as default };","map":{"version":3,"names":["gsap","_toArray","_doc","_win","_isEdge","_coreInitted","_warned","_getStyleSaver","_reverting","_windowExists","window","_getGSAP","registerPlugin","_numExp","_types","rect","circle","ellipse","line","_round","value","Math","round","_parseNum","parseFloat","_parseSingleVal","length","num","indexOf","_getAttributeAsNumber","target","attr","getAttribute","_sqrt","sqrt","_getDistance","x1","y1","x2","y2","scaleX","scaleY","_warn","message","console","warn","_hasNonScalingStroke","_bonusValidated","_parse","defaultStart","i","s","e","undefined","substr","_getLength","type","tagName","toLowerCase","style","bbox","points","prevPoint","rx","ry","getScreenCTM","a","b","d","c","getBBox","x","y","width","height","abs","strokeDasharray","getTotalLength","match","push","PI","_getPosition","cs","getComputedStyle","dash","offset","strokeDashoffset","_initCore","document","utils","toArray","core","getStyleSaver","reverting","navigator","userAgent","DrawSVGPlugin","version","name","register","init","tween","index","targets","start","end","styles","_style","_target","_length","_dash","_offset","_dashPT","add","_offsetPT","strokeLinecap","strokeLinejoin","strokeMiterlimit","_live","_nowrap","_props","render","ratio","data","_time","pt","_pt","lengthRatio","r","_next","revert","getLength","getPosition","default"],"sources":["/Users/linhankuan/fvl2025/node_modules/gsap/src/DrawSVGPlugin.js"],"sourcesContent":["/*!\n * DrawSVGPlugin 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\n\nlet gsap, _toArray, _doc, _win, _isEdge, _coreInitted, _warned, _getStyleSaver, _reverting,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi, //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n\t_types = {rect:[\"width\",\"height\"], circle:[\"r\",\"r\"], ellipse:[\"rx\",\"ry\"], line:[\"x2\",\"y2\"]},\n\t_round = value => Math.round(value * 10000) / 10000,\n\t_parseNum = value => parseFloat(value) || 0,\n\t_parseSingleVal = (value, length) => {\n\t\tlet num = _parseNum(value);\n\t\treturn ~value.indexOf(\"%\") ? num / 100 * length : num;\n\t},\n\t_getAttributeAsNumber = (target, attr) => _parseNum(target.getAttribute(attr)),\n\t_sqrt = Math.sqrt,\n\t_getDistance = (x1, y1, x2, y2, scaleX, scaleY) => _sqrt(((_parseNum(x2) - _parseNum(x1)) * scaleX) ** 2 + ((_parseNum(y2) - _parseNum(y1)) * scaleY) ** 2),\n\t_warn = message => console.warn(message),\n\t_hasNonScalingStroke = target => target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\",\n\t_bonusValidated = 1, //<name>DrawSVGPlugin</name>\n\t//accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n\t_parse = (value, length, defaultStart) => {\n\t\tlet i = value.indexOf(\" \"),\n\t\t\ts, e;\n\t\tif (i < 0) {\n\t\t\ts = defaultStart !== undefined ? defaultStart + \"\" : value;\n\t\t\te = value;\n\t\t} else {\n\t\t\ts = value.substr(0, i);\n\t\t\te = value.substr(i + 1);\n\t\t}\n\t\ts = _parseSingleVal(s, length);\n\t\te = _parseSingleVal(e, length);\n\t\treturn (s > e) ? [e, s] : [s, e];\n\t},\n\t_getLength = target => {\n\t\ttarget = _toArray(target)[0];\n\t\tif (!target) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet type = target.tagName.toLowerCase(),\n\t\t\tstyle = target.style,\n\t\t\tscaleX = 1,\n\t\t\tscaleY = 1,\n\t\t\tlength, bbox, points, prevPoint, i, rx, ry;\n\t\tif (_hasNonScalingStroke(target)) { //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n\t\t\tscaleY = target.getScreenCTM();\n\t\t\tscaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n\t\t\tscaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n\t\t}\n\t\ttry { //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n\t\t\tbbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n\t\t} catch (e) {\n\t\t\t//firefox has a bug that throws an error if the element isn't visible.\n\t\t\t_warn(\"Some browsers won't measure invisible elements (like display:none or masks inside defs).\");\n\t\t}\n\t\tlet {x, y, width, height} = bbox || {x:0, y:0, width:0, height:0};\n\t\tif ((!bbox || (!width && !height)) && _types[type]) { //if the element isn't visible, try to discern width/height using its attributes.\n\t\t\twidth =_getAttributeAsNumber(target, _types[type][0]);\n\t\t\theight = _getAttributeAsNumber(target, _types[type][1]);\n\t\t\tif (type !== \"rect\" && type !== \"line\") { //double the radius for circles and ellipses\n\t\t\t\twidth *= 2;\n\t\t\t\theight *= 2;\n\t\t\t}\n\t\t\tif (type === \"line\") {\n\t\t\t\tx = _getAttributeAsNumber(target, \"x1\");\n\t\t\t\ty = _getAttributeAsNumber(target, \"y1\");\n\t\t\t\twidth = Math.abs(width - x);\n\t\t\t\theight = Math.abs(height - y);\n\t\t\t}\n\t\t}\n\t\tif (type === \"path\") {\n\t\t\tprevPoint = style.strokeDasharray;\n\t\t\tstyle.strokeDasharray = \"none\";\n\t\t\tlength = target.getTotalLength() || 0;\n\t\t\t_round(scaleX) !== _round(scaleY) && !_warned && (_warned = 1) && _warn(\"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n\t\t\tlength *= (scaleX + scaleY) / 2;\n\t\t\tstyle.strokeDasharray = prevPoint;\n\t\t} else if (type === \"rect\") {\n\t\t\tlength = width * 2 * scaleX + height * 2 * scaleY;\n\t\t} else if (type === \"line\") {\n\t\t\tlength = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\n\t\t} else if (type === \"polyline\" || type === \"polygon\") {\n\t\t\tpoints = target.getAttribute(\"points\").match(_numExp) || [];\n\t\t\ttype === \"polygon\" && points.push(points[0], points[1]);\n\t\t\tlength = 0;\n\t\t\tfor (i = 2; i < points.length; i+=2) {\n\t\t\t\tlength += _getDistance(points[i-2], points[i-1], points[i], points[i+1], scaleX, scaleY) || 0;\n\t\t\t}\n\t\t} else if (type === \"circle\" || type === \"ellipse\") {\n\t\t\trx = (width / 2) * scaleX;\n\t\t\try = (height / 2) * scaleY;\n\t\t\tlength = Math.PI * ( 3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)) );\n\t\t}\n\t\treturn length || 0;\n\t},\n\t_getPosition = (target, length) => {\n\t\ttarget = _toArray(target)[0];\n\t\tif (!target) {\n\t\t\treturn [0, 0];\n\t\t}\n\t\tlength || (length = _getLength(target) + 1);\n\t\tlet cs = _win.getComputedStyle(target),\n\t\t\tdash = cs.strokeDasharray || \"\",\n\t\t\toffset = _parseNum(cs.strokeDashoffset),\n\t\t\ti = dash.indexOf(\",\");\n\t\ti < 0 && (i = dash.indexOf(\" \"));\n\t\tdash = i < 0 ? length : _parseNum(dash.substr(0, i));\n\t\tdash > length && (dash = length);\n\t\treturn [-offset || 0, (dash - offset) || 0];\n\t},\n\t_initCore = () => {\n\t\tif (_windowExists()) {\n\t\t\t_doc = document;\n\t\t\t_win = window;\n\t\t\t_coreInitted = gsap = _getGSAP();\n\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t_getStyleSaver = gsap.core.getStyleSaver;\n\t\t\t_reverting = gsap.core.reverting || function() {};\n\t\t\t_isEdge = (((_win.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1); //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n\t\t}\n\t};\n\n\nexport const DrawSVGPlugin = {\n\tversion:\"3.13.0\",\n\tname:\"drawSVG\",\n\tregister(core) {\n\t\tgsap = core;\n\t\t_initCore();\n\t},\n\tinit(target, value, tween, index, targets) {\n\t\tif (!target.getBBox) {\n\t\t\treturn false;\n\t\t}\n\t\t_coreInitted ||\t_initCore();\n\t\tlet length = _getLength(target),\n\t\t\tstart, end, cs;\n\t\tthis.styles = _getStyleSaver && _getStyleSaver(target, \"strokeDashoffset,strokeDasharray,strokeMiterlimit\");\n\t\tthis.tween = tween;\n\t\tthis._style = target.style;\n\t\tthis._target = target;\n\t\tif (value + \"\" === \"true\") {\n\t\t\tvalue = \"0 100%\";\n\t\t} else if (!value) {\n\t\t\tvalue = \"0 0\";\n\t\t} else if ((value + \"\").indexOf(\" \") === -1) {\n\t\t\tvalue = \"0 \" + value;\n\t\t}\n\t\tstart = _getPosition(target, length);\n\t\tend = _parse(value, length, start[0]);\n\t\tthis._length = _round(length);\n\t\tthis._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n\t\tthis._offset = _round(-start[0]);\n\t\tthis._dashPT = this.add(this, \"_dash\", this._dash, _round(end[1] - end[0]), 0, 0, 0, 0, 0, 1);\n\t\tthis._offsetPT = this.add(this, \"_offset\", this._offset, _round(-end[0]), 0, 0, 0, 0, 0, 1);\n\t\tif (_isEdge) { //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n\t\t\tcs = _win.getComputedStyle(target);\n\t\t\tif (cs.strokeLinecap !== cs.strokeLinejoin) {\n\t\t\t\tend = _parseNum(cs.strokeMiterlimit);\n\t\t\t\tthis.add(target.style, \"strokeMiterlimit\", end, end + 0.01);\n\t\t\t}\n\t\t}\n\t\tthis._live = (_hasNonScalingStroke(target) || ~((value + \"\").indexOf(\"live\")));\n\t\tthis._nowrap = ~(value + \"\").indexOf(\"nowrap\");\n\t\tthis._props.push(\"drawSVG\");\n\t\treturn _bonusValidated;\n\t},\n\trender(ratio, data) {\n\t\tif (data.tween._time || !_reverting()) {\n\t\t\tlet pt = data._pt,\n\t\t\t\tstyle = data._style,\n\t\t\t\tlength, lengthRatio, dash, offset;\n\t\t\tif (pt) {\n\t\t\t\t//when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n\t\t\t\tif (data._live) {\n\t\t\t\t\tlength = _getLength(data._target);\n\t\t\t\t\tif (length !== data._length) {\n\t\t\t\t\t\tlengthRatio = length / data._length;\n\t\t\t\t\t\tdata._length = length;\n\t\t\t\t\t\tif (data._offsetPT) {\n\t\t\t\t\t\t\tdata._offsetPT.s *= lengthRatio;\n\t\t\t\t\t\t\tdata._offsetPT.c *= lengthRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (data._dashPT) {\n\t\t\t\t\t\t\tdata._dashPT.s *= lengthRatio;\n\t\t\t\t\t\t\tdata._dashPT.c *= lengthRatio;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdata._dash *= lengthRatio;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (pt) {\n\t\t\t\t\tpt.r(ratio, pt.d);\n\t\t\t\t\tpt = pt._next;\n\t\t\t\t}\n\t\t\t\tdash = data._dash || ((ratio && ratio !== 1 && 0.0001) || 0); // only let it be zero if it's at the start or end of the tween.\n\t\t\t\tlength = data._length - dash + 0.1;\n\t\t\t\toffset = data._offset;\n\t\t\t\tdash && offset && dash + Math.abs(offset % data._length) > data._length - 0.05 && (offset += offset < 0 ? 0.005 : -0.005) && (length += 0.005);\n\t\t\t\tstyle.strokeDashoffset = dash ? offset : offset + 0.001;\n\t\t\t\tstyle.strokeDasharray = length < 0.1 ? \"none\" : dash ? dash + \"px,\" + (data._nowrap ? 999999 : length) + \"px\" : \"0px, 999999px\";\n\t\t\t}\n\t\t} else {\n\t\t\tdata.styles.revert();\n\t\t}\n\t},\n\tgetLength: _getLength,\n\tgetPosition: _getPosition\n};\n\n_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\n\nexport { DrawSVGPlugin as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}