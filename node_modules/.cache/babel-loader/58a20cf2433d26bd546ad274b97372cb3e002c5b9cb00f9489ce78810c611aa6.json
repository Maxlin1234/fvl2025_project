{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  id: \"imageContainer\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1);\n}","map":{"version":3,"names":["id","_createElementBlock","_hoisted_1"],"sources":["/Users/linhankuan/fvl2025/src/components/Banner.vue"],"sourcesContent":["<template>\n  <div id=\"imageContainer\"></div>\n</template>\n\n<script>\nimport * as THREE from 'three';\n\nexport default {\n  name: 'Ban-ner',\n  mounted() {\n    const container = this.$el;\n\n    const loader = new THREE.TextureLoader();\n    loader.load(require('@/assets/2025banner.jpg'), (texture) => {\n      initScene(texture);\n    });\n\n    const vertexShader = `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `;\n\n    const fragmentShader = `\n      varying vec2 vUv;\n      uniform sampler2D u_texture;\n      uniform vec2 u_mouse;\n      uniform vec2 u_prevMouse;\n      uniform float u_aberrationIntensity;\n\n      void main() {\n        vec2 gridUV = floor(vUv * vec2(20.0)) / vec2(20.0);\n        vec2 centerOfPixel = gridUV + vec2(1.0 / 20.0);\n        vec2 mouseDirection = u_mouse - u_prevMouse;\n        vec2 pixelToMouse = centerOfPixel - u_mouse;\n        float dist = length(pixelToMouse);\n        float strength = smoothstep(0.2, 0.0, dist);\n        vec2 uvOffset = strength * -mouseDirection * 2.5;\n        vec2 uv = vUv - uvOffset;\n\n        vec4 r = texture2D(u_texture, uv - vec2(strength * u_aberrationIntensity * 0.0, 0.0));\n        vec4 g = texture2D(u_texture, uv + vec2(strength * u_aberrationIntensity * 0.02, 0.0));\n        vec4 b = texture2D(u_texture, uv - vec2(strength * u_aberrationIntensity * 0.01, 0.0));\n\n        gl_FragColor = vec4(r.r, g.g, b.b, 1.0);\n      }\n    `;\n\n    let scene, camera, renderer, plane, sphere;\n    const mouse = new THREE.Vector2(0.2, 0.2);\n    const prevMouse = new THREE.Vector2(0.5, 0.5);\n    let aberration = 0;\n\n    // 用UV來大致指定最大圓的位置，可視需要微調\n    const circleUVX = 0.50; // 0~1 左右\n    const circleUVY = 0.52; // 0~1 上下(0底 1頂)\n    let planeWidth = 1, planeHeight = 1;\n    let baseSphereRadius = 0.2; // 之後會依視窗比例換算\n\n    function initScene(texture) {\n      // renderer\n      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      renderer.setPixelRatio(window.devicePixelRatio);\n      renderer.domElement.style.position = 'absolute';\n      renderer.domElement.style.inset = '0';\n      container.appendChild(renderer.domElement);\n\n      // scene & camera\n      scene = new THREE.Scene();\n      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10);\n      camera.position.z = 1;\n\n      const uniforms = {\n        u_texture: { value: texture },\n        u_mouse: { value: mouse.clone() },\n        u_prevMouse: { value: prevMouse.clone() },\n        u_aberrationIntensity: { value: 0.0 }\n      };\n\n      // 根據FOV求出z=0平面可視寬高，讓plane正好鋪滿\n      const fov = (camera.fov * Math.PI) / 180;\n      planeHeight = 2 * Math.tan(fov / 2) * camera.position.z;\n      planeWidth = planeHeight * camera.aspect;\n\n      const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);\n      const material = new THREE.ShaderMaterial({ uniforms, vertexShader, fragmentShader });\n      plane = new THREE.Mesh(geometry, material);\n      scene.add(plane);\n\n      // 加入可自轉球體(置於plane前方一點點)\n      addRotatingSphere();\n\n      // 監聽\n      animate();\n      window.addEventListener('resize', onResize);\n      container.addEventListener('mousemove', onMouseMove);\n    }\n\n    function addRotatingSphere() {\n      // 基於目前plane尺寸，估算球半徑(占螢高的某比例)\n      baseSphereRadius = planeHeight * 0.18; // 可視需要微調大小\n      const sphereGeo = new THREE.SphereGeometry(baseSphereRadius, 64, 64);\n      const sphereMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35, metalness: 0.15 });\n      sphere = new THREE.Mesh(sphereGeo, sphereMat);\n\n      // 打光\n      const ambient = new THREE.AmbientLight(0xffffff, 0.6);\n      const dir = new THREE.DirectionalLight(0xffffff, 0.9);\n      dir.position.set(1, 1, 1);\n      scene.add(ambient, dir);\n\n      // 依UV定位到plane上的對應世界座標\n      const target = uvToWorld(circleUVX, circleUVY);\n      sphere.position.set(target.x, target.y, 0.05); // 往鏡頭方向一點，蓋過plane\n      scene.add(sphere);\n    }\n\n    function uvToWorld(u, v) {\n      // plane置中，x: [-planeWidth/2, +planeWidth/2]；y同理\n      const x = (u - 0.5) * planeWidth;\n      const y = (v - 0.5) * planeHeight;\n      return new THREE.Vector3(x, y, 0);\n    }\n\n    function onMouseMove(e) {\n      const rect = container.getBoundingClientRect();\n      prevMouse.copy(mouse);\n      mouse.x = (e.clientX - rect.left) / rect.width;\n      mouse.y = 1 - (e.clientY - rect.top) / rect.height;\n      aberration = 1.0;\n    }\n\n    function onResize() {\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n\n      // 重新計算plane可視寬高、縮放以維持鋪滿\n      const fov = (camera.fov * Math.PI) / 180;\n      const newHeight = 2 * Math.tan(fov / 2) * camera.position.z;\n      const newWidth = newHeight * camera.aspect;\n\n      const scaleX = newWidth / planeWidth;\n      const scaleY = newHeight / planeHeight;\n      plane.scale.set(scaleX, scaleY, 1);\n\n      // 更新參考尺寸\n      planeWidth = newWidth;\n      planeHeight = newHeight;\n\n      // 重新定位與調整球大小\n      if (sphere) {\n        const target = uvToWorld(circleUVX, circleUVY);\n        sphere.position.set(target.x, target.y, 0.05);\n        const newRadius = planeHeight * 0.18;\n        const scaleR = newRadius / baseSphereRadius;\n        sphere.scale.set(scaleR, scaleR, scaleR);\n      }\n    }\n\n    function animate() {\n      requestAnimationFrame(animate);\n\n      if (plane) {\n        plane.material.uniforms.u_mouse.value.copy(mouse);\n        plane.material.uniforms.u_prevMouse.value.copy(prevMouse);\n        aberration = Math.max(0.0, aberration - 0.005);\n        plane.material.uniforms.u_aberrationIntensity.value = aberration;\n      }\n\n      if (sphere) {\n        sphere.rotation.y += 0.01;\n        sphere.rotation.x += 0.003;\n      }\n\n      renderer.render(scene, camera);\n    }\n  }\n};\n</script>\n\n<style>\n#imageContainer {\n  position: relative;\n  width: 100vw;\n  height: 100vh;\n  overflow: hidden;\n}\n\n@media (max-width:768px){\n  #imageContainer {\n    height: 100svh; /* 避免手機瀏覽器 UI 影響顯示高度 */\n  }\n}\n\ncanvas {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  pointer-events: none;\n  position: absolute;\n  display: block;\n  inset: 0;\n}\n</style>\n"],"mappings":";;EACOA,EAAE,EAAC;AAAgB;;uBAAxBC,mBAAA,CAA+B,OAA/BC,UAA+B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}