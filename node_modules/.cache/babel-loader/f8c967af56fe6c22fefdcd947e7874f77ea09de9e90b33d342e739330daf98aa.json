{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"container\",\n  class: \"three-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_hoisted_1"],"sources":["/Users/linhankuan/fvl2025/src/components/ThreeSphere.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from 'three'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'\n\nexport default {\n  name: 'ThreeSphere',\n  props: {\n    modelPath: {\n      type: String,\n      default: '/sphere.glb'\n    }\n  },\n  data() {\n    return {\n      renderer: null,\n      scene: null,\n      camera: null,\n      animationId: null,\n      model: null,\n      resizeObserver: null\n    }\n  },\n  mounted() {\n    this.initScene()\n    this.loadModel()\n    this.onResize()\n    window.addEventListener('resize', this.onResize)\n  },\n  beforeUnmount() {\n    window.removeEventListener('resize', this.onResize)\n    cancelAnimationFrame(this.animationId)\n    if (this.resizeObserver) this.resizeObserver.disconnect()\n    if (this.renderer) {\n      this.renderer.dispose()\n      this.renderer.forceContextLoss && this.renderer.forceContextLoss()\n      this.renderer.domElement = null\n      this.renderer = null\n    }\n    if (this.scene) {\n      this.scene.traverse((obj) => {\n        if (obj.isMesh) {\n          obj.geometry && obj.geometry.dispose && obj.geometry.dispose()\n          if (obj.material) {\n            const materials = Array.isArray(obj.material) ? obj.material : [obj.material]\n            materials.forEach((m) => {\n              Object.keys(m).forEach((k) => {\n                if (m[k] && m[k].isTexture) m[k].dispose && m[k].dispose()\n              })\n              m.dispose && m.dispose()\n            })\n          }\n        }\n      })\n      this.scene = null\n    }\n  },\n  methods: {\n    initScene() {\n      const container = this.$refs.container\n      const width = container.clientWidth || 300\n      const height = container.clientHeight || 300\n\n      this.scene = new THREE.Scene()\n      this.scene.background = null\n\n      this.camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100)\n      this.camera.position.set(0, 0, 3)\n\n      // lights\n      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0)\n      this.scene.add(hemi)\n      const dir = new THREE.DirectionalLight(0xffffff, 0.8)\n      dir.position.set(5, 5, 5)\n      dir.castShadow = true\n      this.scene.add(dir)\n\n      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })\n      this.renderer.setSize(width, height)\n      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n      this.renderer.shadowMap.enabled = true\n      container.appendChild(this.renderer.domElement)\n\n      this.animate()\n    },\n    loadModel() {\n      const loader = new GLTFLoader()\n      loader.load(\n        this.modelPath,\n        (gltf) => {\n          this.model = gltf.scene\n          // Optional: find specific mesh to set shadow flags\n          this.model.traverse((obj) => {\n            if (obj.isMesh) {\n              obj.castShadow = true\n              obj.receiveShadow = true\n            }\n          })\n          // Center and scale to fit\n          const box = new THREE.Box3().setFromObject(this.model)\n          const size = new THREE.Vector3()\n          box.getSize(size)\n          const maxAxis = Math.max(size.x, size.y, size.z) || 1\n          const scale = 1.2 / maxAxis\n          this.model.scale.setScalar(scale)\n          // Center\n          const center = new THREE.Vector3()\n          box.getCenter(center)\n          this.model.position.sub(center.multiplyScalar(scale))\n\n          this.scene.add(this.model)\n        },\n        undefined,\n        (err) => {\n          console.error('Failed to load GLB', err)\n        }\n      )\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate)\n      if (this.model) {\n        this.model.rotation.y += 0.01\n      }\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    },\n    onResize() {\n      const container = this.$refs.container\n      if (!container || !this.renderer || !this.camera) return\n      const width = container.clientWidth\n      const height = container.clientHeight\n      if (!width || !height) return\n      this.renderer.setSize(width, height)\n      this.camera.aspect = width / height\n      this.camera.updateProjectionMatrix()\n    }\n  }\n}\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n}\n</style> "],"mappings":";;EACOA,GAAG,EAAC,WAAW;EAACC,KAAK,EAAC;;;uBAA3BC,mBAAA,CAAmD,OAAnDC,UAAmD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}